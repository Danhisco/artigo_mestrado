---
title: "Simulação: Exemplo Minimo"
author: "Danilo Pereira Mori"
date: "2022-10-17"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=TRUE,echo=FALSE}
knitr::opts_chunk$set(echo = FALSE, tidy = FALSE, include = TRUE, warning = FALSE,cache = TRUE,message=FALSE,eval=FALSE)
```

```{r pacotes}
library(doMC)
library(readr)
library(purrr)
library(stringr)
library(tidyr)
library(plyr)
library(dplyr)
select <- dplyr::select
```


```{r dados para simulacao,echo=FALSE,eval=FALSE,include=FALSE}
df_sims <- read.csv("./simulacao_codigos_e_resultados/df_simulacao.csv",header = TRUE)  |> 
  filter(p == max(p)) |> arrange(d) |> select(!(U_med:theta),-DA,-p,-Ntotal)
# replicas
n_rep.U <- 10
func1 <- function(x,replicas=n_rep.U) {
  x$U <- NA
  x <- x[rep(1:dim(x)[1],each=replicas),]
}
# nomes
df_simulacao.U <- df_sims  |>
  func1() |> 
  mutate(.n=1:n(),
         txt.name = gsub("/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/dados_para_iniciar_artigo/",
                         "",txt.name))
write_csv(df_simulacao.U,file="./simulacao/df_simulacao.csv")
```

  
## Introdução
    
Passos gerais da simulação coalescente:
1) estimar U
2) simular SADs
  
   
__tabela 1__ As 11 primeiras linhas (de 200) do data frame usada para guiar a simulação coalescente usada para estimar a taxa de especiação média necessária para obter a riqueza observada (U). k = proporção de propágulos que permanece até a distância entre dois indivíduos vizinhos imediatos; S_obs =  número de espécies observado na parcela amostrada; kernel_code = código do tipo de kernel de dispersão usado na simulação coalescente, 2 indica distribuição de Laplace; d = distância em metros usado para parametrizar o desvio padrão da função de dispersão; txt.name = caminho do arquivo .txt que contém o mapa de cobertura vegetal com a resolução ajustada tal que a densidade de pixels seja igual a densidade de indivíduos na parcela; U = coluna que irá armazenar a estimativa da taxa de especiação necessária para obter a riqueza observada; .n = identificador da réplica, são 10 réplicas por bateria de simulação (anteriormente observamos pouca variação entre réplicas por isso usamos apenas 10 réplicas).  
  

```{r 11 primeiras linhas da tabela guia da estimativa de U echo=FALSE,eval=TRUE}
df_simulacao.U <- read_csv("./simulacao/df_simulacao.csv")
df_simulacao.U |> head(n=11)
```



__Janela de Código 1__ Função do R usada para intermediar o fluxo de trabalho em R com o programa 'dinamica_coalescente'. Para criar o programa coalescente basta fazer o 'make' no repositório [simulacao](https://github.com/Danhisco/artigo_mestrado/tree/master/1A.P_MOVER/simulacao) no git. Os parâmetros desta função são informados no data frame df_simulaca.U (tabela 1). Para que seja possível usar essa fução e roda a simulação é necessário que todos os arquivos estejam na mesma pasta
    

```{r janela de codigo 7,echo=TRUE,eval=TRUE}
dinamica_coalescente <- function(U, S=0, N_simul, seed, disp_range, disp_kernel, landscape){
  # Runs coalescent simulations for a given heterogeneous landscape
  #
  # Parameters:
  # U: speciation rate
  # S: observed richness (integer) - used to fit the value of U, or set to
  #       0 (default) if that is not desired
  # N_simul: number of simulations
  # seed: seed of the RNG (an integer)
  # disp_range: width of the dispersal kernel
  # disp_kernel: an integer corresponding to the type of dispersal kernel. One of
  #               0: uniform
  #               1: normal
  #               2: Laplacian
  # landscape: either a filename containing the landscape data, or a
  #   bidimensional R array or matrix.
  #   TODO: describe the format of the input - trinary matrix)
  #
  # Returns:
  # r: an array of dimension N_simul x landscape dimensions, that is, each
  #   r[i.,] is a bidimensional array of the same shape as the landscape.
  #   Each site is labeled according to the identity of the species occupying
  #   that site.
  # U_est: estimated speciation rate. This is returned only if input parameter S > 0
  if (is.character(landscape)){
    l <- as.matrix(read.table(landscape))
    infile <- landscape
    land_dims <- dim(l)
  } else {
    land_dims <- dim(landscape)
    infile <- tempfile()
    # input file *must* be clean: no comments, headers or anything
    write.table(landscape, infile, col.names=F, row.names=F)
  }
  outfile <- tempfile()
  repeat {
    system(paste('./dinamica_coalescente', land_dims[1], land_dims[2], U, S, N_simul,
                 seed, disp_range, disp_kernel, infile, outfile))
    if (file.exists(outfile) || S == 0)
      break
    U <- U/10.
    print(paste("Decreasing value of U to", U))
    # set some lowest boundary here so simulations don't take forever
    if (U < 1e-20){
      print("Richness value too low, giving up...")
      return(NULL)
    }
  }
  r <- as.matrix(read.table(outfile))
  # transpose each grid, as output is written along lines but R reads it along columns
  # TODO: I thought I got it right, but it was wrong... please DO re-check
  #r <- aperm(r, c(1,3,2))

  # recover estimated speciation rate
  if (S > 0){
    out_con <- file(outfile)
    U_line <- strsplit(readLines(out_con, 2)[2], ' ')[[1]]
    close(out_con)
    U_est <- as.double(U_line[length(U_line)])
    return(list(r = r, U_est = U_est))
  }
  return(r)
}
```




#### Estimativa de U

O código a seguir funciona, mas foi escrito faz um tempo já, não pude desenvolver uma versão mais atualizada. É bem importante que todos os arquivos estejam na mesma pasta (programa coalescente e arquivo txt com o mapa de cobertura vegetal) e também a sessão do R. Por isso costumo começar a janela de código a seguir com a função setwd. 
  
Note que U está definido como 1.25e-06. Conceitualmente essa simulação coalescente pressupõe que U = 0 para construir uma árvore da comunidade que seja próxima da situação da monodominância, na prática U é configurado para ser 'bem pequeno'. Essa simulação que estima U tem uma dirença importante com a próxima simulação: aqui informamos o número de espécies observado na parcela (S_obs); dessa forma indicamos que queremos obter como retorno o valor de U estimado (janela de código 1).  

Para cada cenário de limitação de dispersão salvo os resultados na subpasta ./simulacao/U/ em um arquivo .csv

Para aproveitar esse código certifique-se que a função dinamica_coalescente está disponível no global environment da sua sessão do R.  

Ao tentar rodar esse exemplo eu obtive o erro:

./dinamica_coalescente: error while loading shared libraries: libgsl.so.23: cannot open shared object file: No such file or directory

Quando rodei:

sudo apt install libgsl23

Obtive: 

O pacote libgsl23 não está disponível, mas é referenciado por outro pacote.
Isto pode significar que o pacote está faltando, ficou obsoleto ou
está disponível somente a partir de outra fonte
No entanto, os pacotes a seguir o substituem:
  libgslcblas0 libgslcblas0:i386

Esse erro se manteve mesmo instalando os pacotes sugeridos.  


```{r estimativa de U, echo=TRUE, eval=FALSE}
setwd("./simulacao/")
k_factor <- unique(df_simulacao.U$k)
registerDoMC(2)
for(a in 1:length(k_factor)){
  df_simU <- df_simulacao.U %>% dplyr::filter(k == k_factor[a])
  op <- options(digits.secs=6)
  funcao_imigracao <- function(i,df_temp=df_simU){
    aviao <- list()
    aviao <- dinamica_coalescente(U = 1.25e-06,
                                  S = df_temp[i,"S_obs"],
                                  N_simul = 1,
                                  seed = as.numeric(Sys.time()),
                                  disp_range = df_temp[i,"d"],
                                  disp_kernel = df_temp[i,"kernel_code"],
                                  landscape = df_temp[i,"txt.name"])
    return(aviao$U_est)
  }
  replica.sim <- as.list(1:dim(df_simU)[1])
  sim.coal_U <- llply(.data = replica.sim, .fun = funcao_imigracao, .parallel = TRUE)
  df_simU[,"U"] <- unlist(sim.coal_U)
  write.csv(df_simU,
            file=paste0("./U/","df_simU__k",k_factor[a],".csv"),row.names = FALSE)
}
```
  
  
#### Preparação para simulação das SADs
  
Feita a estimativa de U, então calculo a média e variância dos U por bateria de simulação e determino o número de SADs réplicas igual 100:
    
```{r media de U por bateria de simulacao, echo=TRUE,eval=FALSE}
df_U <- map_df(Sys.glob("./U/*.csv"), read_csv)
df_simulacao <-  inner_join(x=distinct(dplyr::select(df_U, SiteCode, k, Ntotal, S_obs, kernel_code, DA, d, p, txt.name)),
                            y=ddply(df_U,c("SiteCode","k"),summarise,U_med = mean(U), U_var = var(U)),
                            by=c("SiteCode","k"))
n_rep.SAD <- 100
```
    
#### Simulacao das SADs




```{r simulacao das SADs, echo=TRUE,eval=FALSE}
f_simulacao <- function(i,df_=df_simulacao){
  X <- df_[i,] %>% as.data.frame()
  mat_sim <- dinamica_coalescente(U = X[,"U_med"],
                                  S = 0,
                                  N_simul = n_rep.SAD,
                                  seed = as.numeric(Sys.time()),
                                  disp_range = X[,"d"],
                                  disp_kernel = X[,"kernel_code"],
                                  landscape = X[,"txt.name"])
  df_SAD.replica <- bind_rows(alply(mat_sim,1,function(Y) data.frame(N = sort(as.integer(table(Y))) ) ),
                              .id = "replica")
  df_SAD.replica %<>% 
    mutate(SiteCode = X$SiteCode, MN = "EE", k = X$k)
  path.file <- paste0("./SADs_preditas/",
                      X[,"SiteCode"],
                      "_k",X[,"k"],
                      "_EE.csv")
  write.csv(df_SAD.replica,
            file = path.file,
            row.names = FALSE)
}
registerDoMC(2)
simulacao <- as.list(1:dim(df_simulacao)[1])
l_ply(simulacao,f_simulacao,.parallel = TRUE)
```
