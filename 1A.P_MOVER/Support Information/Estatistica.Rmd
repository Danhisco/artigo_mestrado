---
title: "Estatistica"
author: "Mori, Danilo"
date: "31/10/2019"
output: 
  html_document:
    toc: true
    toc_depth: 5
---

<style>
body {
text-align: justify}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, tidy = FALSE, include = TRUE, warning = FALSE,cache = TRUE,message=FALSE,eval=TRUE)
knitr::opts_knit$set(root.dir = "~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/")
setwd("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/")
```

```{r pacotes,eval=TRUE}
library(gtools)
library(doMC)
library(mgcv)
library(gratia)
library(GUILDS)
library(broom)
library(bbmle)
library(gamm4)
library(lme4)
library(merTools)
library(magrittr)
library(gridExtra)
library(ggplot2)
library(stringr)
library(tidyr)
library(plyr)
library(purrr)
library(dplyr)
```

```{r dados}
### dados ###
# leitura
df_resultados <- read.table(file="./resultados/df_resultados.csv",header = TRUE,sep = ";",dec = ".",as.is=FALSE)
# padronização
level_k <- unique(as.character(df_resultados$k))
df_resultados$k <- factor(as.character(df_resultados$k),levels = level_k)
levels(df_resultados$k)[19] <- "0.1"
df_resultados %<>% mutate(L_plot = 100*sqrt(Ntotal/DA),
                          d_L.plot = d / L_plot)
# z score
f_z <- function(x){
  m <- base::mean(x,na.rm=TRUE)
  sd <- sd(x,na.rm=TRUE)
  output <- (x-m)/sd
  return(output)
} 
# names(df_resultados)
df_resultados.z <- as.data.frame(apply(df_resultados[c("p","Ntotal","Stotal","k.0","d_L.plot")],2,f_z))
names(df_resultados.z) <- sapply(names(df_resultados.z), function(x) paste(gsub(".0","",x),".z",sep=""))
df_resultados %<>% cbind(.,df_resultados.z)
# summary(df_resultados)
```

# U - taxa de especiação necessária para obter a riqueza observada no equilíbrio  

## Padrões Gerais  

```{r padroes gerais U,echo=FALSE,fig.width=12,fig.height=4}
# graficos
l_p <- vector("list",3)
l_p[[1]] <- ggplot(df_resultados,aes(x=k,y=U_med)) + 
  geom_point() +
  geom_line(aes(group=SiteCode)) + 
  geom_boxplot(aes(group=k))
l_p[[2]] <- ggplot(df_resultados,aes(x=Stotal,y=U_med)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(y="")
l_p[[3]] <- ggplot(df_resultados,aes(x=p,y=Stotal)) +
  geom_point() + 
  geom_smooth(method="lm")
do.call("grid.arrange",c(l_p,ncol=3))
```

__Figura 1__ Padrões gerais de U_med: ~ k (% de propágulos até a vizinhança imediata da planta progenitora); ~ Stotal (riqueza observada na área amostral). E o padrão empírico encontrado nos dados Stotal ~ p



```{r padroes gerais U por SiteCode,echo=FALSE,fig.height=50,fig.width=12}
# dados
df_plot <- df_resultados %>% select(SiteCode,p,U_med,k,d_L.plot) %>% 
  mutate(label_facet.wrap = paste0(SiteCode,";p=",round(p,4))) %>% 
  distinct() %>% arrange(p)
levels_label <- unique(df_plot$label_facet.wrap)
df_plot$label_facet.wrap <- factor(df_plot$label_facet.wrap,levels = levels_label)
# graficos
l_p <- vector("list",2)
l_p[[1]] <- ggplot(df_plot,aes(x=k,U_med)) +
  geom_point() +
  geom_line(aes(group=SiteCode)) +
  facet_wrap(~label_facet.wrap,ncol=6,scales="free") +
  ggtitle(label="eixo x = k")
l_p[[2]] <- ggplot(df_plot,aes(x=d_L.plot,U_med)) +
  geom_point() +
  geom_line(aes(group=SiteCode)) +
  facet_wrap(~label_facet.wrap,ncol=6,scales="free") +
  ggtitle(label="eixo x = d / L_plot")  
do.call("grid.arrange",c(l_p,ncol=1))
```

__Figura 2__ Padrões gerais de U_med por SiteCode: ~ k (% de propágulos até a vizinhança imediata da planta progenitora); ~ d / L_plot (distância média de dispersão / Lado do área amostral)


## Descrição Estatística

<!-- Segundo Pedersen et al. (2019) há 5 formas de utilizar HGAM (Hierarchical Generalized Additive Models); dessas 3 descrevem o padrão geral: G, GS e GI (figura 4, Petersen et al. 2019) -->

<!-- __Modelo G:__   -->
<!-- "A single commom (global) smoother for all observations"   -->
<!-- Nesse modelo há um smoother global e 1 intercepto para cada nível do efeito aleatório (random smoother); e.g.:   -->

<!-- CO2_modG <- gam(log(uptake) ~ s(log(conc), k=5, bs="tp") +   -->
<!--                               s(Plant_uo, k=12, bs="re),   -->
<!--                               data =.; method="REML", family="gaussian")   -->

<!-- Modelo GS:   -->
<!-- "Model GS is a close analogue to a GLMM with varying slopes: all groups have similar functional responses, but intergroup variation in responses is allowed. This approach works by allowing each grouping level to have its own functional response, but penalizing functions that are too far from the average."   -->

<!-- CO2_modGS <- gam(log(uptake) ∼ s(log(conc), k=5, m=2) +   -->
<!--                                s(log(conc), Plant_uo, k=5, bs="fs", m=2),   -->
<!--                                data=CO2, method="REML")   -->

<!-- Modelo GI:   -->
<!-- " We now allow each group-specific smoother to have its own smoothing parameter and hence its own level of wiggliness (there are more smoothing parameters to estimate) and means that the only information shared between groups is through the global smoother, the common error term, and through the random effect for group-level intercepts (if used)."   -->

<!-- CO2_modGI <- gam(log(uptake) ∼ s(log(conc), k=5, m=2, bs="tp") +    -->
<!--                                s(log(conc), by=Plant_uo, k=5, m=1, bs="tp") +    -->
<!--                                s(Plant_uo, bs="re", k=12),    -->
<!--                                data=CO2, method="REML")   -->


<!-- EXEMPLO DE gamm4::  -->

<!-- ~ 6 vezes mais rapido do que a alternativa, porem não tem a mesma flexibilidade que a função gam -->

<!-- system.time(l_p[[1]] <- gamm4(U_med ~ s(d_L.plot), random = ~(1|SiteCode) , -->
<!--                 family="gaussian", -->
<!--                 data = df_resultados))[[3]] -->
  
Para descrever o padrão de U em função da diminuição da limitação de dispersão e proporção de habitat disponível vamos utilizar GAMM (generalized additive mixed models, Wood 2017). Há pelo menos 3 formas de descrevermos o padrão global (Pedersen et al. 2019): a) um intercepto por SiteCode (1|SiteCode); b) um smoother por SiteCode (dispersão | SiteCode), porém com penalização para aqueles smoothers muito distintos do padrão global; e c) um smoother por SiteCode (dispersão | SiteCode) com seu próprio parâmetro de 'flexibilidade' (smoothing parameter).   
  
GAMM oferecem grande flexibilidade ao custo de aumento do número de parâmetros estimados e do custo computacional. Então irei começar por um modelo cuja estrutura aleatória é a mais simples possível (1 intercepto por SiteCode) para poder oferecer mais flexibilidade para o tensor(variável_dispersão,p)  

### Seleção de Modelo cheio  

- 2 famílias: gaussian e gamma  
- 3 funções de ligação: identity (apenas para gaussian), log, inverse  
- 2 variáveis concorrentes para descrever a dispersão: k e (d/L_plot)  
- log(Stotal) como preditora linear  
- (1|SiteCode) como estrutura aleatória  

__exemplo de código:__  
gam(U_med ~ s(d_L.plot.z) + s(p.z) + ti(d_L.plot.z,p.z) +  
                      log(Stotal) +  
                      s(SiteCode,bs="re"),  
                    family="gaussian",  
                    data = df_resultados, method = "REML",control=ctrl)  

__Tabela de Seleção do Modelo Mais plausível:__    

```{r selecao de modelo cheio GAMM(U)}
ctrl <- list(nthreads=3) #número de cores para paralelizar
l_md <- vector("list",length = 10)
names(l_md) <- c("d id normal","d log normal", "d inverse normal", "d log gamma", "d inverse gamma",
                 "k id normal","k log normal", "k inverse normal", "k log gamma", "k inverse gamma")
l_md[[1]] <- gam(U_med ~ s(d_L.plot.z) + s(p.z) + ti(d_L.plot.z,p.z) +
                  log(Stotal) +
                  s(SiteCode,bs="re"),
                family="gaussian",
                data = df_resultados, method = "REML",control=ctrl)
l_md[[2]] <- gam(U_med ~ s(d_L.plot.z) + s(p.z) + ti(d_L.plot.z,p.z) +
                  log(Stotal) +
                  s(SiteCode,bs="re"),
                family=gaussian(link = "log"),
                data = df_resultados, method = "REML",control=ctrl)
l_md[[3]] <- gam(U_med ~ s(d_L.plot.z) + s(p.z) + ti(d_L.plot.z,p.z) +
                  log(Stotal) +
                  s(SiteCode,bs="re"),
                family=gaussian(link = "inverse"),
                data = df_resultados, method = "REML",control=ctrl)
l_md[[4]] <- gam(U_med ~ s(d_L.plot.z) + s(p.z) + ti(d_L.plot.z,p.z) +
                  log(Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados, method = "REML",control=ctrl)
l_md[[5]] <- gam(U_med ~ s(d_L.plot.z) + s(p.z) + ti(d_L.plot.z,p.z) +
                  log(Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "inverse"),
                data = df_resultados, method = "REML",control=ctrl)

l_md[[6]] <- gam(U_med ~ s(k.z) + s(p.z) + ti(k.0,p.z) +
                  log(Stotal) +
                  s(SiteCode,bs="re"),
                family="gaussian",
                data = df_resultados, method = "REML",control=ctrl)
l_md[[7]] <- gam(U_med ~ s(k.z) + s(p.z) + ti(k.0,p.z) +
                  log(Stotal) +
                  s(SiteCode,bs="re"),
                family=gaussian(link = "log"),
                data = df_resultados, method = "REML",control=ctrl)
l_md[[8]] <- gam(U_med ~ s(k.z) + s(p.z) + ti(k.0,p.z) +
                  log(Stotal) +
                  s(SiteCode,bs="re"),
                family=gaussian(link = "inverse"),
                data = df_resultados, method = "REML",control=ctrl)
l_md[[9]] <- gam(U_med ~ s(k.z) + s(p.z) + ti(k.0,p.z) +
                  log(Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados, method = "REML",control=ctrl)
l_md[[10]] <- gam(U_med ~ s(k.z) + s(p.z) + ti(k.0,p.z) +
                  log(Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "inverse"),
                data = df_resultados, method = "REML",control=ctrl)
AICctab(l_md,weights = TRUE)
```

O modelos cheio mais plausível possui família Gamma e função de ligação 'log"

### Auditoria do modelo cheio mais plausível

<!-- Protocolo de Wood (in Checking and Selecting GAMs): -->

<!-- 1) Residual Checking:   -->
<!-- a) fitted ~ residuals (1|SiteCode) -->
<!-- a) fitted ~ residuals (1|SiteCode) -->
<!-- b) residuals ~ preditoras   -->

```{r auditoria md mais plausivel U 1}
# Dados
md_U <- gam(U_med ~ s(d_L.plot.z) + s(p.z) + ti(d_L.plot.z,p.z) +
                  log(Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados, method = "REML",control=as.list(3)) # "d log gamma"

summary(md_U)
gam.check(md_U)
# md_U <- l_md[["d log gamma"]]
# df_md.U <- augment(md_U)
# Gráficos
# l_p <- vector("list",2)
# l_p[[1]] <- 
# ggplot(df_md.U,aes(y=U_med,x=.fitted)) +
#   geom_point() +
#   geom_smooth() +
#   # geom_abline(intercept = 0,slope = 1,color="red") +
#   # theme(axis.text = element_blank(),
#         # axis.ticks = element_blank()) +
#   facet_wrap(~SiteCode,ncol=4,scales="free")
gam.check(md_U)
```

__Figura 3__ gam.check(modelo cheio mais plausível)  


```{r auditoria md mais plausivel U 2,warning=FALSE,message=FALSE}
p_plot <- DHARMa::simulateResiduals(md_U,n=1000)
plot(p_plot)
```

__Figura 4__ DHARMa::simulateResiduals(modelo cheio mais plausível)


O Modelo mais plausível diverge do pressuposto de que a variável resposta pode ser aproximada por uma distribuição Gamma(link=log) para ambos diagnósticos.  
Possibilidades de configuração: a) número de funções bases e/ou local dos knots; b) os tipos de smoothers para utilizar (cubic ou thin plate regression spline); c) determinar em qual derivada a penalização sera feita;...?  


```{r md_U comparacao entre smoothers}
l_md <- vector("list",5)
names(l_md) <- paste0("model",1:5)
l_md[[1]] <- gam(U_med ~ s(d_L.plot.z,bs="tp") + s(p.z,bs="tp") + ti(d_L.plot.z,p.z,bs="tp") +
                  log(Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados, method = "REML",control=as.list(3))
l_md[[2]] <- gam(U_med ~ s(d_L.plot.z,bs="cr") + s(p.z,bs="cr") + ti(d_L.plot.z,p.z,bs="cr") +
                  log(Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados, method = "REML",control=as.list(3))
l_md[[3]] <- gam(U_med ~ s(d_L.plot.z,bs="cr") + s(p.z,bs="tp") + ti(d_L.plot.z,p.z,bs="cr") +
                  log(Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados, method = "REML",control=as.list(3))
l_md[[4]] <- gam(U_med ~ s(d_L.plot.z,bs="tp") + s(p.z,bs="cr") + ti(d_L.plot.z,p.z,bs="tp") +
                  log(Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados, method = "REML",control=as.list(3))
l_md[[5]] <- gam(U_med ~ te(d_L.plot.z,p.z,bs=c("cr","tp")) +
                  log(Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados, method = "REML",control=as.list(3))
l_md[[6]] <- gamm4(U_med ~ t2(d_L.plot.z,p.z,bs=c("cr","tp")) +
                    log(Stotal),
                    random=~(1|SiteCode),
                  family=Gamma(link = "log"),
                  data = df_resultados) #, method = "REML",control=as.list(3)
l_md[[7]] <- gamm4(U_med ~ t2(d_L.plot.z,p.z,bs=c("cr","tp")) +
                    log(Stotal),
                    random=~(d_L.plot.z|SiteCode),
                  family=Gamma(link = "log"),
                  data = df_resultados) #, method = "REML",control=as.list(3)
AICctab(l_md,weights = TRUE)
# gam.check(l_md[[3]])
# p_plot <- DHARMa::simulateResiduals(l_md[[6]]$mer,n = 1000)
# plot(p_plot)
# plot(l_md[[6]]$gam)
```

Utilizar bs="cr" para a variável d e para o tensor entre p e d parece ser o método mais plausível; enquanto para a variável p é robusta. O gam.check parece indicar que existe poucas funções de base para o smoother de d:  

```{r atualizacao de l_md.U.3}
teste_md.U <- gam(U_med ~ s(d_L.plot.z,bs="cr",k = 40) + s(p.z,bs="tp") + ti(d_L.plot.z,p.z,bs="cr") +
                  log(Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados, method = "REML",control=as.list(3))
gam.check(teste_md.U)
library(gamm4)
teste_md.U <- gamm4(U_med ~ t2(d_L.plot.z,p.z,bs=c("cr","tp")) + 
                      # t2(d_L.plot.z,SiteCode,bs=c("cr","ts")) +
                      log(Stotal),
                family=Gamma(link = "log"),
                data = df_resultados, method = "REML")

```

O valor padrão de k=9, utilizei duas alternativas: k=20 e k=40. Para ambas o número de k parece ser insuficiente (k-edf->0 e p-valor<2e-16), isso pode indicar que seja necessário considerar um smoother por sitecode.


```{r diag 1 modelo cheio GAMM(U),eval=FALSE,echo=FALSE,include=FALSE}

gam.check(md_U)
md_U.upgrade <- gam(U_med ~ s(d_L.plot.z,k=103) + s(p.z) + ti(d_L.plot.z,p.z,k=20) +
                  log(Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados, method = "REML",control=ctrl)
ck(md_U.upgrade)
```








<!-- __1) Parâmetros Lineares (parametric coefficients)__    -->
<!-- intercepto geral e a inclinação de log(Stotal)     -->

<!-- __2) Approximate significance of smooth terms__ -->
<!-- a) edf (effective degrees of freedom): número de parâmetros a serem estimados por smoothers menos uma constante; descreve o grau de complexidade do smoother. -->
<!-- b) Ref.df e F: columns from a ANOVA for the overall significance of the smoother (a linear parametric test) -->




<!-- código antigo  -->

<!-- ## Número de SADs refutadas -->

<!-- ### Visualização -->

<!-- ```{r n_ref preditoras categoricas} -->
<!-- # graficos -->
<!-- l_p <- vector("list",4) -->
<!-- l_p[[1]] <- ggplot(df_resultados,aes(x=MN,y=n_SAD.ref)) + -->
<!--   geom_jitter() + -->
<!--   geom_boxplot() -->
<!-- l_p[[2]] <- ggplot(df_resultados,aes(x=k,y=n_SAD.ref,group=k)) + -->
<!--   geom_jitter() + -->
<!--   geom_boxplot() -->
<!-- l_p[[3]] <- ggplot(filter(df_resultados, -->
<!--                           k %in% levels(df_resultados$k)[1:10]), -->
<!--                    aes(x=p,y=n_SAD.ref)) + -->
<!--   geom_point() +  -->
<!--   geom_smooth() +  -->
<!--   facet_grid(k~MN) -->
<!-- l_p[[4]] <- ggplot(filter(df_resultados, -->
<!--                           k %in% levels(df_resultados$k)[11:20]), -->
<!--                    aes(x=p,y=n_SAD.ref)) + -->
<!--   geom_point() +  -->
<!--   geom_smooth() +  -->
<!--   facet_grid(k~MN) -->
<!-- grid.arrange(l_p[[1]],l_p[[2]],l_p[[3]],l_p[[4]], -->
<!--              layout_matrix = rbind(c(1,2,2,2), -->
<!--                                    c(3,3,4,4), -->
<!--                                    c(3,3,4,4), -->
<!--                                    c(3,3,4,4)) -->
<!--              ) -->

<!-- ``` -->

<!-- __Figura 1__ Número de SADs refutadas (n_SAD.ref) ~ MN, k, p -->

<!-- Vamos aproximar a variável por um processo binomial. Utilizamos o seguinte protocolo de ajuste dos dados   -->
<!-- 1) comparar diferentes agrupamentos dos dados por sítios de amostragem, para um mesmo modelo cheio;   -->
<!-- 2) os modelo cheio vão conter as variáveis p e MN e duas versões de k (continua e categorica); -->
<!-- 3) e as 3 funções de ligação canônicas   -->
<!-- 4) o modelo cheio mais plausível sera utilizado na seleção de variáveis -->
<!-- 5) a seleção de variáveis contará com todas as combinações das preditoras do modelo cheio -->
<!-- 6) avaliamos os resíduos quantílicos do modelo mais plausível -->


<!-- ```{r n_ref comparacao modelos cheios} -->
<!-- l_md <- vector("list",15) -->
<!-- names(l_md) <- c("l k0 1|Site","l k0 MN|Site","l k0 k0*MN|Site", -->
<!--                  "l kf 1|Site","l kf MN|Site", -->
<!--                  "p k0 1|Site","p k0 MN|Site","p k0 k0*MN|Site", -->
<!--                  "p kf 1|Site","p kf MN|Site", -->
<!--                  "c k0 1|Site","c k0 MN|Site","c k0 k0*MN|Site", -->
<!--                  "c kf 1|Site","c kf MN|Site") -->
<!-- ## logito ## -->
<!-- l_md[[1]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (1|Site),  -->
<!--                    family = "binomial",data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[2]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (MN|Site),  -->
<!--                    family = "binomial",data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[3]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (MN*k.z|Site), -->
<!--                    family = "binomial",data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[4]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k * MN + (1|Site), -->
<!--                    family = "binomial",data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[5]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k * MN + (MN|Site), -->
<!--                    family = "binomial",data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- ## probit ## -->
<!-- l_md[[6]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (1|Site),  -->
<!--                    family = "binomial"(link = probit),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[7]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (MN|Site),  -->
<!--                    family = "binomial"(link = probit),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[8]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (MN*k.z|Site), -->
<!--                    family = "binomial"(link = probit),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[9]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k * MN + (1|Site), -->
<!--                    family = "binomial"(link = probit),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[10]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k * MN + (MN|Site), -->
<!--                    family = "binomial"(link = probit),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- ## cloglog -->
<!-- l_md[[11]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (1|Site),  -->
<!--                    family = "binomial"(link = cloglog),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[12]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (MN|Site),  -->
<!--                    family = "binomial"(link = cloglog),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[13]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (MN*k.z|Site), -->
<!--                    family = "binomial"(link = cloglog),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e7))) -->
<!-- par_md <- getME(l_md[[13]],c("theta","fixef")) -->
<!-- l_md[[13]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (MN*k.z|Site), -->
<!--                    family = "binomial"(link = cloglog),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e7)), -->
<!--                    start = par_md) -->
<!-- l_md[[14]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k * MN + (1|Site), -->
<!--                    family = "binomial"(link = cloglog),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[15]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k * MN + (MN|Site), -->
<!--                    family = "binomial"(link = cloglog),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- AICctab(l_md,weights=T) -->
<!-- ``` -->

<!-- Pergunta: existe algum problema em comparar modelos que utilizaram diferentes otimizadores? -->
<!-- Resposta: os otimizadores diferem no algoritmo que vare o campo de parâmetros; uma vez escolhidos os parâmetros os modelos são comparados da mesma forma -->

<!-- Falhas de convergência: -->

<!-- ```{r n_ref modelo cheio com convergencia} -->
<!-- # rotina de avaliação -->
<!-- #  -->
<!-- par_md <- getME(l_md[[13]],c("theta","fixef")) -->
<!-- l_md[[13]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (MN*k.z|Site), -->
<!--                    family = "binomial"(link = cloglog),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e7)), -->
<!--                    start = par_md) -->
<!-- AICctab(l_md,weights=T) -->
<!-- ``` -->

<!-- Resolvido -->

<!-- ### Para n_SAD.Nref -->

<!-- ```{r gof comparacao modelos cheios} -->
<!-- l_md <- vector("list",15) -->
<!-- names(l_md) <- c("l k0 1|Site","l k0 MN|Site","l k0 k0*MN|Site", -->
<!--                  "l kf 1|Site","l kf MN|Site", -->
<!--                  "p k0 1|Site","p k0 MN|Site","p k0 k0*MN|Site", -->
<!--                  "p kf 1|Site","p kf MN|Site", -->
<!--                  "c k0 1|Site","c k0 MN|Site","c k0 k0*MN|Site", -->
<!--                  "c kf 1|Site","c kf MN|Site") -->
<!-- ## logito ## -->
<!-- l_md[[1]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (1|Site),  -->
<!--                    family = "binomial",data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[2]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (MN|Site),  -->
<!--                    family = "binomial",data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[3]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (MN*k.z|Site), -->
<!--                    family = "binomial",data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[4]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k * MN + (1|Site), -->
<!--                    family = "binomial",data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[5]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k * MN + (MN|Site), -->
<!--                    family = "binomial",data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- ## probit ## -->
<!-- l_md[[6]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (1|Site),  -->
<!--                    family = "binomial"(link = probit),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[7]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (MN|Site),  -->
<!--                    family = "binomial"(link = probit),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[8]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (MN*k.z|Site), -->
<!--                    family = "binomial"(link = probit),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- par_md <- getME(l_md[[8]],c("theta","fixef")) -->
<!-- l_md[[8]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (MN*k.z|Site), -->
<!--                    family = "binomial"(link = probit),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)), -->
<!--                    start = par_md) -->
<!-- l_md[[9]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k * MN + (1|Site), -->
<!--                    family = "binomial"(link = probit),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[10]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k * MN + (MN|Site), -->
<!--                    family = "binomial"(link = probit),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- ## cloglog -->
<!-- l_md[[11]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (1|Site),  -->
<!--                    family = "binomial"(link = cloglog),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[12]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (MN|Site),  -->
<!--                    family = "binomial"(link = cloglog),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[13]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (MN*k.z|Site), -->
<!--                    family = "binomial"(link = cloglog),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e7))) -->
<!-- par_md <- getME(l_md[[13]],c("theta","fixef")) -->
<!-- l_md[[13]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (MN*k.z|Site), -->
<!--                    family = "binomial"(link = cloglog),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e7)), -->
<!--                    start = par_md) -->
<!-- l_md[[14]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k * MN + (1|Site), -->
<!--                    family = "binomial"(link = cloglog),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[15]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k * MN + (MN|Site), -->
<!--                    family = "binomial"(link = cloglog),data=df_resultados, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- AICctab(l_md,weights=T) -->
<!-- ``` -->


<!-- O modelo cheio VR ~ p.z * k.z * MN + (MN * k.z|Site) é o modelo cheio mais plausível. -->

<!-- Se VR = n_ref, então a função de ligação cloglog é a mais plausível -->
<!-- Se VR = GOF, então a logito -->



<!-- __Seleção de Variáveis__ -->

<!-- ```{r GOF selecao de modelos} -->
<!-- # f_md <- function( -->
<!-- df_=df_resultados -->
<!-- l_md <- vector("list",19) -->
<!-- names(l_md) <- c("p*k*MN",# modelo cheio -->
<!--                  "p*k*MN-p:k:MN", #MC - 3a ordem -->
<!--                  "p*(k+MN)","k*(p+MN)","MN*(p+k)", #2 interações -->
<!--                  "p*k+MN","p*MN+k","k*MN+p", #1 interação + preditor -->
<!--                  "p*k","p*MN","k*MN", #1 interação -->
<!--                  "p+k+MN",#aditivo 3 -->
<!--                  "p+k","p+MN","k+MN", #aditivo 2  -->
<!--                  "p","k","MN", #preditor isolado -->
<!--                  "1") #nulo -->
<!-- #modelo cheio -->
<!-- l_md[[1]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k * MN + (MN|Site),  -->
<!--                    family = "binomial", data=df_, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- #modelo cheio - interação 3a ordem -->
<!-- l_md[[2]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k * MN - p.z:k:MN + (MN|Site),  -->
<!--                    family = "binomial", data=df_, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- #2 interações -->
<!-- l_md[[3]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * (k + MN) + (MN|Site),  -->
<!--                    family = "binomial", data=df_, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[4]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ k * (p.z + MN) + (MN|Site),  -->
<!--                    family = "binomial", data=df_, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[5]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ MN * (p.z + k) + (MN|Site),  -->
<!--                    family = "binomial",data=df_, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- #1 interação + preditor -->
<!-- l_md[[6]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k + MN + (MN|Site),  -->
<!--                    family = "binomial", data=df_, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[7]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * MN + k + (MN|Site),  -->
<!--                    family = "binomial", data=df_, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[8]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ k * MN + p.z + (MN|Site),  -->
<!--                    family = "binomial", data=df_, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- #1 interação -->
<!-- l_md[[9]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k + (1|Site), -->
<!--                    family = "binomial", data=df_, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[10]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * MN + (MN|Site), -->
<!--                     family = "binomial", data=df_, -->
<!--                     control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[11]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ k * MN + (MN|Site), -->
<!--                     family = "binomial", data=df_, -->
<!--                     control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- #aditivo 3 -->
<!-- l_md[[12]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z + k + MN + (MN|Site), -->
<!--                     family = "binomial", data=df_, -->
<!--                     control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- #aditivo 2 -->
<!-- l_md[[13]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z + k + (1|Site), -->
<!--                     family = "binomial", data=df_, -->
<!--                     control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[14]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z + MN + (MN|Site), -->
<!--                     family = "binomial", data=df_, -->
<!--                     control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[15]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ k + MN + (MN|Site), -->
<!--                     family = "binomial", data=df_, -->
<!--                     control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- #aditivo 1 -->
<!-- l_md[[16]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z + (1|Site), -->
<!--                     family = "binomial", data=df_, -->
<!--                     control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[17]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ k + (1|Site), -->
<!--                     family = "binomial", data=df_, -->
<!--                     control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[18]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ MN + (MN|Site), -->
<!--                     family = "binomial", data=df_, -->
<!--                     control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- # nulo -->
<!-- l_md[[19]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ 1 + (1|Site), -->
<!--                     family = "binomial", data=df_, -->
<!--                     control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- # } -->
<!-- # registerDoMC(3) -->
<!-- # l_md.GOF <- dlply() -->

<!-- AICctab(l_md,weights=T) -->
<!-- ``` -->

