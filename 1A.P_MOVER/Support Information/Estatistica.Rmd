---
Ftitle: "Apêndice 2: Descrição Estatística"
author: "Mori, Danilo"
date: "31/10/2019"
output: 
  html_document:
    toc: true
    toc_depth: 5
editor_options: 
  chunk_output_type: console
---

<style>
body {
text-align: justify}
</style>

<!--  -->

```{r setup, include=TRUE,echo=FALSE}
knitr::opts_chunk$set(echo = FALSE, tidy = FALSE, include = TRUE, warning = FALSE,cache = TRUE,message=FALSE,eval=TRUE)
# setwd("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/")
knitr::opts_knit$set(root.dir = "~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/")
```

```{r pacotes,eval=TRUE,echo=TRUE}
library(parallel)
library(doMC)
library(DHARMa)
library(broom.mixed)
library(gratia)
library(MuMIn)
library(mgcv)
library(bbmle)
library(lme4)
library(merTools)
library(magrittr)
library(gridExtra)
library(ggplot2); theme_set(theme_classic())
library(tidyr)
library(purrr)
library(plyr)
library(dplyr)
```

```{r dados,message=FALSE}
### dados ###
# leitura
df_resultados <- read.csv(file="/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/resultados/df_resultados.csv",
                            header = TRUE,as.is=FALSE)[,1:13]
# padronização
level_k <- as.character(unique(sort(as.numeric(df_resultados$k),decreasing = TRUE)))
df_resultados$k <- factor(df_resultados$k,levels = level_k)
levels(df_resultados$k)[19] <- "0.1"
# z score
f_z <- function(x){
  m <- base::mean(x,na.rm=FALSE)
  sd <- sd(x,na.rm=FALSE)
  output <- (x-m)/sd
  return(output)
} 
# names(df_resultados)
# str(df_resultados)
df_resultados %<>% mutate(diffS_gamma = diffS_mean + min(diffS_mean)*(-1) + 0.01,
                          modulo_diffS = abs(diffS_mean),
                          log_Sobs=log(S_obs))

df_resultados.z <- as.data.frame(apply(df_resultados[,c("p","Ntotal","log_Sobs","k_1","d_Lplot","d","modulo_diffS")],2,f_z))
names(df_resultados.z) <- sapply(names(df_resultados.z), function(x) paste0(x,".z"))
df_resultados %<>% cbind(.,df_resultados.z) %>% 
  select(-k_1,-k_1.z)
```


# 1 - Variables

__table 1:__
Variáveis utilizadas na descrição estatística

```{r 1 tabela de variaveis,echo=FALSE, eval=TRUE}
df_variaveis <- read.csv("/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/tabela_variaveis.csv",
                         header = TRUE,as.is = FALSE) %>% 
  filter(code != "1-k")
knitr::kable(df_variaveis,caption = "Variables") %>%
  kableExtra::kable_styling()
```

  
    
__Figure 1__ Possible Predictor Variables  
  
    
```{r figura 11 possiveis variaveis preditoras,echo=FALSE,include=TRUE,fig.height=7,fig.align='center',fig.width=7}
l_p <- list()
l_p[[1]] <- ggplot(df_resultados,aes(x=k,y=d)) +
  geom_jitter(alpha=0.3) +
  geom_boxplot(alpha=0.6) +
  coord_flip()
l_p[[2]] <- ggplot(df_resultados,aes(x=k,y=d_Lplot)) +
  geom_jitter(alpha=0.3) +
  geom_boxplot(alpha=0.6) +
  coord_flip()
l_p[[3]] <- ggplot(filter(df_resultados,MN=="EE"&k=="0.99"), aes(x=p,y=S_obs)) +
  geom_point(alpha=0.3)
l_p[[4]] <- ggplot(filter(df_resultados,MN=="EE"&k=="0.99"),aes(x="",y=p)) + geom_jitter(alpha=0.3) + geom_boxplot(alpha=0.6) + labs(x="")
l_p[[5]] <- ggplot(filter(df_resultados,MN=="EE"&k=="0.99"),aes(x="",y=S_obs)) + geom_jitter(alpha=0.3) + geom_boxplot(alpha=0.6) + labs(x="")
layout_mat <- rbind(c(1,1,1,2,2,2),
                    c(3,3,3,4,5,NA))
# do.call("grid.arrange",c(l_p[1:3],layout_matrix=1,top="Possible Predictor Variables"))
grid.arrange(l_p[[1]],l_p[[2]],l_p[[3]],l_p[[4]],l_p[[5]],top="Possible Predictor Variables",layout_matrix=layout_mat)
```


  
# 2 - Number of unrefuted SADs
  
    
__Figura 2.1__ número de SADs não refutadas ~ p *  k * MN. A linha azul é uma estimativa baseada em 'loess'.   
    
```{r n_nRef padroes gerais fig21}
l_p <- vector("list",2)
l_p[[1]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[1:10]),
                   aes(x=p,y=n_nRef)) + 
  geom_point() + 
  geom_smooth(method="loess") +
  facet_grid(k~MN)
l_p[[2]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[11:20]),
                   aes(x=p,y=n_nRef)) + 
  geom_point() + 
  geom_smooth(method="loess") +
  facet_grid(k~MN) 
do.call("grid.arrange",c(l_p,ncol=2))
```
    
  
  
  
__Figura 2.2__ número de SADs não refutadas ~ (d * MN|Site ~ p). Site está ordenado pelo valor de p.  
  
  
```{r n_nRef padroes gerais fig22 ,fig.width=8, fig.height=27}
df_plot <- df_resultados %>% mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
ggplot(df_plot,aes(x=d.z,y=n_nRef,group=MN)) +
  geom_point(aes(color=MN),alpha=0.3) +
  # geom_line(aes(y=Pr_nRef,color=MN),alpha=0.3) +
  scale_color_manual(values=c("#FF0000", "#000000")) +
  theme_classic() + theme(legend.position="top") + labs(x="d(metros)",y="nRef(count)") +
  facet_wrap(~title,ncol=6)
```


  
    
## 2.1 GLMM binomial

### Modelo cheio 1: 


__linear term__  
  
i) ~ (p + p^2) * (d + d^2) * MN; if : var_dispersao = contiguous  
ii) ~ ( p + p^2) * k * MN;   if : var_dispersao = category    
  
__random term__
  
a) 1|SiteCode  
b) MN|SiteCode  
c)  (var_dispersao + var_dispersao^2)*MN|SiteCode, if : var = dispersao : contiguous



```{r glmm n_nRef comparacao modelos cheios, echo=TRUE,eval=FALSE,cache=TRUE,message=FALSE,warning=FALSE}
# dados
df_md <- df_resultados %>% 
  select(n_nRef,p,SiteCode,MN,p.z,k,d.z,d_Lplot.z)
df_md[,6:8] <- apply(df_md[,6:8],2,as.character)
df_md %<>% 
  gather(key = var_dispersao, value = value_dispersao, k:d_Lplot.z) 
# funcao ajuste dos modelos
f_md <- function(dados){
  var_dispersao <- unique(dados$var_dispersao)
  if(var_dispersao == "k"){
    l_md <- vector("list",2)
    names(l_md) <- c(paste0(var_dispersao," 1|Site"),
                     paste0(var_dispersao," MN|Site"))
    dados$value_dispersao <- factor(dados$value_dispersao,levels = unique(dados$value_dispersao)[20:1])
    l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN +
                         (1|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN +
                         (MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
  }else{
    dados$value_dispersao <- as.numeric(dados$value_dispersao)
    l_md <- vector("list",3)
    names(l_md) <- c(paste0(var_dispersao," 1|Site"),
                     paste0(var_dispersao," MN|Site"),
                     paste0(var_dispersao," (",var_dispersao,"+",var_dispersao,"^2)*MN|Site"))
    l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * (value_dispersao + I(value_dispersao^2)) * MN + 
                         (1|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * (value_dispersao + I(value_dispersao^2)) * MN + 
                         (MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * (value_dispersao + I(value_dispersao^2)) * MN + 
                         ( (value_dispersao + I(value_dispersao^2) ) * MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    
  }
  return(l_md)
}
registerDoMC(3)
l_nRef__modeloCheio <- dlply(df_md,.(var_dispersao),f_md,.parallel = TRUE)
names(l_nRef__modeloCheio) <- NULL
l_nRef__modeloCheio <- do.call(c,l_nRef__modeloCheio)
#
f_warning <- function(glmm_object){
  # glmm_object <- l_nRef__modeloCheio[[4]]
  v_message <- glmm_object@optinfo$conv$lme4$messages %>% 
    as.character()
  if(length(v_message)==0){v_message <- "OK"}
  if(length(v_message)>1){v_message <- v_message[1] }
  return(v_message)
}
df_auditoria.md <- ldply(l_nRef__modeloCheio,f_warning,.id="glmer") %>% 
  rename(warning_message = V1)
```


```{r l_md_nRef.GLMM, eval=FALSE,echo=FALSE}
save(l_nRef__modeloCheio,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_GLMM.Rdata")
```
  
__Table 2.1__ Modelos Cheios estimados e avisos de convergência  
  
```{r data frame com os avisos de ajustes,eval=TRUE,echo=FALSE}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_GLMM.Rdata")
# avaliação e melhora do ajuste dos modelos
## warnings
f_warning <- function(glmm_object){
  # glmm_object <- l_nRef__modeloCheio[[4]]
  v_message <- glmm_object@optinfo$conv$lme4$messages %>% 
    as.character()
  if(length(v_message)==0){v_message <- "OK"}
  if(length(v_message)>1){v_message <- v_message[1] }
  return(v_message)
}
df_auditoria.md <- ldply(l_nRef__modeloCheio,f_warning,.id="glmer") %>% 
  rename(warning_message = V1)
v_glmerUpdate <- df_auditoria.md[df_auditoria.md$warning_message != "OK",]$glmer %>% 
  as.character()
knitr::kable(df_auditoria.md) %>% 
  kableExtra::kable_styling()
```
  
    
#### allFit  
  
  
```{r rotina de avaliacao individual dos modelos cheios 1,echo=TRUE,eval=FALSE}
i <- 1
names(l_nRef__modeloCheio[v_glmerUpdate])[i]
#
## update1:
md_allFit <- allFit(l_nRef__modeloCheio[v_glmerUpdate][[i]],maxfun = 1e5, parallel = 'multicore', ncpus = 3)
```
  
  
  
__1) d_Lplot 1|Site__  

7 optimizer(s) failed

__2) d_Lplot MN|Site__  
  
7 optimizer(s) failed
      
__3) d 1|Site__  

7 optimizer(s) failed
         
__4) d MN|Site__      
  
7 optimizer(s) failed    

  
### Modelo cheio 2: 


```{r glmm n_nRef comparacao modelos cheios2, echo=TRUE,eval=FALSE,cache=TRUE,message=FALSE,warning=FALSE}
# dados
df_md <- df_resultados %>% 
  select(n_nRef,p,SiteCode,MN,p.z,k,d.z,d_Lplot.z)
df_md[,6:8] <- apply(df_md[,6:8],2,as.character)
df_md %<>% 
  gather(key = var_dispersao, value = value_dispersao, k:d_Lplot.z) 
# funcao ajuste dos modelos
f_md <- function(dados){
  var_dispersao <- unique(dados$var_dispersao)
  if(var_dispersao == "k"){
    l_md <- vector("list",2)
    names(l_md) <- c(paste0(var_dispersao," 1|Site"),
                     paste0(var_dispersao," MN|Site"))
    dados$value_dispersao <- factor(dados$value_dispersao,levels = unique(dados$value_dispersao)[20:1])
    l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN +
                         (1|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN +
                         (MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
  }else{
    dados$value_dispersao <- as.numeric(dados$value_dispersao)
    l_md <- vector("list",4)
    names(l_md) <- c(paste0(var_dispersao," 1|Site"),
                     paste0(var_dispersao," MN|Site"),
                     paste0(var_dispersao," ",var_dispersao,"*MN|Site"),
                     paste0(var_dispersao,"^2 (",var_dispersao,"+",var_dispersao,"^2)*MN|Site"))
    l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN + 
                         (1|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN + 
                         (MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN + 
                         (value_dispersao * MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[4]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * (value_dispersao + I(value_dispersao^2)) * MN + 
                         ( (value_dispersao + I(value_dispersao^2) ) * MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    
  }
  return(l_md)
}
registerDoMC(3)
l_nRef__modeloCheio2 <- dlply(df_md,.(var_dispersao),f_md,.parallel = TRUE)
names(l_nRef__modeloCheio2) <- NULL
l_nRef__modeloCheio2 <- do.call(c,l_nRef__modeloCheio2)
#
f_warning <- function(glmm_object){
  v_message <- glmm_object@optinfo$conv$lme4$messages %>% 
    as.character()
  if(length(v_message)==0){v_message <- "OK"}
  if(length(v_message)>1){v_message <- v_message[1] }
  return(v_message)
}
df_auditoria.md <- ldply(l_nRef__modeloCheio2,f_warning,.id="glmer") %>% 
  rename(warning_message = V1)
```


```{r l_nRef__modeloCheio2,eval=FALSE,echo=FALSE}
save(l_nRef__modeloCheio2,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_GLMM2.Rdata")
```
  
    
__Table 2.2__ Modelos Cheios estimados e avisos de convergência    
    
      
```{r warningns l_nRef__modeloCheio2,eval=TRUE,echo=FALSE}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_GLMM2.Rdata")
# avaliação e melhora do ajuste dos modelos
## warnings
f_warning <- function(glmm_object){
  v_message <- glmm_object@optinfo$conv$lme4$messages %>% 
    as.character()
  if(length(v_message)==0){v_message <- "OK"}
  if(length(v_message)>1){v_message <- v_message[1] }
  return(v_message)
}
df_auditoria.md <- ldply(l_nRef__modeloCheio2,f_warning,.id="glmer") %>% 
  rename(warning_message = V1)
v_glmerUpdate <- df_auditoria.md[df_auditoria.md$warning_message != "OK",]$glmer %>% 
  as.character()
knitr::kable(df_auditoria.md) %>% 
  kableExtra::kable_styling()
```
  
#### allFit  
  
```{r melhoria de modelo cheio 2,eval=FALSE}
i <- 2
names(l_nRef__modeloCheio2[v_glmerUpdate])[i]
md_allFit <- allFit(l_nRef__modeloCheio2[v_glmerUpdate][[i]],maxfun = 1e5, parallel = 'multicore', ncpus = 3)
```
  
  
__d_Lplot.z 1|Site__    
7 optimizer(s) failed


__d.z 1|Site__   
7 optimizer(s) failed


### Comparação de Modelos Cheios:

```{r l_nRef_ModeloCheioFinal,eval=FALSE,echo=FALSE}
v_glmerOK <- df_auditoria.md[df_auditoria.md$warning_message == "OK",]$glmer %>% 
  as.character()
l_nRef_ModeloCheioFinal <- l_nRef__modeloCheio2[v_glmerOK]
save(l_nRef_ModeloCheioFinal,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_ModeloCheioFinal.Rdata")
```

```{r nRef modelo cheio final tabela de aIC,results="hide"}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_ModeloCheioFinal.Rdata")
df_tableGLMM <- print(AICctab(l_nRef_ModeloCheioFinal,weights=TRUE)) %>% 
  as.data.frame()
df_tableGLMM$GLMM <- row.names(df_tableGLMM) %>% gsub(".z","",.)
df_tableGLMM$weight <- as.character(df_tableGLMM$weight)
df_tableGLMM$dAICc <- as.numeric(as.character(df_tableGLMM$dAICc))
rownames(df_tableGLMM) <- NULL
df_tableGLMM <- df_tableGLMM[,c(4,1:3)]
```

__Tabela 2.3__ Comparação baseada em AICc dos modelos cheios  
  
```{r tabela 23}
knitr::kable(df_tableGLMM) %>% 
  kableExtra::kable_styling()
```
  
  
__Tabela 2.4__ Coeficiente de Determinação Condicional e Marginal

```{r tabela 24 coeficiente de determinacao condicional e marginal,cache=TRUE}
md_nRef <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                   (p.z + I(p.z^2)) * (d.z + I(d.z^2)) * MN + 
                   ( (d.z + I(d.z^2) ) * MN|SiteCode),
                 family = "binomial",data=df_resultados,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)),
                 na.action = "na.fail")
r.squaredGLMM(md_nRef)
```




#### Diagnostico do modelo cheio mais plausível 
  
  
__Figura 2.3__ Resíduos Quantílicos do modelo cheio plausível  
  
    
```{r auditoria mais plausivel md_n.ref1, message=FALSE,eval=TRUE,echo=FALSE}
p_plot <- simulateResiduals(md_nRef,n=1000)
plot(p_plot)
```
  
  
    
__Figura 2.4__ Quantile-quantile plot random effects.    
  
    
```{r figura 24 qqplots random effects}
df_ranef <- ranef(md_nRef)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  ggplot(aes(sample=parameter_value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") + theme_classic() +
  facet_wrap(~parameter_class,scales="free",ncol=3)
```
      
  
  
  
__Figura 2.5__ Predito e observado pelo modelo. Em vermelho linha y=x; em azul um modelo linear por sítio de amostragem.      
    
      
```{r fiigura 25,fig.height=4}
# dados
df_md <- md_nRef@frame
df_md$nRef_observado <- df_md$`cbind(n_nRef, 100 - n_nRef)`[,1]
df_md$nRef_predito <- predict(md_nRef,type="response") * 100
# graficos
ggplot(df_md,aes(x=nRef_observado,y=nRef_predito)) +
  geom_smooth(method = "lm",aes(group=SiteCode),se=FALSE,alpha=0.3) +
  geom_abline(slope = 1,intercept = 0,col="red",alpha=0.8,size=2) +
  geom_point(alpha=0.3) +
  facet_wrap(~MN,ncol=2,scales="free") + theme_classic() + xlim(0,100) + ylim(0,100) 
```
  
  
  
  
__Figura 2.6__ Predito e observado para modelo cheio    
  
```{r avaliacao por site fig 26, fig.width=8, fig.height=30,message=FALSE,eval=TRUE,echo=FALSE}
# Dados
## filtrados para o modelo
df_plot <- df_resultados
df_plot$Pr_nRef <- predict(md_nRef,type="response")*100
# df_plot %>% str
# Graficos
df_plot %<>% mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
ggplot(df_plot,aes(x=d.z,y=n_nRef,group=MN)) +
  geom_point(aes(color=MN),alpha=0.3) +
  geom_line(aes(y=Pr_nRef,color=MN),alpha=0.3) +
  scale_color_manual(values=c("#FF0000", "#000000")) +
  theme_classic() + theme(legend.position="top") + labs(x="d(metros)",y="nRef(count)") +
  facet_wrap(~title,ncol=6)
```


      
  
  
## 2.2 GLMM binomial, subset=MNEE

### Estudo GAMM: smoother type

i) Antes de comparar os modelos cheios preciso avaliar smoother type mais para utilizar na GAMM;
ii) Pelo observado nos dados (figuras 2.1 e 2.2) vou comparar dois smoother type: "tp" e "cr"
iii) Para isso vou ajuster um smoother para d por Sítio de amostragem com um mesmo parâmetro de penalização, dessa maneira eu considero a variação por sítio de amostragem na variável d sem um elevado custo computacional.  


```{r nRef MNEE estudo GAMM smoother type,echo=TRUE,eval=FALSE}
# dados
df_md <- df_resultados %>% filter(MN=="EE") %>% distinct()
df_md <- rbind(mutate(df_md,model_class = "cr"),
               mutate(df_md,model_class = "tp"))
df_md$model_class <- factor(df_md$model_class)
# função
f_md <- function(dados){
  model_class <- unique(dados$model_class)
  if(model_class == "cr"){
    md_ <- gam(cbind(n_nRef,100-n_nRef) ~ 
                 s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                 s(d.z,SiteCode,bs="fs",xt=list(bs="cr"), m=1),
                data = dados, family = "binomial")
    
  }else{
    md_ <- gam(cbind(n_nRef,100-n_nRef) ~ 
                 s(p.z,bs="tp") + s(d.z,bs="tp") + ti(p.z,d.z,bs=c("tp","tp")) +
                 s(d.z,SiteCode,bs="fs",xt=list(bs="tp"), m=1),
                data = dados, family = "binomial")
    
  }
  return(md_)
}
registerDoMC(2)
l_nRefEE_estudoGAMM <- dlply(df_md,"model_class",f_md,.parallel = TRUE)
```


```{r l_nRefEE_estudoGAMM, echo=FALSE, eval=FALSE}
save(l_nRefEE_estudoGAMM,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEE_estudoGAMM.Rdata")
```

```{r AICctab ,eval=FALSE,echo=FALSE}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEE_estudoGAMM.Rdata")
AICctab(l_nRefEE_estudoGAMM,weights=TRUE)
```



### Comparação Modelos Cheios

```{r comparacao modelos cheios nRefEE,echo=TRUE,eval=TRUE}
# dados
df_md <- df_resultados %>% filter(MN=="EE") %>% 
  distinct() %>% 
  mutate(rep = 1)
df_md <- left_join(x=data.frame(rep=1,
                                md_class=c("glmm d+d^2|Site",
                                           "glmm d|Site",
                                           "glmm 1|Site",
                                           "gamm d|Site for each",
                                           "gamm d|Site common",
                                           "gamm 1|Site")),
                   y=df_md,
                   by="rep")
# função de ajuste
f_md <- function(dados){
  md_class <- unique(dados$md_class)
  if(md_class == "glmm d+d^2|Site"){
    md_ <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                      (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                      (d.z + I(d.z^2)|SiteCode),
                 family = "binomial",data=dados,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)),
                 na.action = "na.fail")
  }else if(md_class == "glmm d|Site"){
    md_ <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                      (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                      (d.z|SiteCode),
                 family = "binomial",data=dados,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)),
                 na.action = "na.fail")
  }else if(md_class == "glmm 1|Site"){
    md_ <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                      (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                      (1|SiteCode),
                 family = "binomial",data=dados,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)),
                 na.action = "na.fail")
  }else if(md_class == "gamm d|Site for each"){
    md_ <- gam(cbind(n_nRef,100-n_nRef) ~ 
                 s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                 s(SiteCode,bs="re") + s(d.z,by=SiteCode,bs="cr",m=1),
                data = dados, family = "binomial")
  }else if(md_class == "gamm d|Site common"){
    md_ <- gam(cbind(n_nRef,100-n_nRef) ~ 
                 s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                 s(d.z,SiteCode,bs="fs",xt=list(bs="cr"), m=1),
                data = dados, family = "binomial")
  }else{
    md_ <- gam(cbind(n_nRef,100-n_nRef) ~ 
                 s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                 s(SiteCode,bs="re"),
                data = dados, family = "binomial")
  }
  return(md_)
}
```

```{r dlply f md nRef EE, eval=FALSE,echo=TRUE}
registerDoMC(3)
l_nRefEE_mdCheio <- dlply(df_md,"md_class",f_md,.parallel = TRUE)
```


```{r save l_nRefEE_mdCheio, eval=FALSE}
save(l_nRefEE_mdCheio,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEE_mdCheio.Rdata")
```

```{r AICctab l_nRefEE_mdCheio,echo=FALSE,eval=TRUE}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEE_mdCheio.Rdata")
AICctab(l_nRefEE_mdCheio,weights=TRUE)
md_nRefEE1 <- l_nRefEE_mdCheio[["gamm d|Site for each"]]
```


#### Diagnostico modelo cheio

__Figura 2.2.1__ gam.check(md_nRefEE1)


```{r fig 221,eval=TRUE,echo=FALSE}
par(mfrow=c(2,2))
gam.check(md_nRefEE1)
```
  
  
__tabela 2.2.1__ Summary
  
```{r tabela 221,eval=TRUE,echo=FALSE}
summary(md_nRefEE1)
```




__Figura 2.2.2__ Observado e predito pelo modelo cheio mais plausível  

```{r fig 222 predito e observado por sitio md_nRefEE, echo=FALSE,eval=TRUE, fig.width=8, fig.height=30,message=FALSE}
# dados
df_plot <- df_resultados %>% filter(MN=="EE") %>% distinct()
df_plot$nRef_predito <- predict.gam(md_nRefEE1,se.fit = TRUE,type="response")$fit*100
df_plot$nRef_se <- predict.gam(md_nRefEE1,se.fit = TRUE,type="response")$se*100
df_plot %<>%
  mutate(title = paste0(SiteCode, " p=",round(p,digits = 3)),
         yLower=nRef_predito-nRef_se,
         yUpper=nRef_predito+nRef_se) %>% 
  arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
# plot
ggplot(df_plot,aes(x=d.z,y=n_nRef)) +
  geom_ribbon(aes(ymin = yLower, ymax = yUpper),alpha=0.3,fill="blue") +
  geom_point(alpha=0.3) +
  geom_line(aes(y=nRef_predito),alpha=0.5,col="red") +
  theme_classic() + labs(x="d(metros)",y="nRef(count)") + labs(title = "subset : MN==EE")+
  facet_wrap(~title,ncol=6)
```



__Figura 2.2.3__ Diagnostico: avaliação do ajuste pelas preditoras lineares

```{r fig 223,echo=FALSE,eval=TRUE,fig.height=5}
#
df_plot <- augment(md_nRefEE1) 
df_plot1 <- df_plot %>% 
  select(p.z,d.z,.fitted,.resid,.hat,.cooksd) %>% 
  gather(key = preditora_class, value = preditora_value,p.z:d.z) %>% 
  gather(key = var_diagnostico, value = var_value,.fitted:.cooksd)
df_plot1$var_diagnostico <- factor(df_plot1$var_diagnostico,levels = unique(df_plot1$var_diagnostico))
#
f_p <- function(dados){
  title_ <- unique(dados$var_diagnostico) %>% 
    as.character()
  p <- ggplot(dados,aes(x=preditora_value,y=var_value)) + 
  geom_point(alpha=0.3) + 
  geom_smooth(method = "loess",se=TRUE) + 
  facet_wrap(~preditora_class,ncol=2,scales="free") +
  labs(title = title_,x="",y="")
}
l_p <- dlply(df_plot1,.(var_diagnostico),f_p)
# p_ <- ggplot(df_plot,aes(y=var_value)) + 
#   # geom_jitter(alpha=0.3) +
#   geom_boxplot() + 
#   facet_wrap(~var_diagnostico,ncol=4,scales="free")
do.call("grid.arrange",c(l_p,ncol=2))
#
# ggplot(df_plot,aes(x=p.z,y=.fitted)) + 
#   geom_point(alpha=0.3) + 
#   geom_smooth(method = "loess",se=TRUE) +
#   scale_y_continuous(breaks = round(seq(min(df_plot$.fitted), max(df_plot$.fitted), by = 100),1))
  # facet_wrap(~preditora_class,ncol=2,scales="free") +
  # labs(title = title_,x="",y="")
```


```{r nRefEE candidatos outlier,eval=TRUE,echo=TRUE}
v_sitesOut_nRefEE <- filter(df_plot,.fitted < -300 | .fitted > 380 | .cooksd > 2000) %>%
  .$SiteCode %>% unique
```

```{r nRefEE possiveis sitios outliers,eval=TRUE,echo=FALSE,fig.width=4, fig.height=2}
# dados
df_plot <- df_resultados %>% filter(MN=="EE") %>% distinct()
df_plot$nRef_predito <- predict.gam(md_nRefEE1,se.fit = TRUE,type="response")$fit*100
df_plot$nRef_se <- predict.gam(md_nRefEE1,se.fit = TRUE,type="response")$se*100
df_plot %<>%
  mutate(title = paste0(SiteCode, " p=",round(p,digits = 3)),
         yLower=nRef_predito-nRef_se,
         yUpper=nRef_predito+nRef_se) %>% 
  arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
df_plot %<>% filter(SiteCode %in% v_sitesOut_nRefEE)
# plot
ggplot(df_plot,aes(x=d.z,y=n_nRef)) +
  geom_ribbon(aes(ymin = yLower, ymax = yUpper),alpha=0.3,fill="blue") +
  geom_point(alpha=0.3) +
  geom_line(aes(y=nRef_predito),alpha=0.5,col="red") +
  theme_classic() + labs(x="d(metros)",y="nRef(count)") + labs(title = "subset : MN==EE, outliers?")+
  facet_wrap(~title,ncol=3)
```


  
#### Comparação Modelo Cheio sem outliers

```{r nRefEE sem outliers md cheio,eval=FALSE,echo=TRUE}
# sites outlier
v_sitesOut_nRefEE <- filter(df_plot,.fitted < -300 | .fitted > 380 | .cooksd > 2000) %>%
  .$SiteCode %>% unique
# dados
df_md <- df_resultados %>% filter(MN=="EE" & !(SiteCode %in% v_sitesOut_nRefEE)) %>% 
  distinct() %>% 
  mutate(rep = 1) 
df_md <- left_join(x=data.frame(rep=1,
                                md_class=c("glmm d+d^2|Site",
                                           "glmm d|Site",
                                           "glmm 1|Site",
                                           "gamm d|Site for each",
                                           "gamm d|Site common",
                                           "gamm 1|Site")),
                   y=df_md,
                   by="rep")
# ajuste modelos
registerDoMC(3)
l_nRefEE_mdCheio__sOut <- dlply(df_md,"md_class",f_md,.parallel = TRUE)
```

```{r save l_nRefEE_mdCheio__sOut,eval=FALSE,echo=FALSE}
save(l_nRefEE_mdCheio__sOut,file = "~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEE_mdCheio__sOut.Rdata")
```

```{r AICctab l_nRefEE_mdCheio__sOut}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEE_mdCheio__sOut.Rdata")
AICctab(l_nRefEE_mdCheio__sOut,weights=TRUE)
```
  
    
#### Diagnosticos modelo cheio sem outliers  

__Figura 2.2.4__ Appraise(md_nRefEE_sOut)       
      
```{r md cheio sOut nRefEE,echo=FALSE,eval=TRUE}
md_nRefEE_sOut <- l_nRefEE_mdCheio__sOut[["gamm d|Site for each"]]
df_md <- df_resultados %>% filter(MN=="EE" & !(SiteCode %in% v_sitesOut_nRefEE))
appraise(md_nRefEE_sOut)
```
  
  
<!-- __Figura 2.2.5__ Observado e predito pelo modelo cheio mais plausível   -->
  
```{r fig 225 predito e observado por sitio md_nRefEE, echo=FALSE,eval=FALSE, fig.width=8, fig.height=30,message=FALSE}
# dados
df_plot <- df_md
df_plot$nRef_predito <- predict.gam(md_nRefEE_sOut,se.fit = TRUE,type="response")$fit*100
df_plot$nRef_se <- predict.gam(md_nRefEE_sOut,se.fit = TRUE,type="response")$se*100
df_plot %<>%
  mutate(title = paste0(SiteCode, " p=",round(p,digits = 3)),
         yLower=nRef_predito-nRef_se,
         yUpper=nRef_predito+nRef_se) %>% 
  arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
# plot
ggplot(df_plot,aes(x=d.z,y=n_nRef)) +
  geom_ribbon(aes(ymin = yLower, ymax = yUpper),alpha=0.3,fill="blue") +
  geom_point(alpha=0.3) +
  geom_line(aes(y=nRef_predito),alpha=0.5,col="red") +
  theme_classic() + labs(x="d(metros)",y="nRef(count)") + labs(title = "subset : MN==EE")+
  facet_wrap(~title,ncol=6)
```


__Figura 2.2.5__ Diagnostico: avaliação do ajuste pelas preditoras lineares

```{r fig 225,echo=FALSE,eval=TRUE,fig.height=5}
#
df_plot <- augment(md_nRefEE_sOut) 
df_plot1 <- df_plot %>% 
  select(p.z,d.z,.fitted,.resid,.hat,.cooksd) %>% 
  gather(key = preditora_class, value = preditora_value,p.z:d.z) %>% 
  gather(key = var_diagnostico, value = var_value,.fitted:.cooksd)
df_plot1$var_diagnostico <- factor(df_plot1$var_diagnostico,levels = unique(df_plot1$var_diagnostico))
#
f_p <- function(dados){
  title_ <- unique(dados$var_diagnostico) %>% 
    as.character()
  p <- ggplot(dados,aes(x=preditora_value,y=var_value)) + 
  geom_point(alpha=0.3) + 
  geom_smooth(method = "loess",se=TRUE) + 
  facet_wrap(~preditora_class,ncol=2,scales="free") +
  labs(title = title_,x="",y="")
}
l_p <- dlply(df_plot1,.(var_diagnostico),f_p)
# p_ <- ggplot(df_plot,aes(y=var_value)) + 
#   # geom_jitter(alpha=0.3) +
#   geom_boxplot() + 
#   facet_wrap(~var_diagnostico,ncol=4,scales="free")
do.call("grid.arrange",c(l_p,ncol=2))
#
# ggplot(df_plot,aes(x=p.z,y=.fitted)) + 
#   geom_point(alpha=0.3) + 
#   geom_smooth(method = "loess",se=TRUE) +
#   scale_y_continuous(breaks = round(seq(min(df_plot$.fitted), max(df_plot$.fitted), by = 100),1))
  # facet_wrap(~preditora_class,ncol=2,scales="free") +
  # labs(title = title_,x="",y="")
```
  
  
## 2.3 GLMM binomial, subset=MNEI

### Estudo GAMM: smoother type

i) Antes de comparar os modelos cheios preciso avaliar smoother type mais para utilizar na GAMM;
ii) Pelo observado nos dados (figuras 2.1 e 2.2) vou comparar dois smoother type: "tp" e "cr"
iii) Para isso vou ajuster um smoother para d por Sítio de amostragem com um mesmo parâmetro de penalização, dessa maneira eu considero a variação por sítio de amostragem na variável d sem um elevado custo computacional.  


```{r nRef MNEI estudo GAMM smoother type,echo=TRUE,eval=FALSE}
# dados
df_md <- df_resultados %>% filter(MN=="EI") %>% distinct()
df_md <- rbind(mutate(df_md,model_class = "cr"),
               mutate(df_md,model_class = "tp"))
df_md$model_class <- factor(df_md$model_class)
# função
f_md <- function(dados){
  model_class <- unique(dados$model_class)
  if(model_class == "cr"){
    md_ <- gam(cbind(n_nRef,100-n_nRef) ~ 
                 s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                 s(d.z,SiteCode,bs="fs",xt=list(bs="cr"), m=1),
                data = dados, family = "binomial")
    
  }else{
    md_ <- gam(cbind(n_nRef,100-n_nRef) ~ 
                 s(p.z,bs="tp") + s(d.z,bs="tp") + ti(p.z,d.z,bs=c("tp","tp")) +
                 s(d.z,SiteCode,bs="fs",xt=list(bs="tp"), m=1),
                data = dados, family = "binomial")
    
  }
  return(md_)
}
registerDoMC(2)
l_nRefEI_estudoGAMM <- dlply(df_md,"model_class",f_md,.parallel = TRUE)
```

```{r save l_nRefEI_estudoGAMM,eval=FALSE}
save(l_nRefEI_estudoGAMM,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEI_estudoGAMM.Rdata")
```

```{r AICctab l_nRefEI_estudoGAMM,eval=TRUE,echo=FALSE}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEI_estudoGAMM.Rdata")
AICctab(l_nRefEI_estudoGAMM,weights=TRUE)
```


### Comparação Modelos Cheios

```{r comparacao modelos cheios nRefEI,echo=TRUE,eval=FALSE}
# dados
df_md <- df_resultados %>% filter(MN=="EI") %>% 
  distinct() %>% 
  mutate(rep = 1)
df_md <- left_join(x=data.frame(rep=1,
                                md_class=c("glmm d+d^2|Site",
                                           "glmm d|Site",
                                           "glmm 1|Site",
                                           "gamm d|Site for each",
                                           "gamm d|Site common",
                                           "gamm 1|Site")),
                   y=df_md,
                   by="rep")
# função de ajuste
registerDoMC(3)
l_nRefEI_mdCheio <- dlply(df_md,"md_class",f_md,.parallel = TRUE)
```


```{r save l_nRefEI_mdCheio, eval=FALSE}
save(l_nRefEI_mdCheio,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEI_mdCheio.Rdata")
```

```{r AICctab l_nRefEI_mdCheio,echo=FALSE,eval=TRUE}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEI_mdCheio.Rdata")
AICctab(l_nRefEI_mdCheio,weights=TRUE)
md_nRefEI <- l_nRefEI_mdCheio[["gamm d|Site for each"]]
```


#### Diagnostico modelo cheio

__Figura 2.3.1__ appraise(md_nRefEI)

```{r fig 231,echo=FALSE,eval=TRUE}
par(mfrow=c(2,2))
gam.check(md_nRefEI)
```

```{r summary nRefEI,echo=FALSE}
summary(md_nRefEI)
```


__Figura 2.3.2__ Predito e observado por sítio 

```{r fig 232 predito e observado por sitio md_nRefEE, echo=FALSE,eval=TRUE, fig.width=8, fig.height=30,message=FALSE}
# dados
df_plot <- df_resultados %>% filter(MN=="EI") %>% distinct()
df_plot$nRef_predito <- predict.gam(md_nRefEI,se.fit = TRUE,type="response")$fit*100
df_plot$nRef_se <- predict.gam(md_nRefEI,se.fit = TRUE,type="response")$se*100
df_plot %<>%
  mutate(title = paste0(SiteCode, " p=",round(p,digits = 3)),
         yLower=nRef_predito-nRef_se,
         yUpper=nRef_predito+nRef_se) %>% 
  arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
# plot
ggplot(df_plot,aes(x=d.z,y=n_nRef)) +
  geom_ribbon(aes(ymin = yLower, ymax = yUpper),alpha=0.3,fill="blue") +
  geom_point(alpha=0.3) +
  geom_line(aes(y=nRef_predito),alpha=0.5,col="red") +
  theme_classic() + labs(x="d(metros)",y="nRef(count)") + labs(title = "subset : MN==EI")+
  facet_wrap(~title,ncol=6)
```
  
  
__Figura 2.3.3__ Diagnostico: avaliação do ajuste pelas preditoras lineares

```{r fig 233,echo=FALSE,eval=TRUE,fig.height=5}
#
df_plot <- augment(md_nRefEI) 
df_plot1 <- df_plot %>% 
  select(p.z,d.z,.fitted,.resid,.hat,.cooksd) %>% 
  gather(key = preditora_class, value = preditora_value,p.z:d.z) %>% 
  gather(key = var_diagnostico, value = var_value,.fitted:.cooksd)
df_plot1$var_diagnostico <- factor(df_plot1$var_diagnostico,levels = unique(df_plot1$var_diagnostico))
#
f_p <- function(dados){
  title_ <- unique(dados$var_diagnostico) %>% 
    as.character()
  p <- ggplot(dados,aes(x=preditora_value,y=var_value)) + 
  geom_point(alpha=0.3) + 
  geom_smooth(method = "loess",se=TRUE) + 
  facet_wrap(~preditora_class,ncol=2,scales="free") +
  labs(title = title_,x="",y="")
}
l_p <- dlply(df_plot1,.(var_diagnostico),f_p)
# p_ <- ggplot(df_plot,aes(y=var_value)) + 
#   # geom_jitter(alpha=0.3) +
#   geom_boxplot() + 
#   facet_wrap(~var_diagnostico,ncol=4,scales="free")
do.call("grid.arrange",c(l_p,ncol=2))
#
# ggplot(df_plot,aes(x=p.z,y=.fitted)) + 
#   geom_point(alpha=0.3) + 
#   geom_smooth(method = "loess",se=TRUE) +
#   scale_y_continuous(breaks = round(seq(min(df_plot$.fitted), max(df_plot$.fitted), by = 100),1))
  # facet_wrap(~preditora_class,ncol=2,scales="free") +
  # labs(title = title_,x="",y="")
#
```
  
    
  
## 2.4 Conjunto Completo dos Dados

### Dados

```{r}
# new data
df_pred0 <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1],
                       d.z=seq(min(df_resultados$d.z),max(df_resultados$d.z),length=40),
                       p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=200))
# number of posterior draws
f_rmvn <- function(n,mu,sig){
  L <- mroot(sig)
  m <- ncol(L)
  t(mu + L%*%matrix(rnorm(m*n),m,n))
}
# lista de modelos
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEE_mdCheio.Rdata")
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEI_mdCheio.Rdata")
l_mdNref <- list()
l_mdNref[[1]] <- l_nRefEE_mdCheio[["gamm d|Site for each"]]
l_mdNref[[2]] <- l_nRefEI_mdCheio[["gamm d|Site for each"]]
names(l_mdNref) <- c("EE","EI")
# Função para indice para calculo do intervalo de credibilidade
## codigo adaptado de post de Gavin Simpson 2016
## acessado em abril 2020
## https://fromthebottomoftheheap.net/2016/12/15/simultaneous-interval-revisited/
f_CI.index <- function(gamm,df=df_pred0,N=10000){
  Vb_ <- vcov(gamm)
  pred_ <- predict.gam(gamm,df,se.fit = TRUE)
  se.fit_ <- pred_$se.fit 
  BUdiff_ <- f_rmvn(N,mu=rep(0,nrow(Vb_)),sig=Vb_)
  Cg_ <- predict(gamm,df,type="lpmatrix")
  simDev_ <- Cg_ %*% t(BUdiff_)
  absDev_ <- abs(sweep(simDev_, 1, se.fit_, FUN = "/"))
  masd_ <- apply(absDev_, 2L, max)
  crit_ <- quantile(masd_,prob=0.95,type=8)
return(crit_)  
}
# calculo index
# set.seed(1)
registerDoMC(2)
df_CI.index <- ldply(l_mdNref,f_CI.index,.id="MN") #,.parallel = TRUE



```




```{r preparacao dos dados,eval=FALSE,echo=FALSE,include=FALSE }
# dados
df_pred0 <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1],
                       d.z=seq(min(df_resultados$d.z),max(df_resultados$d.z),length=40),
                       p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=200))
## EI
predict_nRefEI <- predict.gam(md_nRefEI,newdata = df_pred,type = "link",se.fit = TRUE)
df_predEI <- cbind(df_pred0,
                   data.frame(MN="EI",
                              fit=predict_nRefEI$fit,
                              se.fit=predict_nRefEI$se.fit)) %>% 
  mutate(upper_fit = fit + se.fit,
         lower_fit = fit - se.fit,
         Pr_nRef = arm::invlogit(fit),
         upper_Pr_nRef = arm::invlogit(upper_fit),
         lower_Pr_nRef = arm::invlogit(lower_fit))
## EE
predict_nRefEE <- predict.gam(md_nRefEE,newdata = df_pred,type = "link",se.fit = TRUE)
df_predEI <- cbind(df_pred0,
                   data.frame(MN="EE",
                              fit=predict_nRefEI$fit,
                              se.fit=predict_nRefEI$se.fit)) %>% 
  mutate(upper_fit = fit + se.fit,
         lower_fit = fit - se.fit,
         Pr_nRef = arm::invlogit(fit),
         upper_Pr_nRef = arm::invlogit(upper_fit),
         lower_Pr_nRef = arm::invlogit(lower_fit))
# graficos 1



# graficos
         # logOR_EE.EI = fitEE - fitEI,
         # upper_logOR_EE.EI = upper_fitEE - upper_fitEI,
         # lower_logOR_EE.EI = lower_fitEE - lower_fitEI)


```




```{r eval=FALSE,include=FALSE}





df_plot <- rbind(mdAvg_nRefEE__AICcmodavg,mdAvg_nRefEI__AICcmodavg)
df_plot %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
                    d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
## Gráficos
l_p.nRefEE_AICcmodavg <- list()
labels_IC <- c(lower.CL="IC 5%", upper.CL="IC 95%")
## predição média para ambos modelos
l_p.nRefEE_AICcmodavg[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(
    # title="Probabilidade de Não Refutar",
       fill="Probability") +
  theme_classic() + facet_wrap(~MN,ncol=2) + theme(legend.position="top")
## IC para MNEE
df_plotEE <- df_plot %>% filter(MN=="EE") %>%
  gather(key = IC_class ,value = IC_pred,lower.CL:upper.CL)
l_p.nRefEE_AICcmodavg[[2]] <- ggplot(df_plotEE,aes(x=p,y=d,fill=IC_pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  theme_classic() + facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) + theme(legend.position='none')
## IC para MNEI
df_plotEI <- df_plot %>% filter(MN=="EI") %>%
  gather(key = IC_class ,value = IC_pred,lower.CL:upper.CL)
l_p.nRefEE_AICcmodavg[[3]] <- ggplot(df_plotEI,aes(x=p,y=d,fill=IC_pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  theme_classic() + facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) + theme(legend.position='none')
## Arranjo dos gráficos
grid.arrange(l_p.nRefEE_AICcmodavg[[1]],l_p.nRefEE_AICcmodavg[[2]],l_p.nRefEE_AICcmodavg[[3]],
             layout_matrix=rbind(rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 c(2,2,3,3),
                                 c(2,2,3,3))
             )

```




  
<!-- ## 1.2 GLMM binomail subset:MN==EE -->

<!-- ### Modelo cheio -->

<!-- ```{r glmm quadratico n_nRef MNEE modelo cheio,echo=TRUE,eval=FALSE} -->
<!-- l_md <- vector("list",3) -->
<!-- names(l_md) <- c("1|Site","d|Site","d + d^2|Site") -->
<!-- l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ -->
<!--                      ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) + -->
<!--                      (1|SiteCode), -->
<!--                    family = "binomial",data=filter(df_resultados,MN=="EE"), -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ -->
<!--                      ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) + -->
<!--                      (d.z|SiteCode), -->
<!--                    family = "binomial",data=filter(df_resultados,MN=="EE"), -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~ -->
<!--                      ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) + -->
<!--                      (d.z + I(d.z^2)|SiteCode), -->
<!--                    family = "binomial",data=filter(df_resultados,MN=="EE"), -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- ``` -->

<!-- ```{r l_md_nRef.GLMM_EE,echo=FALSE,eval=FALSE} -->
<!-- l_md_nRef.GLMM_EE <- l_md -->
<!-- save(l_md_nRef.GLMM_EE,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef.GLMM_EE.Rdata") -->
<!-- ``` -->

<!-- __Tabela 1.2.1__ AICctab para n_nRef MNEE  -->

<!-- ```{r glmm quadratico n_nRef MNEE modelo cheio AICctab} -->
<!-- load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef.GLMM_EE.Rdata") -->
<!-- AICctab(l_md_nRef.GLMM_EE,weights=TRUE) -->
<!-- ``` -->


<!-- O modelo mais plausível considera um termo linear e quadrático para d na estrutura aletória.  -->


<!-- ```{r fig 119 res quant glmm cheio MNEE} -->
<!-- p_plot <- DHARMa::simulateResiduals(l_md_nRef.GLMM_EE[["d + d^2|Site"]],n=1000) -->
<!-- plot(p_plot)   -->
<!-- ``` -->

<!-- __Figura 1.6__ Resíduos Quantílicos do glmm cheio para MNEE     -->


<!-- __Tabela 1.2.2__ R2 condicional e marginal modelo cheio nRef  -->

<!-- ```{r tabela md cheio para MNEE nRef,message=FALSE,warning=FALSE} -->
<!-- r.squaredGLMM(l_md_nRef.GLMM_EE[["d + d^2|Site"]]) -->
<!-- ``` -->



<!-- ```{r avaliacao por site fig 17 glmm EE p2 d2,fig.width=8, fig.height=30,message=FALSE,eval=FALSE} -->
<!-- # Dados -->
<!-- df_plot <- df_resultados %>% filter(MN=="EE") -->
<!-- # df_plot <- cbind(df_plot, -->
<!-- #   predictInterval(merMod = l_md_nRef.GLMM_EE[["d + d^2|Site"]], -->
<!-- #                          level = 0.95, n.sims=200, -->
<!-- #                          stat="median",type = "probability", -->
<!-- #                          include.resid.var = TRUE)*100 -->
<!-- #                  ) -->
<!-- df_plot$Pr_nRef <- predict(l_md_nRef.GLMM_EE[["d + d^2|Site"]],type="response")*100 -->
<!-- # Graficos -->
<!-- df_plot %<>% mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p) -->
<!-- df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title)) -->
<!-- ggplot(df_plot,aes(x=d.z,y=n_nRef)) + -->
<!--   geom_point() + -->
<!--   geom_line(aes(y=Pr_nRef),color="red") + -->
<!--   theme_light() + theme(legend.position="top") + facet_wrap(~title,ncol=5) -->
<!-- ``` -->

<!-- <!-- __Figura 1.7__ Predito pelo modelo cheio com termo quadrático para p e d para MN=EE --> -->


<!-- ### Seleção de Variáveis -->



<!-- ```{r modelo global e R2m/c MNEE, echo=TRUE,cache=TRUE} -->
<!-- # dados -->
<!-- df_md <- filter(df_resultados,MN=="EE") -->
<!-- # modelo global -->
<!-- global_md <- glmer(cbind(n_nRef,100-n_nRef) ~ -->
<!--                      ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) + -->
<!--                      (d.z + I(d.z^2)|SiteCode), -->
<!--                    family = "binomial",data=df_md, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)),na.action = "na.fail") -->
<!-- ``` -->


<!-- __Tabela 1.2.3__ R2 condicional e marginal do modelo global -->

<!-- ```{r modelo global dredge e AICctab delta 7 n_nRefEE} -->
<!-- dredge_glmmEE <- dredge(global_md,trace = FALSE,evaluate=TRUE) -->
<!-- subset(dredge_glmmEE,delta<7) -->
<!-- ``` -->






<!-- ```{r model averaging EE MuMIn e AICcmodavg,message=FALSE,eval=FALSE} -->
<!-- library(AICcmodavg) -->
<!-- # todas as combinações de modelo do modelo cheio -->
<!-- l_md.dredge_nRefEE <- lapply(dredge(global_md,trace = FALSE,evaluate=FALSE), eval) -->
<!-- # Model Averaging for SiteCode predictions -->
<!-- mdAvg_nRefEE__MuMIn <- model.avg(l_md.dredge_nRefEE) #,subset<2 -->
<!-- save(mdAvg_nRefEE__MuMIn,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__MuMIn.Rdata") -->
<!-- # Model Averaging for new data predictions -->
<!-- df_pred <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1], -->
<!--                        d.z=seq(min(df_resultados$d.z),max(df_resultados$d.z),length=40), -->
<!--                        p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=200)) -->
<!-- mdAvg_nRefEE__AICcmodavg <- modavgPred(l_md.dredge_nRefEE,newdata = df_pred) %>% -->
<!--   cbind(df_pred) -->
<!-- save(mdAvg_nRefEE__AICcmodavg,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__AICcmodavg.Rdata") -->
<!-- ``` -->

<!-- #### Predito para cada Sítio -->

<!-- Para avaliar o ajuste do modelo ao conjunto de dados utilizo funções do pacote MuMIn (REF) que permite calcular a predição do modelo médio para o conjunto original de dados.   -->


<!-- ```{r glmm quadratico n_nRef MNEE selecao de variaveis, comment=FALSE, message=FALSE,warning=FALSE,results="hide",fig.width=8, fig.height=30} -->
<!-- # Modelo Global -->
<!-- load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__MuMIn.Rdata") -->
<!-- # Predição -->
<!-- df_md <- df_resultados %>% filter(MN=="EE") -->
<!-- df_md$Pr_nRef <- predict(mdAvg_nRefEE__MuMIn,type="response")*100 -->
<!-- # Gráfico -->
<!-- df_md %<>% mutate(title = paste0(SiteCode," p=",round(p,3))) %>% arrange(p) -->
<!-- df_md$title <- factor(df_md$title,levels = unique(df_md$title)) -->
<!-- ggplot(df_md,aes(x=d,y=n_nRef)) +  -->
<!--   geom_point() + geom_line(aes(y=Pr_nRef),color="red") +  -->
<!--   labs(x="Dispersão Média", -->
<!--        y="Número de SADs não Refutadas", -->
<!--        title="Prob. Não Refutar uma SAD neutra MN=EE") + -->
<!--   facet_wrap(~title,ncol=5) + theme_light() -->
<!-- ``` -->

<!-- __Figura 1.7__ Predições por sítio de amostragem do modelo médio calculado a partir do modelo global  -->
<!-- ; pontos: número de SADs neutras refutadas para uma bateria de simulações com um determinada distância média de dispersão; eixo x = distância média de dispersão / largura da área de amostragem; a linha é a probabilidade de não refutar uma SAD neutra segundo a predição média do conjunto de sub-modelos dentro do intervalo de plausibilidade de 7 (Burnham et al 2011) -->


<!-- #### Predito para novo conjunto de dados   -->

<!-- Para avaliar o predito e intervalo de confiança de 95% pelo modelo médio utilizo funções do pacote AICcmodavg (REF).   -->

<!-- ```{r fig 18 predito para novo conjunto de dados glmm nRefEE AICcmodavg} -->
<!-- # dados -->
<!-- ## modelo médio -->
<!-- load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__AICcmodavg.Rdata") -->
<!-- df_plot <- mdAvg_nRefEE__AICcmodavg -->
<!-- # df_plot %>% names -->
<!-- df_plot %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),d = d.z*sd(df_resultados$d) + mean(df_resultados$d)) -->


<!-- l_p.nRefEE_AICcmodavg <- list() -->
<!-- l_p.nRefEE_AICcmodavg[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred)) + -->
<!--   geom_tile() + -->
<!--   scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") + -->
<!--   labs(title="Prob de não Refutar", -->
<!--        fill="Probability") + theme_classic() -->
<!-- l_p.nRefEE_AICcmodavg[[2]] <- ggplot(df_plot,aes(x=p,y=d,fill=lower.CL)) + -->
<!--   geom_tile() + -->
<!--   scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") + -->
<!--   labs(title="Lower IC (5%)", -->
<!--        fill="Probability") + theme_classic() -->
<!-- l_p.nRefEE_AICcmodavg[[3]] <- ggplot(df_plot,aes(x=p,y=d,fill=upper.CL)) + -->
<!--   geom_tile() + -->
<!--   scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") + -->
<!--   labs(title="Upper IC (95%)", -->
<!--        fill="Probability") + theme_classic() -->
<!-- grid.arrange(l_p.nRefEE_AICcmodavg[[1]],l_p.nRefEE_AICcmodavg[[2]],l_p.nRefEE_AICcmodavg[[3]], -->
<!--              layout_matrix=rbind(rep(1,4), -->
<!--                                  rep(1,4), -->
<!--                                  rep(1,4), -->
<!--                                  rep(1,4), -->
<!--                                  c(2,2,3,3), -->
<!--                                  c(2,2,3,3)) -->
<!--              ) -->
<!-- ``` -->

<!-- __Figura 1.8__ Efeito predito de d e p na Probabilidade de não refutar segundo o modelo médio para MN==EE.  No painel superior a predição média, nos paineis inferiores o intervalo de confiança.   -->


<!-- ## 1.3 n_nRef subset:MN==EI   -->


<!-- ```{r glmm quadratico n_nRef MNEI modelo cheio,include=FALSE,eval=FALSE,echo=TRUE} -->
<!-- l_md <- vector("list",3) -->
<!-- names(l_md) <- c("1|Site","d|Site","d + d^2|Site") -->
<!-- l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ -->
<!--                      ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) + -->
<!--                      (1|SiteCode), -->
<!--                    family = "binomial",data=filter(df_resultados,MN=="EI"), -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ -->
<!--                      ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) + -->
<!--                      (d.z|SiteCode), -->
<!--                    family = "binomial",data=filter(df_resultados,MN=="EI"), -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~ -->
<!--                      ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) + -->
<!--                      (d.z + I(d.z^2)|SiteCode), -->
<!--                    family = "binomial",data=filter(df_resultados,MN=="EI"), -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- ``` -->

<!-- ```{r l_md_nRef.GLMM_EI,eval=FALSE} -->
<!-- l_md_nRef.GLMM_EI <- l_md -->
<!-- save(l_md_nRef.GLMM_EI,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef.GLMM_EI.Rdata") -->
<!-- ``` -->



<!-- __Tabela 1.3.1__ AICctab n_nRef MNEI   -->

<!-- ```{r glmm quadratico n_nRef MNEI modelo cheio AICctab} -->
<!-- load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef.GLMM_EI.Rdata") -->
<!-- AICctab(l_md_nRef.GLMM_EI,weights=TRUE) -->
<!-- ``` -->

<!-- A função AICcmodavg::modavgPred aceita apenas a função de ligação canonica logito, então não irei comparar outras funções de ligação -->
<!-- O modelo mais plausível considera um termo linear e quadrático para d na estrutura aletória. Segue seleção de variáveis. -->

<!-- __Tabela 1.3.2__ R2 marginal e condicional n_nRef MNEI   -->


<!-- ```{r r2mc nRefEI} -->
<!-- r.squaredGLMM(l_md_nRef.GLMM_EI[["d + d^2|Site"]]) -->
<!-- ``` -->


<!-- ```{r fig 19 res quant glmm cheio MNEI} -->
<!-- p_plot <- DHARMa::simulateResiduals(l_md_nRef.GLMM_EI[["d + d^2|Site"]],n=1000) -->
<!-- plot(p_plot)   -->
<!-- ``` -->

<!-- __Figura 1.9__ Resíduos Quantílicos do glmm cheio mais plausível para MNEI    -->


<!-- ```{r modelo global n_nRef e R2m/c MNEI, include=TRUE,echo=TRUE,cache=TRUE} -->
<!-- # dados -->
<!-- df_md <- filter(df_resultados,MN=="EI") -->
<!-- # modelo global -->
<!-- global_md <- glmer(cbind(n_nRef,100-n_nRef) ~ -->
<!--                      ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) + -->
<!--                      (d.z + I(d.z^2)|SiteCode), -->
<!--                    family = "binomial",data=df_md, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)),na.action = "na.fail") -->
<!-- ``` -->

<!-- __Tabela 1.3.3__ AICctab n_nRef MNEI delta<7   -->



<!-- ```{r modelo dredge AICctab nRefEI} -->
<!-- dredge_glmmEI <- dredge(global_md,trace = FALSE,evaluate=TRUE) -->
<!-- subset(dredge_glmmEI,delta<7) -->
<!-- ``` -->



<!-- ```{r model averaging EI MuMIn e AICcmodavg,message=FALSE,eval=FALSE} -->
<!-- # todas as combinações de modelo do modelo cheio -->
<!-- l_md.dredge_nRefEI <- lapply(dredge(global_md,trace = FALSE,evaluate=FALSE), eval) -->
<!-- # Model Averaging for SiteCode predictions -->
<!-- mdAvg_nRefEI__MuMIn <- model.avg(l_md.dredge_nRefEI) #,subset<2 -->
<!-- save(mdAvg_nRefEI__MuMIn,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__MuMIn.Rdata") -->
<!-- # Model Averaging for new data predictions -->
<!-- df_pred <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1], -->
<!--                        d.z=seq(min(df_resultados$d.z),max(df_resultados$d.z),length=40), -->
<!--                        p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=200)) -->
<!-- mdAvg_nRefEI__AICcmodavg <- AICcmodavg::modavgPred(l_md.dredge_nRefEI,newdata = df_pred) %>% -->
<!--   cbind(df_pred) -->
<!-- save(mdAvg_nRefEI__AICcmodavg,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__AICcmodavg.Rdata") -->
<!-- ``` -->

<!-- ##### Predito para cada Sítio -->

<!-- Para avaliar o ajuste do modelo ao conjunto de dados utilizo funções do pacote MuMIn (REF) que permite calcular a predição do modelo médio para o conjunto original de dados.   -->


<!-- ```{r glmm quadratico n_nRef MNEI selecao de variaveis, comment=FALSE, message=FALSE,warning=FALSE,results="hide",fig.width=8, fig.height=30} -->
<!-- # Modelo Global -->
<!-- load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__MuMIn.Rdata") -->
<!-- # Predição -->
<!-- df_md <- df_resultados %>% filter(MN=="EI") -->
<!-- df_md$Pr_nRef <- predict(mdAvg_nRefEI__MuMIn,type="response")*100 -->
<!-- # Gráfico -->
<!-- df_md %<>% mutate(title = paste0(SiteCode," p=",round(p,3))) %>% arrange(p) -->
<!-- df_md$title <- factor(df_md$title,levels = unique(df_md$title)) -->
<!-- ggplot(df_md,aes(x=d_Lplot,y=n_nRef)) +  -->
<!--   geom_point() + geom_line(aes(y=Pr_nRef),color="red") +  -->
<!--   labs(x="Dispersão Média per capita / Lado da Área Amostrada", -->
<!--        y="Número de SADs não Refutadas", -->
<!--        title="Prob. Não Refutar uma SAD neutra MN=EI") + -->
<!--   facet_wrap(~title,ncol=5) + theme_classic() -->
<!-- ```   -->

<!-- __Figura 1.10__ Predito por SiteCode a partir do modelo médio para MNEI.   -->




<!-- ```{r fig 111 predito para novo conjunto de dados glmm nRefEI AICcmodavg} -->
<!-- # dados -->
<!-- ## modelo médio -->
<!-- load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__AICcmodavg.Rdata") -->
<!-- df_plot <- mdAvg_nRefEI__AICcmodavg -->
<!-- # df_plot %>% names -->
<!-- df_plot %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),d = d.z*sd(df_resultados$d) + mean(df_resultados$d)) -->


<!-- l_p.nRefEI_AICcmodavg <- list() -->
<!-- l_p.nRefEI_AICcmodavg[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred)) + -->
<!--   geom_tile() + -->
<!--   scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") + -->
<!--   labs(title="Prob de não Refutar", -->
<!--        fill="Probability") + theme_classic() -->
<!-- l_p.nRefEI_AICcmodavg[[2]] <- ggplot(df_plot,aes(x=p,y=d,fill=lower.CL)) + -->
<!--   geom_tile() + -->
<!--   scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") + -->
<!--   labs(title="Lower IC (5%)", -->
<!--        fill="Probability") + theme_classic() -->
<!-- l_p.nRefEI_AICcmodavg[[3]] <- ggplot(df_plot,aes(x=p,y=d,fill=upper.CL)) + -->
<!--   geom_tile() + -->
<!--   scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") + -->
<!--   labs(title="Upper IC (95%)", -->
<!--        fill="Probability") + theme_classic() -->
<!-- grid.arrange(l_p.nRefEI_AICcmodavg[[1]],l_p.nRefEI_AICcmodavg[[2]],l_p.nRefEI_AICcmodavg[[3]], -->
<!--              layout_matrix=rbind(rep(1,4), -->
<!--                                  rep(1,4), -->
<!--                                  rep(1,4), -->
<!--                                  rep(1,4), -->
<!--                                  c(2,2,3,3), -->
<!--                                  c(2,2,3,3)) -->
<!--              ) -->
<!-- ``` -->

<!-- __Figura 1.11__ Efeito predito de d e p na Probabilidade de não refutar segundo o modelo médio para MN==EE.  No painel superior a predição média, nos paineis inferiores o intervalo de confiança.   -->



<!-- ## 1.4 Figura Final -->





<!-- ```{r figura final n_nRef } -->
<!-- ############# -->
<!-- # dados -->
<!-- ## MNEE -->
<!-- load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__AICcmodavg.Rdata") -->
<!-- mdAvg_nRefEE__AICcmodavg$MN <- "EE" -->
<!-- ## MNEI -->
<!-- load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__AICcmodavg.Rdata") -->
<!-- mdAvg_nRefEI__AICcmodavg$MN <- "EI" -->
<!-- ## df comum -->
<!-- df_plot <- rbind(mdAvg_nRefEE__AICcmodavg,mdAvg_nRefEI__AICcmodavg) -->
<!-- df_plot %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p), -->
<!--                     d = d.z*sd(df_resultados$d) + mean(df_resultados$d)) -->
<!-- ## Gráficos -->
<!-- l_p.nRefEE_AICcmodavg <- list() -->
<!-- labels_IC <- c(lower.CL="IC 5%", upper.CL="IC 95%") -->
<!-- ## predição média para ambos modelos -->
<!-- l_p.nRefEE_AICcmodavg[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred)) + -->
<!--   geom_tile() + -->
<!--   scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") + -->
<!--   labs( -->
<!--     # title="Probabilidade de Não Refutar", -->
<!--        fill="Probability") + -->
<!--   theme_classic() + facet_wrap(~MN,ncol=2) + theme(legend.position="top") -->
<!-- ## IC para MNEE -->
<!-- df_plotEE <- df_plot %>% filter(MN=="EE") %>% -->
<!--   gather(key = IC_class ,value = IC_pred,lower.CL:upper.CL) -->
<!-- l_p.nRefEE_AICcmodavg[[2]] <- ggplot(df_plotEE,aes(x=p,y=d,fill=IC_pred)) + -->
<!--   geom_tile() + -->
<!--   scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") + -->
<!--   theme_classic() + facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) + theme(legend.position='none') -->
<!-- ## IC para MNEI -->
<!-- df_plotEI <- df_plot %>% filter(MN=="EI") %>% -->
<!--   gather(key = IC_class ,value = IC_pred,lower.CL:upper.CL) -->
<!-- l_p.nRefEE_AICcmodavg[[3]] <- ggplot(df_plotEI,aes(x=p,y=d,fill=IC_pred)) + -->
<!--   geom_tile() + -->
<!--   scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") + -->
<!--   theme_classic() + facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) + theme(legend.position='none') -->
<!-- ## Arranjo dos gráficos -->
<!-- grid.arrange(l_p.nRefEE_AICcmodavg[[1]],l_p.nRefEE_AICcmodavg[[2]],l_p.nRefEE_AICcmodavg[[3]], -->
<!--              layout_matrix=rbind(rep(1,4), -->
<!--                                  rep(1,4), -->
<!--                                  rep(1,4), -->
<!--                                  rep(1,4), -->
<!--                                  c(2,2,3,3), -->
<!--                                  c(2,2,3,3)) -->
<!--              ) -->


<!-- ``` -->


<!-- __Figura 1.12__ Probabilidade de não refutar uma SAD neutra em função do modelo neutro (EE e EI), proporção de cobertura vegetal (p) e distância média de dispersão (d) -->


<!-- # 2 diff_S = (S_obs - S_MN)/S_obs -->

<!-- __Padrão Geral__ -->

<!-- ```{r preparacao dos dados 1,message=FALSE,eval=TRUE} -->
<!-- # gráfico -->
<!-- df_resultados %>% ggplot(aes(x=p,y=diff_S0,group=MN)) +  -->
<!--   geom_abline(intercept = 0,slope = 0,col="blue") + -->
<!--   geom_point(aes(color=MN),alpha=0.3) + -->
<!--   scale_color_manual(values=c("#FF0000", "#000000")) + -->
<!--   labs(title="diff_S = (S_MN - S_obs)/S_obs",x="p",y="diff_S") + -->
<!--   facet_wrap(~k,ncol=5,scales="free") + theme_light() -->
<!-- # # graficos  -->
<!-- # filter(df_resultados,MN=="EE") %>% select(diff_S0, p, d, Stotal, Ntotal) %>% ggpairs() + labs(title="MNEE") -->
<!-- # do.call("grid.arrange",c(l_p,ncol=1)) -->
<!-- ``` -->

<!-- __Figura 2.1__ diff_S (y-axis), p (x-axis). -->




<!-- ## 2.1 MNEE -->



<!-- ```{r diff_S MNEE modelo cheio,echo=TRUE} -->
<!-- l_md <- vector("list",9) -->
<!-- names(l_md) <- c("1-k 1|Site","1-k I(1-k)|Site", -->
<!--                  "k 1|Site", -->
<!--                  "d 1|Site","d d|Site", -->
<!--                  "d/L 1|Site","d/L I(d/L)|Site", -->
<!--                  "1 1|Site", -->
<!--                  "1") -->
<!-- df_md <- df_resultados %>% filter(MN=="EE") -->
<!-- l_md[[1]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * k_1.z + (1|SiteCode), -->
<!--                    data=df_md,na.action = "na.fail") -->
<!-- l_md[[2]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * k_1.z + (k_1.z|SiteCode), -->
<!--                    data=df_md,na.action = "na.fail") -->
<!-- l_md[[3]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * k + (1|SiteCode), -->
<!--                    data=df_md,na.action = "na.fail") -->
<!-- l_md[[4]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * d.z + (1|SiteCode), -->
<!--                    data=df_md,na.action = "na.fail") -->
<!-- l_md[[5]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * d.z + (d.z|SiteCode), -->
<!--                    data=df_md,na.action = "na.fail") -->
<!-- l_md[[6]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * d_Lplot.z + (1|SiteCode), -->
<!--                    data=df_md,na.action = "na.fail") -->
<!-- l_md[[7]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * d_Lplot.z + (d_Lplot.z|SiteCode), -->
<!--                    data=df_md,na.action = "na.fail") -->
<!-- l_md[[8]] <- lmer(diff_S0 ~ 1 + (1|SiteCode), -->
<!--                    data=df_md,na.action = "na.fail") -->
<!-- l_md[[9]] <- lm(diff_S0 ~ 1, -->
<!--                   data=df_md,na.action = "na.fail") -->
<!-- AICctab(l_md,weights=T) -->
<!-- ``` -->

<!-- Alguns modelos utilizados para estimar diff_S apresentaram "singularidade" (estimativas não diferem de zero), dentre eles o único modelo plausível. Isso indica que modelo com a estrutura aleatória mais simples devem ser ajustados aos dados, assim vou descartar aqueles com inclinação para a variável de dispersão por Sítio. -->

<!-- ```{r diff_S modelo cheio 2,echo=TRUE} -->
<!-- l_md <- vector("list",6) -->
<!-- names(l_md) <- c("1-k 1|Site", -->
<!--                  "k 1|Site", -->
<!--                  "d 1|Site", -->
<!--                  "d/L 1|Site", -->
<!--                  "1 1|Site", -->
<!--                  "1") -->
<!-- df_md <- df_resultados %>% filter(MN=="EE") -->
<!-- l_md[[1]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * k_1.z + (1|SiteCode), -->
<!--                    data=df_md,na.action = "na.fail") -->
<!-- l_md[[2]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * k + (1|SiteCode), -->
<!--                    data=df_md,na.action = "na.fail") -->
<!-- l_md[[3]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * d.z + (1|SiteCode), -->
<!--                    data=df_md,na.action = "na.fail") -->
<!-- l_md[[4]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * d_Lplot.z + (1|SiteCode), -->
<!--                    data=df_md,na.action = "na.fail") -->
<!-- l_md[[5]] <- lmer(diff_S0 ~ 1 + (1|SiteCode), -->
<!--                    data=df_md,na.action = "na.fail") -->
<!-- l_md[[6]] <- lm(diff_S0 ~ 1, -->
<!--                    data=df_md,na.action = "na.fail") -->
<!-- AICctab(l_md,weights=T) -->
<!-- ``` -->

<!-- Nenhum destes modelos apresentou singularidade, o modelo nulo sem estrutura aleatória foi o único plausível. Segue gráfico diagnóstico:   -->


<!-- ```{r graf diag modelo cheio mais plausivel diff_S MNEE,message=FALSE,warning=FALSE} -->
<!-- p_plot <- simulateResiduals(l_md[["1"]],n = 1000) -->
<!-- plot(p_plot) -->
<!-- ``` -->

<!-- __Figura 2.2__ Resíduos Quantílicos do modelo mais plausível para diff_S subset=MNEE (diff_S ~ 1) -->

<!-- __Tabela 2.3__ Sumário do modelo mais plausível para diff_S MNEE   -->

<!-- ```{r} -->
<!-- summary(l_md[["1"]]) -->
<!-- ``` -->

<!-- ## MNEI   -->

<!-- ```{r padroes gerais diff S MNEI, warning=FALSE,message=FALSE} -->
<!-- df_plot <- df_resultados %>% filter(MN=="EI") -->
<!-- ggplot(df_plot,aes(x=p,y=diff_S)) +  -->
<!--   geom_smooth() +  -->
<!--   geom_point(alpha=0.3) +  -->
<!--   facet_wrap(~k,ncol=5,scales="free") -->
<!-- ``` -->

<!-- __Figura 2.3__ diffS_EI ~p*k   -->

<!-- Vou iniciar apenas com as preditoras de interesse (p e variáveis de dispersão). Devido a clara ausência de simetria de diff_S desloquei a distribuição apenas para valores positivos (figura 2.3 primeiro quadro) e utilizarei distribuição Gamma para ajustar os modelos com função de ligação 'log'. -->

<!-- ```{r diff_S MNEI por sitio,fig.width=8, fig.height=30} -->
<!-- df_plot <- df_resultados %>% filter(MN=="EI") -->
<!-- df_plot %<>% mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p) -->
<!-- df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title)) -->
<!-- ## por sítio de amostragem -->
<!-- ggplot(df_plot,aes(x=d,y=diff_S0)) + -->
<!--   geom_point() + -->
<!--   geom_smooth(method="loess",col="blue") + geom_smooth(method="lm",col="red") + -->
<!--   theme_light() + theme(legend.position="top") +  -->
<!--   labs(title=" red = lm; blue = 'loess' ") + -->
<!--   facet_wrap(~title,ncol=5) #,scales="free"  -->
<!-- ``` -->

<!-- __Figura 2.4__ diff_S por sítio de amostragem e d -->

<!-- ### Seleção do Modelo cheio: GLMM -->

<!-- ```{r modelo cheio diff_S MNEI, echo=TRUE,warning=TRUE,message=TRUE,eval=FALSE} -->
<!-- df_md <- df_resultados %>% filter(MN=="EI") -->
<!-- # df_md$diff_S %>% summary -->
<!-- l_md <- vector("list",6) -->
<!-- names(l_md) <- c("1|Site","d|Site", -->
<!--                  "p2*k log", -->
<!--                  "p2*d2 id 1|Site", -->
<!--                  "p2*d2 id d|Site", -->
<!--                  "p2*d2 id d2|Site") -->
<!-- # modelos mínimos -->
<!-- l_md[[1]] <- glmer(diff_S ~ p.z*d.z + (1|SiteCode), -->
<!--                    data=df_md,family="Gamma"(link="log")) -->
<!-- l_md[[2]] <- glmer(diff_S ~ p.z*d.z  + (d.z|SiteCode), -->
<!--                    data=df_md,family="Gamma"(link="log")) -->
<!-- # com p2 -->
<!-- ## erro -->
<!-- l_md[[3]] <- glmer(diff_S ~ (p+I(p.z^2))*k + (1|SiteCode), -->
<!--                    data=df_md,family="Gamma"(link="log")) -->
<!-- v_vars <- getME(l_md[[3]],c("theta","fixef")) -->
<!-- l_md[[3]] <- update(l_md[[3]],start=v_vars,control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5))) -->
<!-- l_md[[3]] <- glmer(diff_S ~ I(p.z^2)*k + (1|SiteCode), -->
<!--                    data=df_md,family="Gamma"(link="log")) -->
<!-- # com p2 e d2 -->
<!-- ####################### -->
<!-- # Model failed to converge with max|grad| = 0.00556207 (tol = 0.002, component 1)Model is nearly unidentifiable: very large eigenvalue -->
<!-- #  - Rescale variables? -->
<!-- l_md[[4]] <- glmer(diff_S ~ (p.z + I(p.z^2))*(d.z + I(d.z^2)) + (1|SiteCode), -->
<!--                    data=df_md,family="Gamma"(link="log")) -->
<!-- v_vars <- getME(l_md[[4]],c("theta","fixef")) -->
<!-- l_md[[4]] <- update(l_md[[4]],start=v_vars,control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5))) -->
<!-- ####################### -->
<!-- ####################### -->
<!-- # Model failed to converge with max|grad| = 0.0608783 (tol = 0.002, component 1)Model is nearly unidentifiable: very large eigenvalue -->
<!-- #  - Rescale variables? -->
<!-- l_md[[5]] <- glmer(diff_S ~ (p.z + I(p.z^2))*(d.z + I(d.z^2)) + (d.z|SiteCode), -->
<!--                    data=df_md,family="Gamma"(link="log")) -->
<!-- v_vars <- getME(l_md[[5]],c("theta","fixef")) -->
<!-- l_md[[5]] <- update(l_md[[5]],start=v_vars,control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5))) -->
<!-- ####################### -->
<!-- # Model failed to converge with max|grad| = 0.336616 (tol = 0.002, component 1)Model is nearly unidentifiable: very large eigenvalue -->
<!-- #  - Rescale variables? -->
<!-- l_md[[6]] <- glmer(diff_S ~ (p.z + I(p.z^2))*(d.z + I(d.z^2)) + (d.z + I(d.z^2)|SiteCode), -->
<!--                    data=df_md,family="Gamma"(link="log")) -->
<!-- v_vars <- getME(l_md[[6]],c("theta","fixef")) -->
<!-- l_md[[6]] <- update(l_md[[6]],start=v_vars,control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5))) -->
<!-- ####################### -->
<!-- ``` -->

<!-- ```{r l_md.diffS_EI_glmm,eval=FALSE} -->
<!-- l_md.diffS_EI_glmm <- l_md -->
<!-- save(l_md.diffS_EI_glmm,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diffS_EI_glmm.Rdata") -->
<!-- ``` -->

<!-- ```{r AICctab l_md.diffS_EI_glmm} -->
<!-- load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diffS_EI_glmm.Rdata") -->
<!-- AICctab(l_md.diffS_EI_glmm,weights=TRUE) -->
<!-- ``` -->


<!-- Não foi possível ajustar os modelos com estrutura fixa mais complexa. Vou avaliar se GAMM oferecem melhor ajuste aos dados -->

<!-- ### GAMM cheio -->

<!-- ```{r diff_S MNEI GAMM cheio,eval=FALSE,echo=TRUE} -->
<!-- l_md <- vector("list",4) -->
<!-- names(l_md) <- c("tp by=k","cr by=k", -->
<!--                  "tp ti","cr ti") -->
<!-- l_md[[1]] <- gam(diff_S ~ s(p.z,by=k,bs="tp") +  -->
<!--                    s(SiteCode,bs="re"), -->
<!--                  data=df_md,family = "Gamma"(link="log")) -->
<!-- l_md[[2]] <- gam(diff_S ~ s(p.z,by=k,bs="cr") +  -->
<!--                    s(SiteCode,bs="re"), -->
<!--                  data=df_md,family = "Gamma"(link="log")) -->
<!-- l_md[[3]] <- gam(diff_S ~ s(p.z,bs="tp") + s(d.z,bs="tp") + ti(p.z,d.z,bs=c("tp","tp")) + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                  data=df_md,family = "Gamma"(link="log")) -->
<!-- l_md[[4]] <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                  data=df_md,family = "Gamma"(link="log")) -->
<!-- ``` -->


<!-- ```{r l_md.diff_S.EI__GAMM,eval=FALSE} -->
<!-- l_md.diff_S.EI__GAMM <- l_md -->
<!-- save(l_md.diff_S.EI__GAMM,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM.Rdata") -->
<!-- ``` -->


<!-- ```{r AICctab modelos cheios diff_S EI GAMM} -->
<!-- load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM.Rdata") -->
<!-- AICctab(l_md.diff_S.EI__GAMM,weights=TRUE) -->
<!-- ``` -->


<!-- O único modelo cheio plausível considera as variáveis p e d (um smoother para cada mais um tensor para ambas) e 1 intercepto por Sítio de Amostragem. -->


<!-- ```{r gamm cheio selecionado diff_S MNEI, warning=FALSE,message=FALSE} -->
<!-- appraise(l_md.diff_S.EI__GAMM[["cr ti"]]) -->
<!-- ``` -->

<!-- __Figura 2.5__ Gráficos Diagnostico do gamm cheio mais plausível para diff_S MN==EI -->

<!-- De maneira geral o modelo esta fazendo um bom ajuste, contudo alguns sítios distoam do padrão geral dos dados. Há duas alternativas: i) possibilitar um smoother por sítio de amostragem com um parâmetro de penalização comum; ou ii) remover sítios outliers. -->

<!-- ```{r update gamm cheio mais plausivel diff_S MNEI,eval=FALSE,echo=TRUE} -->
<!-- l_md <- vector("list",2) -->
<!-- names(l_md) <- c("1|Site","d|Site") -->
<!-- l_md[[1]] <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                  data=df_md,family = "Gamma"(link="log")) -->
<!-- l_md[[2]] <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) + -->
<!--                    s(d.z,SiteCode,bs="fs",xt="cr"), -->
<!--                  data=df_md,family = "Gamma"(link="log")) -->
<!-- ``` -->


<!-- ```{r l_md.diff_S.EI__GAMM2,eval=FALSE} -->
<!-- l_md.diff_S.EI__GAMM2 <- l_md -->
<!-- save(l_md.diff_S.EI__GAMM2,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM2.Rdata") -->
<!-- ``` -->



<!-- ```{r AICctab gamm cheio diff_S MNEI 2} -->
<!-- load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM2.Rdata") -->
<!-- AICctab(l_md.diff_S.EI__GAMM2) -->
<!-- ``` -->

<!-- ```{r graf diag gamm2 diff_S MNEI} -->
<!-- gratia::appraise(l_md.diff_S.EI__GAMM2[["d|Site"]]) -->
<!-- ``` -->

<!-- __Figura 2.6__ Gráfico Diagnóstico gamm cheio com segunda estrutra aleatória diff_S MM==EI -->

<!-- ```{r diff_S MNEI modelo cheio avaliacao,message=FALSE,warning=FALSE,results="hide"} -->
<!-- gratia::draw(l_md.diff_S.EI__GAMM2[["d|Site"]]) -->
<!-- ``` -->

<!-- __Figura 2.7__ gratia::draw() gamm mais plausível com estrutura similar a (d|Site)   -->

<!-- Este modelo apresenta problema de concurvidade. Assim vou refazer a comparação com configuração adequada:   -->

<!-- ```{r updata gamm cheio mais plausível d Site,eval=FALSE,echo=TRUE} -->
<!-- df_md <- filter(df_resultados,MN=="EI") -->
<!-- md_gam.diff_S.EI__update <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) + -->
<!--                    s(d.z,SiteCode,bs="fs",xt=list(bs="cp"), m=1), -->
<!--                  data=df_md,family = "Gamma"(link="log")) -->
<!-- ``` -->

<!-- ```{r md_gam.diff_S.EI__update,eval=FALSE} -->
<!-- save(md_gam.diff_S.EI__update,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/md_diff_S_EI__GAMM_update.Rdata") -->
<!-- ``` -->


<!-- ```{r draw update gamm cheio mais plausivel d Site} -->
<!-- load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/md_diff_S_EI__GAMM_update.Rdata") -->
<!-- l_md.diff_S.EI__GAMM2[[2]] <- md_gam.diff_S.EI__update -->
<!-- gratia::draw(md_gam.diff_S.EI__update) -->
<!-- ``` -->

<!-- __Figura 2.8__ Update do modelo da figura 2.7 com o smoother da estrutura aleatória penalizada pela 1a derivada para diminuir a concurvidade (Perdersen et al. 2019)   -->

<!-- O modelo diminuiu a concurvidade da estimativa. -->

<!-- ```{r  diff_S MNEI gamm cheio segundo plausivel,message=FALSE,warning=FALSE,results="hide",eval=FALSE} -->
<!-- gratia::appraise(md_gam.diff_S.EI__update) -->
<!-- ``` -->

<!-- ![](/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/appraise_gamm_diffS_EI_updata.png){ width=100% }   -->

<!-- __Figura 2.9__ Appraise do gamm cheio atualizado (smoother de estrutura aleatória: m=1).   -->

<!-- ### Remoção de Outliers -->

<!-- Remoção sítios com observações fora do intervalo [-1.5;1.5] dos resíduos deviance.   -->

<!-- ```{r outliers diffS_MNEI gamm,eval=FALSE,echo=TRUE} -->
<!-- # dados completos -->
<!-- df_md <- df_resultados %>% filter(MN=="EI") -->
<!-- df_md$resDev <- residuals.gam(md_gam.diff_S.EI__update) -->
<!-- # sítios considerados outliers -->
<!-- v_SiteOut <- df_md %>% filter(resDev < -0.15 | resDev > 0.15) %>% .$SiteCode %>% unique -->
<!-- # update da comparação -->
<!-- l_md <- vector("list",2) -->
<!-- names(l_md) <- c("1|Site","d|Site") -->
<!-- l_md[[1]] <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                  data=filter(df_md,!(SiteCode %in% v_SiteOut)), -->
<!--                  family = "Gamma"(link="log")) -->
<!-- l_md[[2]] <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) + -->
<!--                    s(d.z,SiteCode,bs="fs",xt=list(bs="cp"),m=1), -->
<!--                  data=filter(df_md,!(SiteCode %in% v_SiteOut)), -->
<!--                  family = "Gamma"(link="log")) -->
<!-- ``` -->

<!-- ```{r l_md.diff_S.EI__GAMM_sOut,eval=FALSE} -->
<!-- l_md.diff_S.EI__GAMM_sOut <- l_md -->
<!-- save(l_md.diff_S.EI__GAMM_sOut,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM_sOut.Rdata") -->
<!-- ``` -->


<!-- ```{r AICctab gamm cheio sem outliers,eval=TRUE} -->
<!-- load("/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM_sOut.Rdata") -->
<!-- AICctab(l_md.diff_S.EI__GAMM_sOut,weights=TRUE) -->
<!-- ``` -->

<!-- ```{r appraise gamm diffS_EI sOut,eval=TRUE} -->
<!-- gratia::appraise(l_md.diff_S.EI__GAMM_sOut[["d|Site"]]) -->
<!-- ``` -->

<!-- __Figura 2.10__ Gráficos diagnóstico do gamm cheio mais plausível sem outliers -->

<!-- A remoção de outliers não melhorou o ajuste do modelo. -->

<!-- ```{r graw gamm cheio diffS_EI sOut,eval=FALSE} -->
<!-- gratia::draw(l_md.diff_S.EI__GAMM_sOut[["d|Site"]]) -->
<!-- ``` -->

<!-- ![](/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/draw_gamm_diffS_EIsOut_fig211.png){ width=100% } -->

<!-- __Figura 2.11__ Efeitos estimados para o gamm cheio diffS_EI sOut -->

<!-- ### Seleção de Variáveis -->

<!-- ```{r gamm diffS_EI selecao de variaveis, eval=FALSE} -->
<!-- # dados completos -->
<!-- df_md <- df_resultados %>% filter(MN=="EI") -->
<!-- df_md$resDev <- residuals.gam(md_gam.diff_S.EI__update) -->
<!-- # sítios considerados outliers -->
<!-- v_SiteOut <- df_md %>% filter(resDev < -0.15 | resDev > 0.15) %>% .$SiteCode %>% unique -->
<!-- # update da comparação -->
<!-- l_md <- vector("list",4) -->
<!-- names(l_md) <- c("p + d + ti(p,d)","p + d","p","d") -->
<!-- l_md[[1]] <- l_md.diff_S.EI__GAMM_sOut[["d|Site"]] -->
<!-- l_md[[2]] <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") + -->
<!--                    s(d.z,SiteCode,bs="fs",xt=list(bs="cp"),m=1), -->
<!--                  data=filter(df_md,!(SiteCode %in% v_SiteOut)), -->
<!--                  family = "Gamma"(link="log")) -->
<!-- l_md[[3]] <- gam(diff_S ~ s(p.z,bs="cr") + -->
<!--                    s(d.z,SiteCode,bs="fs",xt=list(bs="cp"),m=1), -->
<!--                  data=filter(df_md,!(SiteCode %in% v_SiteOut)), -->
<!--                  family = "Gamma"(link="log")) -->
<!-- l_md[[4]] <- gam(diff_S ~ s(d.z,bs="cr") + -->
<!--                    s(d.z,SiteCode,bs="fs",xt=list(bs="cp"),m=1), -->
<!--                  data=filter(df_md,!(SiteCode %in% v_SiteOut)), -->
<!--                  family = "Gamma"(link="log")) -->
<!-- ``` -->

<!-- ```{r l_md.diffS_EI_GAMM_selVars, eval=FALSE} -->
<!-- l_md.diffS_EI_GAMM_selVars <- l_md -->
<!-- save(l_md.diffS_EI_GAMM_selVars,file="/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM_sOut.Rdata") -->
<!-- ``` -->

<!-- ```{r l_md.diffS_EI_GAMM_selVars AICctab,eval=FALSE} -->
<!-- load("/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM_sOut.Rdata") -->
<!-- AICctab(l_md.diffS_EI_GAMM_selVars,weights=TRUE) -->
<!-- ``` -->


<!-- ## Figura Final -->

<!-- ```{r gamm diff_S predicao novo conjunto de dados,eval=FALSE} -->
<!-- l_p <- list() -->
<!-- # dados -->
<!-- ## MNEE -->
<!-- df_md <- df_resultados %>% filter(MN=="EE") -->
<!-- md_diffS_EE <- lm(diff_S0 ~ 1,data=df_md) -->
<!-- coef_diffS_EE <- summary(md_diffS_EE)$coef -->
<!-- coef_diffS_EE[2] -->
<!-- l_p[[1]] <- ggplot(df_md,aes(y=diff_S0,x="")) + geom_jitter() + stat_summary(fun.data = "mean_cl_boot", colour = "red") -->

<!-- ## MNEI -->
<!-- df_pred <- df_pred <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1], -->
<!--                        d.z=seq(min(df_resultados$d.z),max(df_resultados$d.z),length=20), -->
<!--                        p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=103)) -->
<!-- df_pred <- cbind(df_pred, -->
<!--                  predict(l_md.diff_S.EI__GAMM_sOut[["d|Site"]],df_pred,type="response",se.fit=TRUE)) %>%  -->
<!--   mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p), -->
<!--          d = d.z * sd(df_resultados$d) + mean(df_resultados$d), -->
<!--          fit_diff_S0 = fit - min(df_resultados$diff_S0) - 0.01, -->
<!--          se.fit_diff_S0 = se.fit - min(df_resultados$diff_S0) - 0.01,) -->
<!-- df_pred$fit_diff_S0 %>% summary -->
<!-- l_p[[2]] <- ggplot(df_pred,aes(x=p,y=d,fill=fit)) + geom_tile() -->
<!-- ``` -->


<!-- # 3 U  -->

<!-- ## Padrões Gerais   -->

<!-- __figura 4.1 __ U ~ padrões gerais   -->


<!-- ```{r padroes gerais U,warning=FALSE,message=FALSE} -->
<!-- # graficos -->
<!-- l_p <- vector("list",4) -->
<!-- l_p[[1]] <- ggplot(df_resultados,aes(x=k,y=U_med)) + -->
<!--   geom_point() + -->
<!--   geom_line(aes(group=SiteCode)) + -->
<!--   geom_boxplot(aes(group=k)) -->
<!-- l_p[[2]] <- ggplot(df_resultados,aes(x=p,y=U_med)) + -->
<!--   geom_point() + -->
<!--   geom_smooth(method = "auto") + -->
<!--   labs(y="") -->
<!-- l_p[[3]] <- ggplot(df_resultados,aes(x=log(Stotal),y=U_med)) + -->
<!--   geom_point() + -->
<!--   geom_smooth(method = "auto") -->
<!-- l_p[[4]] <- ggplot(df_resultados,aes(x=p,y=log(Stotal))) + -->
<!--   geom_point() + -->
<!--   geom_smooth(method="auto") -->
<!-- do.call("grid.arrange",c(l_p,ncol=2)) -->
<!-- ``` -->

<!-- __Figura 4.2__ U ~ d (~SiteCode) -->

<!-- ```{r figura 42 U d Site,fig.height=45,fig.width=8} -->
<!-- df_plot <- df_resultados %>%  -->
<!--   filter(MN=="EE") %>%  -->
<!--   mutate(title = paste0(SiteCode," p=",round(p,3))) %>% arrange(p) -->
<!-- df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title)) -->
<!-- df_plot %>% ggplot(aes(x=d,y=U_med)) + -->
<!--   geom_point(alpha=0.3) + theme_light() + -->
<!--   facet_wrap(~title,ncol=4,scales="free") -->
<!-- ``` -->


<!-- ## GAMM -->

<!-- ```{r selecao de variavel de dispersao modelo cheio GAMM(U),eval=FALSE} -->
<!-- ctrl <- list(nthreads=3) #número de cores para paralelizar -->
<!-- l_md.U <- vector("list",length = 20) -->
<!-- names(l_md.U) <- c("d/L id normal","d/L log normal", "d/L inverse normal", "d/L log gamma", "d/L inverse gamma", -->
<!--                    "1-k id normal","1-k log normal", "1-k inverse normal", "1-k log gamma", "1-k inverse gamma", -->
<!--                    "k id normal","k log normal", "k inverse normal", "k log gamma", "k inverse gamma", -->
<!--                    "d id normal","d log normal", "d inverse normal", "d log gamma", "d inverse gamma") -->
<!-- # d/L -->
<!-- l_md.U[[1]] <- gam(U_med ~ s(d_Lplot.z) + s(p.z) + ti(d_Lplot.z,p.z) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family="gaussian", -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[2]] <- gam(U_med ~ s(d_Lplot.z) + s(p.z) + ti(d_Lplot.z,p.z) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=gaussian(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[3]] <- gam(U_med ~ s(d_Lplot.z) + s(p.z) + ti(d_Lplot.z,p.z) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=gaussian(link = "inverse"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[4]] <- gam(U_med ~ s(d_Lplot.z) + s(p.z) + ti(d_Lplot.z,p.z) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[5]] <- gam(U_med ~ s(d_Lplot.z) + s(p.z) + ti(d_Lplot.z,p.z) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "inverse"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- # k_1 -->
<!-- l_md.U[[6]] <- gam(U_med ~ s(k_1.z) + s(p.z) + ti(k_1.z,p.z) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family="gaussian", -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[7]] <- gam(U_med ~ s(k_1.z) + s(p.z) + ti(k_1.z,p.z) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=gaussian(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[8]] <- gam(U_med ~ s(k_1.z) + s(p.z) + ti(k_1.z,p.z) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=gaussian(link = "inverse"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[9]] <- gam(U_med ~ s(k_1.z) + s(p.z) + ti(k_1.z,p.z) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[10]] <- gam(U_med ~ s(k_1.z) + s(p.z) + ti(k_1.z,p.z) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "inverse"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- # k.f -->
<!-- l_md.U[[11]] <- gam(U_med ~ s(p.z,k,bs="fs") + k + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family="gaussian", -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[12]] <- gam(U_med ~ s(p.z,k,bs="fs") + k + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=gaussian(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[13]] <- gam(U_med ~ s(p.z,k,bs="fs") + k + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=gaussian(link = "inverse"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[14]] <- gam(U_med ~ s(p.z,k,bs="fs") + k + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[15]] <- gam(U_med ~ s(p.z,k,bs="fs") + k + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "inverse"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- # d -->
<!-- l_md.U[[16]] <- gam(U_med ~ s(d.z) + s(p.z) + ti(d.z,p.z) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family="gaussian", -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[17]] <- gam(U_med ~ s(d.z) + s(p.z) + ti(d.z,p.z) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=gaussian(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[18]] <- gam(U_med ~ s(d.z) + s(p.z) + ti(d.z,p.z) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=gaussian(link = "inverse"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[19]] <- gam(U_med ~ s(d.z) + s(p.z) + ti(d.z,p.z) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[20]] <- gam(U_med ~ s(d.z) + s(p.z) + ti(d.z,p.z) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "inverse"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- AICctab(l_md.U,weights=TRUE) -->
<!-- l_md_U_selVar_disp_1Site <- l_md.U  -->
<!-- save(l_md_U_selVar_disp_1Site,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_U_selVar_disp_1Site.Rdata") -->


<!-- ############### exemplo de código para estrutura aleatoria mais complexa -->
<!-- # l_md[[3]] <- gam(U_med ~ s(d.z,bs="tp") + s(p.z,bs="tp") + ti(d.z,p.z,ns=c("tp","tp")) + -->
<!-- #                   s(log_Stotal,bs="tp") + -->
<!-- #                   s(d.z,by=SiteCode,bs="tp",m=1) -->
<!-- #                   s(SiteCode,bs="re"), -->
<!-- #                 family=gaussian(link = "log"), -->
<!-- #                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- ``` -->


<!-- ### Modelo Cheio: comparação estrutura aleatória -->

<!-- Variável de dispersão: d (como para n_nRef) -->

<!-- i) Na escala log a variável parece ser simetrica, então vou comparar a distribuição normal e gamma;     -->
<!-- ii) É possível apresentar 3 estruturas: a) 1|Site; b) d|Site, penalizacao comum; c) d|Site, penalizacao por Site [que não vou incluir a priori pelo custo computacional]   -->
<!-- iii) pelo menos 2 smoother type (tp,cr)   -->


<!-- ```{r gamm cheio U_med,eval=FALSE} -->
<!-- ctrl <- list(nthreads=3) -->
<!-- l_md <- vector("list",8) -->
<!-- names(l_md) <- c("tp normal 1|Site","tp normal d|Site","cr normal 1|Site","cr normal d|Site", -->
<!--                  "tp gamma 1|Site","tp gamma d|Site","cr gamma 1|Site","cr gamma d|Site") -->
<!-- ### Gaussian -->
<!-- l_md[[1]] <- gam(U_med ~ s(d.z,bs="tp") + s(p.z,bs="tp") + ti(d.z,p.z,bs=c("tp","tp")) + -->
<!--                   s(log_Stotal,bs="tp") + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=gaussian(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md[[2]] <- gam(U_med ~ s(d.z,bs="tp") + s(p.z,bs="tp") + ti(d.z,p.z,bs=c("tp","tp")) + -->
<!--                   s(log_Stotal,bs="tp") + -->
<!--                   s(d.z,SiteCode,bs="fs",m=1,xt=list(bs="tp")), -->
<!--                 family=gaussian(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md[[3]] <- gam(U_med ~ s(d.z,bs="cr") + s(p.z,bs="cr") + ti(d.z,p.z,bs=c("cr","cr")) + -->
<!--                   s(log_Stotal,bs="cr") + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=gaussian(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md[[4]] <- gam(U_med ~ s(d.z,bs="cr") + s(p.z,bs="cr") + ti(d.z,p.z,bs=c("cr","cr")) + -->
<!--                   s(log_Stotal,bs="cr") + -->
<!--                   s(d.z,SiteCode,bs="fs",m=1,xt=list(bs="cr")), -->
<!--                 family=gaussian(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- ### Gamma -->
<!-- l_md[[5]] <- gam(U_med ~ s(d.z,bs="tp") + s(p.z,bs="tp") + ti(d.z,p.z,bs=c("tp","tp")) + -->
<!--                   s(log_Stotal,bs="tp") + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md[[6]] <- gam(U_med ~ s(d.z,bs="tp") + s(p.z,bs="tp") + ti(d.z,p.z,bs=c("tp","tp")) + -->
<!--                   s(log_Stotal,bs="tp") + -->
<!--                   s(d.z,SiteCode,bs="fs",m=1,xt=list(bs="tp")), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md[[7]] <- gam(U_med ~ s(d.z,bs="cr") + s(p.z,bs="cr") + ti(d.z,p.z,bs=c("cr","cr")) + -->
<!--                   s(log_Stotal,bs="cr") + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md[[8]] <- gam(U_med ~ s(d.z,bs="cr") + s(p.z,bs="cr") + ti(d.z,p.z,bs=c("cr","cr")) + -->
<!--                   s(log_Stotal,bs="cr") + -->
<!--                   s(d.z,SiteCode,bs="fs",m=1,xt=list(bs="cr")), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md_U_gammCheio <- l_md -->
<!-- AICctab(l_md) -->
<!-- save(l_md_U_gammCheio,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_U_gammCheio.Rdata") -->
<!-- ``` -->


<!-- __Figura 4.3__ Graf Diag Gamm cheio mais plausível -->

<!-- ```{r gamm cheio U_med graf diag}  -->
<!-- load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_U_gammCheio.Rdata") -->
<!-- gratia::appraise(l_md_U_gammCheio[["cr gamma d|Site"]]) -->
<!-- ``` -->




<!-- # 4 Comparação n_nRef e diff_S -->

<!-- __Figura 3.1__ Observado (pontos) e predito (linhas) para diffS e n_nRef (segunda linha no facet) em função de d*MN, por sítio de amostragem (primeira linha no facet). -->

<!-- ```{r comparacao n_nRef e diff_S,fig.height=65,fig.width=11} -->
<!-- # dados -->
<!-- ## MN=="EI" -->
<!-- ### gamm diffS -->
<!-- load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/md_diff_S_EI__GAMM_update.Rdata") -->
<!-- df_EI <- cbind(filter(df_resultados,MN=="EI"), -->
<!--                  predict.gam(md_gam.diff_S.EI__update,type="response",se.fit=TRUE)) %>%  -->
<!--   mutate(fit_diffS0 = fit + min(df_resultados$diff_S0) - 0.01) -->
<!-- ### glmm nRef -->
<!-- load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__MuMIn.Rdata") -->
<!-- df_EI$Pr_nRef <- predict(mdAvg_nRefEI__MuMIn,type="response")*100 -->
<!-- ## MN=="EI" -->
<!-- ### gamm diffS -->
<!-- md_diffS_EE <- lm(diff_S0 ~ 1,data=filter(df_resultados,MN=="EE")) -->
<!-- df_EE <- filter(df_resultados,MN=="EE") %>%  -->
<!--   mutate(fit_diffS0 = coef(md_diffS_EE)) -->
<!-- ### glmm nRef -->
<!-- load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__MuMIn.Rdata") -->
<!-- df_EE$Pr_nRef <- predict(mdAvg_nRefEE__MuMIn,type="response")*100 -->
<!-- ## conjunto completo -->
<!-- df_plot <- rbind.fill(df_EE,df_EI) %>% -->
<!--   mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p) -->
<!-- df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title)) -->
<!-- df_plot <- rbind.fill( -->
<!--   select(df_plot,title,d,MN,n_nRef,Pr_nRef) %>%  -->
<!--     mutate(response_class = "nRef") %>%  -->
<!--     rename(response_obs=n_nRef,fit_value=Pr_nRef), -->
<!--   select(df_plot,title,d,MN,diff_S0,fit_diffS0) %>%  -->
<!--     mutate(response_class = "diff_S") %>%  -->
<!--     rename(response_obs=diff_S0,fit_value=fit_diffS0) -->
<!-- ) -->
<!-- # gráficos -->
<!-- df_plot %>% #filter(title %in% unique(df_plot$title)[1:10]) %>%  -->
<!--   ggplot(aes(x=d,y=response_obs,group=MN)) + -->
<!--   geom_point(aes(color=MN),alpha=0.3) + -->
<!--   geom_line(aes(y=fit_value,color=MN),alpha=0.3) + -->
<!--   scale_color_manual(values=c("#FF0000", "#000000")) + -->
<!--   facet_wrap(~title+response_class,ncol=6,scales="free") + labs(y="") + -->
<!--   theme_light() + theme(legend.position="top") -->
<!-- ``` -->




<!-- __Figura 4.2__ |diffS| ~ n_nRef * k, subset=MNEI -->

<!-- ```{r figura 32,fig.height=10,fig.width=7} -->
<!-- # dados  ,fig.height=10 -->
<!-- df_plot <- df_resultados %>% filter(MN=="EI") %>%  -->
<!--   mutate(modulo_diffS = abs(diff_S0)) -->
<!-- # graficos -->
<!-- l_p <- list() -->
<!-- l_p[[1]] <- ggplot(df_plot,aes(x=d,y=modulo_diffS)) +  -->
<!--   # geom_boxplot(col="blue") + -->
<!--   # geom_jitter(alpha=0.3) -->
<!--   geom_point(alpha=0.3) + geom_smooth(method = "auto",se=FALSE,color="blue") -->
<!-- l_p[[2]] <- ggplot(df_plot,aes(x=d,y=n_nRef)) +  -->
<!--   # geom_boxplot(col="blue") + -->
<!--   # geom_jitter(alpha=0.3) -->
<!--   geom_point(alpha=0.3) + geom_smooth(method = "auto",se=FALSE,color="blue") -->
<!-- l_p[[3]] <- df_plot %>%  -->
<!--   mutate(logito_nRef = logit(n_nRef/100)) %>%  -->
<!--   ggplot(aes(x=log(modulo_diffS),y=logito_nRef)) +  -->
<!--   geom_smooth(method="lm",se=FALSE) + -->
<!--   geom_point(alpha=0.3) + labs(title="logit( n_nRef/100 ) ~ log( |diffS| ) * k", -->
<!--                                y="logit( n_nRef/100 )",x="log( |diffS| )") + -->
<!--   facet_wrap(~k,ncol=4,scales="free") -->
<!-- # do.call("grid.arrange",c(l_p,ncol=1)) -->
<!-- grid.arrange(l_p[[1]],l_p[[2]],l_p[[3]], -->
<!--              layout_matrix=rbind(c(1,2), -->
<!--                                  c(3,3), -->
<!--                                  c(3,3)) ) -->
<!-- ``` -->



<!-- __Figura 3.3__ n_nRef ~ |diffS| (~SiteCode), subset=MNEI -->

<!-- ```{r figura 33,fig.width=8, fig.height=30} -->
<!-- # dados -->
<!-- df_plot1  <-  left_join(x=df_plot, -->
<!--                        y=ddply(df_plot,"SiteCode",summarise,max_mod_diffS=max(modulo_diffS)), -->
<!--                        by="SiteCode") %>%  -->
<!--   arrange(max_mod_diffS) %>% -->
<!--   mutate(title=paste0(SiteCode," max(|diffS|)=",round(max_mod_diffS,2) ) ) -->
<!-- df_plot1$title <- factor(df_plot1$title,levels = unique(df_plot1$title)) -->
<!-- # graficos -->
<!-- df_plot1 %>% ggplot(aes(x=log(modulo_diffS),y=n_nRef)) + -->
<!--   geom_point(alpha=0.3) + -->
<!--   ylim(0,100) + theme_light() + labs(title="n_nRef ~ (log( |diffS| ) | SiteCode)") +  -->
<!--   facet_wrap(~title,ncol=4,scales="free_y") -->
<!-- ``` -->


<!-- ## Comparação funções para o teste KS -->


<!-- ```{r dados para auditoria , eval=FALSE} -->
<!-- # dados brutos -->
<!-- df_auditoria <- read.csv("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/df_raster_e_SAD_atualizados.csv", -->
<!--                          header = TRUE,as.is = TRUE) -->
<!-- df_SAD.replicas <- read.csv("/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/resultados/df_replicas.csv", -->
<!--                             header = TRUE,as.is = TRUE) -->
<!-- df_SAD_e_paisagem <- left_join(x=df_SAD.replicas,y=select(df_auditoria,-c(SAD_obs.name,SiteCode)),by=c("ordem","refID")) -->
<!-- # rank máximo -->
<!-- registerDoMC(3) -->
<!-- df_SAD_e_paisagem <- left_join(x=df_SAD_e_paisagem, -->
<!--                                y=ddply(df_SAD_e_paisagem,c("SiteCode","k","MN"),function(X) max(c(X$S_SAD.predita,X$S_SAD.obs)),.parallel = TRUE), -->
<!--                                by=c("SiteCode","k","MN")) -->
<!-- df_SAD_e_paisagem %<>% rename(max_rank=V1) -->
<!-- df_SAD_e_paisagem$SAD_MN.name <- gsub("./SADs_preditas/","/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/SADs_preditas/",df_SAD_e_paisagem$SAD_MN.name) -->
<!-- # dados de congruência -->
<!-- # level_k <- unique(as.character(df_SAD_e_paisagem$k)) -->
<!-- # levels(df_SAD_e_paisagem$k)[19] <- "0.1" -->
<!-- df_SAD_e_paisagem$k <- as.character(df_SAD_e_paisagem$k) -->
<!-- df_SAD_e_paisagem$k[df_SAD_e_paisagem$k=="0.0999999999999999"] <- 0.1 -->
<!-- df_SAD_e_paisagem$k <- factor(df_SAD_e_paisagem$k,levels=unique(df_SAD_e_paisagem$k)[c(19,20,18:1)]) -->
<!-- df_SAD_e_paisagem$SiteCode <- factor(df_SAD_e_paisagem$SiteCode,levels=levels(df_resultados$SiteCode))  -->
<!-- df_SAD_e_paisagem$MN <- factor(df_SAD_e_paisagem$MN,levels=levels(df_resultados$MN))  -->
<!-- df_SAD_e_paisagem <- left_join(x=df_SAD_e_paisagem, -->
<!--                                y=select(df_resultados,SiteCode,k,MN,n_nRef,modulo_diffS), -->
<!--                                by=c("SiteCode","k","MN")) -->
<!-- # auditoria valores de congruência -->
<!-- registerDoMC(3) -->
<!-- df_auditoria <- df_SAD_e_paisagem %>%   -->
<!--   mutate(diffS0 = (S_SAD.predita-S_SAD.obs)/S_SAD.obs, -->
<!--          mod_diffS.aud = abs(diffS0)) %>%  -->
<!--   inner_join(x=ddply(.,c("SiteCode","k","MN"), -->
<!--                      summarise,  -->
<!--                      KS.D_mean = mean(KS.D), KS.D_sd = sd(KS.D),KS.p_mean = mean(KS.p), KS.p_sd = sd(KS.p), -->
<!--                      S_MNmean = mean(S_SAD.predita),S_MNsd = sd(S_SAD.predita),S_obs=head(S_SAD.obs,1), -->
<!--                       mod_diffSmean=mean(mod_diffS.aud),mod_diffSsd=sd(mod_diffS.aud), diffS0mean=mean(diffS0),diffS0sd=sd(diffS0), -->
<!--                      .parallel = TRUE), -->
<!--              y=ddply(.,c("SiteCode","k","MN"), -->
<!--                      function(x) nrow(x[x$KS.p >= 0.05,]), -->
<!--                      .parallel = TRUE), -->
<!--              by=c("SiteCode","k","MN")) %>%  -->
<!--   rename(nRef = V1) -->
<!-- df_auditoria <- left_join(x=df_SAD_e_paisagem, -->
<!--                           y=df_auditoria, -->
<!--                           by=c("SiteCode","k","MN")) %>%  -->
<!--   left_join(x=., -->
<!--             y=distinct(select(df_resultados,SiteCode,p,k,d)), -->
<!--             by=c("SiteCode","k")) %>%  -->
<!--   mutate(string_main=paste0("k=",k," d=",round(d,3),"\n nRef=",n_nRef,"; |diffS|=",round(mod_diffSmean,3),"; rankMax=",max_rank), -->
<!--          string_mtext=paste0(SiteCode," MN==",MN," p=",round(p,3)) ) -->
<!-- #  -->
<!-- levels_k <- df_auditoria$k %>% unique %>% as.numeric %>% sort() %>% as.character() -->
<!-- df_auditoria$k <- factor(df_auditoria$k,levels=levels_k[20:1]) -->
<!-- ``` -->


<!-- ```{r teste KS bootstrap,eval=FALSE} -->
<!-- # Dados -->
<!-- df_testeKS <- df_auditoria %>%  -->
<!--   select(SAD_obs.name,SAD_MN.name,MN,k,rep,ordem,refID,SiteCode,txt.name,S_obs,p,d) %>% -->
<!--   group_by(SAD_obs.name) %>% nest -->
<!-- df_testeKS$resultados <- vector("list",length = nrow(df_testeKS)) -->
<!-- # rotina para a função -->
<!-- registerDoMC(3) -->
<!-- for(row_label in 1:nrow(df_testeKS)){ -->
<!--   # i <- 1 -->
<!--   df_ <- df_testeKS[row_label,] -->
<!--   v_SAD.obs <- read.csv(df_$SAD_obs.name,header = TRUE,as.is = TRUE) %>%  -->
<!--     filter(species.correct != "Mortas") %>%  -->
<!--     .$N %>% sort() -->
<!--   df_predicao <- as.data.frame(df_$data[[1]]) -->
<!--   f_KSeS <- function(v_obs = v_SAD.obs,path_MN){ -->
<!--     v_SAD.MN <- read.csv(file=path_MN,header = TRUE,as.is = TRUE)$SAD_predita -->
<!--     teste <- ks_test(a=v_SAD.obs,b = v_SAD.MN,nboots = 3000)   -->
<!--     a <- data.frame(D_KSboot=teste[1],p.valor_KSboot=teste[2]) -->
<!--     a$S_SAD.predita <- length(v_SAD.predita) -->
<!--     a$S_SAD.obs <- length(v_SAD.obs)  -->
<!--     return(a) -->
<!--    } -->
<!--   df_testeKS$resultados[[row_label]] <- adply(df_predicao,1, -->
<!--                                               function(X) f_testeParallel(path_MN = X$SAD_MN.name), -->
<!--                                               .parallel = TRUE) -->
<!-- } -->

<!-- df_replicas <- df_testeKS %>% select(-data) %>% unnest(cols = c(resultados)) %>% as.data.frame() -->
<!-- write.csv(df_replicas,file = "~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/resultados/df_replicas__2samples.csv",row.names = FALSE) -->
<!-- ``` -->



<!-- __Figura 3.4__ Comparação testes KS: pressupondo distribuição contínua (stats::ks.test) e por bootstrap (twosamples::ks_test)   -->

<!-- ```{r figura 34 nRef KSboot, cache=TRUE} -->
<!-- df_replicasBoot <- read.csv("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/resultados/df_replicas__2samples.csv", -->
<!--                         header = TRUE,as.is = TRUE) -->
<!-- registerDoMC(3) -->
<!-- df_nRef.KSboot <- df_replicasBoot %>% ddply(c("SiteCode","k","MN"),summarise, -->
<!--                                            D.boot_mean = mean(D_KSboot),D.boot_sd = sd(D_KSboot), -->
<!--                                            p.valor.boot_mean = mean(p.valor_KSboot),p.valor.boot_sd = sd(p.valor_KSboot), -->
<!--                                            n_nRef_boot=sum(p.valor_KSboot>=0.05), -->
<!--                                            .parallel = TRUE) -->
<!-- # comparação -->
<!-- level_k <- unique(as.character(df_nRef.KSboot$k)) -->
<!-- df_nRef.KSboot$k <- factor(as.character(df_nRef.KSboot$k),levels = level_k[20:1]) -->
<!-- # levels(df_nRef.KSboot$k)[19] <- "0.1" -->
<!-- df_ad <- inner_join(x=df_resultados, -->
<!--                     y=df_nRef.KSboot, -->
<!--                     by=c("SiteCode","k","MN")) -->
<!-- # graficos diagnostico -->
<!-- l_p <- list() -->
<!-- l_p[[1]] <- df_ad %>% ggplot(aes(x=D_mean,y=D.boot_mean)) +  -->
<!--   geom_point() +  -->
<!--   labs(x="dist. cont.",y="bootstrap", title="Média Estatística D") -->
<!-- l_p[[2]] <- df_ad %>% ggplot(aes(x=p.value_mean,y=p.valor.boot_mean)) +  -->
<!--   geom_point() +  -->
<!--   labs(x="dist. cont.",y="bootstrap", title="Média p-valor") -->
<!-- l_p[[3]] <- df_ad %>% ggplot(aes(x=sqrt(D_var),y=D.boot_sd)) +  -->
<!--   geom_point() +  -->
<!--   labs(x="dist. cont.",y="bootstrap", title="sd Estatística D") -->
<!-- l_p[[4]] <- df_ad %>% ggplot(aes(x=sqrt(p.value_var),y=p.valor.boot_sd)) +  -->
<!--   geom_point() +  -->
<!--   labs(x="dist. cont.",y="bootstrap", title="sd p-valor") -->
<!-- do.call("grid.arrange",c(l_p,ncol=2)) -->
<!-- ``` -->


<!-- __figura 3.5__ número de SADs não refutadas: ks.test X ks_test   -->

<!-- ```{r figura 35 nRef ks.test e ks_test} -->
<!-- df_ad %>% ggplot(aes(x=n_nRef,y=n_nRef_boot,col=MN)) +  -->
<!--   geom_abline(slope = 1,intercept = 0,col="blue") + -->
<!--   geom_point(alpha=0.3) +  -->
<!--   scale_color_manual(values=c("#FF0000", "#000000")) + -->
<!--   facet_wrap(~k,ncol=4) -->
<!-- ``` -->


<!-- ## Visualização das SADs preditas e observadas -->

<!-- ```{r painel de SADs, eval=FALSE} -->
<!-- ### dados -->
<!-- # dados brutos -->
<!-- df_auditoria <- read.csv("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/df_raster_e_SAD_atualizados.csv", -->
<!--                          header = TRUE,as.is = TRUE) -->
<!-- df_SAD.replicas <- read.csv("/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/resultados/df_replicas.csv", -->
<!--                             header = TRUE,as.is = TRUE) -->
<!-- df_SAD_e_paisagem <- left_join(x=df_SAD.replicas,y=select(df_auditoria,-c(SAD_obs.name,SiteCode)),by=c("ordem","refID")) -->
<!-- # rank máximo -->
<!-- registerDoMC(3) -->
<!-- df_SAD_e_paisagem <- left_join(x=df_SAD_e_paisagem, -->
<!--                                y=ddply(df_SAD_e_paisagem,c("SiteCode","k","MN"),function(X) max(c(X$S_SAD.predita,X$S_SAD.obs)),.parallel = TRUE), -->
<!--                                by=c("SiteCode","k","MN")) -->
<!-- df_SAD_e_paisagem %<>% rename(max_rank=V1) -->
<!-- df_SAD_e_paisagem$SAD_MN.name <- gsub("./SADs_preditas/","/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/SADs_preditas/",df_SAD_e_paisagem$SAD_MN.name) -->
<!-- ##  -->
<!-- df_SAD_e_paisagem$SiteCode <- factor(df_SAD_e_paisagem$SiteCode)  -->
<!-- df_SAD_e_paisagem$MN <- factor(df_SAD_e_paisagem$MN) -->
<!-- levels_k <- unique(df_SAD_e_paisagem$k) %>% sort %>% as.character() -->
<!-- df_SAD_e_paisagem$k <- factor(df_SAD_e_paisagem$k,levels = levels_k[20:1]) -->
<!-- levels(df_SAD_e_paisagem$k)[19] <- "0.1" -->
<!-- # -->
<!-- df_ad$SiteCode <- factor(df_ad$SiteCode) -->
<!-- df_ad$MN <- factor(df_ad$MN) -->
<!-- df_auditoria <- left_join(x=df_SAD_e_paisagem, -->
<!--                           y=select(df_ad,SiteCode,MN,k,d,p,n_nRef,n_nRef_boot), -->
<!--                           by=c("SiteCode","MN","k")) -->
<!-- df_auditoria %<>% -->
<!--   mutate(string_main=paste0("k=",k," d=",round(d,3),"\n ks.test::nRef=",n_nRef," ks_test::nRef=",n_nRef_boot), -->
<!--          string_mtext=paste0(SiteCode," MN==",MN," p=",round(p,3)) ) -->
<!-- ### graficos -->
<!-- for(s in 1:length(levels(df_auditoria$SiteCode))){ -->
<!--   X <- df_auditoria %>% filter(SiteCode == levels(df_auditoria$SiteCode)[s]) -->
<!--   v_SADobs <- read.csv(X[1,"SAD_obs.name"],header = TRUE)[,"N"] -->
<!--   # MNEE -->
<!--   df_ <- X %>% filter(MN=="EE") -->
<!--   png(paste0("/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/figuras/", -->
<!--              levels(df_auditoria$SiteCode)[s],"_EE_SADs.png"), -->
<!--       width = 980, height = 600) -->
<!--   par(mfrow=c(4,5)) -->
<!--   for(K in 1:length(levels(df_$k))){ -->
<!--     df_k <- filter(df_,k==levels(df_$k)[K]) -->
<!--     plot(rad(v_SADobs),main=head(df_k$string_main,1),cex=0.5, -->
<!--          xlim=c(1,head(df_$max_rank,1))) -->
<!--     for(p in 1:nrow(df_k)){ -->
<!--       v_SAD_MN <- read.table(df_k[p,"SAD_MN.name"],header = TRUE,as.is = TRUE)$SAD_predita -->
<!--       lines(rad(v_SAD_MN),type="l",col=rgb(0.25, 0.25, 0.25, 0.25)) -->
<!--     } -->
<!--     lines(rad(v_SADobs),pch = 19, col="red",cex=0.5,bg="black",type="b", -->
<!--            main=head(df_k$string_main,1)) -->
<!--   } -->
<!--   dev.off() -->
<!--   # MNEI -->
<!--   df_ <- X %>% filter(MN=="EI") -->
<!--   png(paste0("/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/figuras/", -->
<!--              levels(df_auditoria$SiteCode)[s],"_EI_SADs.png"), -->
<!--       width = 980, height = 600) -->
<!--   par(mfrow=c(4,5)) -->
<!--   for(K in 1:length(levels(df_$k))){ -->
<!--     df_k <- filter(df_,k==levels(df_$k)[K]) -->
<!--     plot(rad(v_SADobs),main=head(df_k$string_main,1),cex=0.5, -->
<!--          xlim=c(1,head(df_$max_rank,1))) -->
<!--     for(p in 1:nrow(df_k)){ -->
<!--       v_SAD_MN <- read.table(df_k[p,"SAD_MN.name"],header = TRUE,as.is = TRUE)$SAD_predita -->
<!--       lines(rad(v_SAD_MN),type="l",col=rgb(0.25, 0.25, 0.25, 0.25)) -->
<!--     } -->
<!--     lines(rad(v_SADobs),pch = 19, col="red",cex=0.5,type="b", -->
<!--            main=head(df_k$string_main,1)) -->
<!--   } -->
<!--   dev.off() -->
<!-- } -->
<!-- ``` -->




<!-- Inspeção individual das SADs -->




<!-- __Estratégia__   -->

<!-- i) estrutura do tipo:   -->

<!-- cbind(n_nRef,100-n_nRef) ~ log(modulo_diffS) * d + ( log(modulo_diffS) * d | SiteCode)   -->

<!-- ii) expectativa:   -->

<!-- a) esperavamos que se o teste é adequado então deve existir um erro de estimativa da riqueza máximo no qual a probabilidade de não se refutar uma SAD se torna muito diminuta.   -->
<!-- b) e uma vez que não é suficiente apresentar boa estimativa da riqueza para apresentar boa congruência, então esperava que a nuvem de pontos pudesse ser aproximada por um triangulo retangulo com angulo reto na origem.  -->

<!-- ```{r nRef por modulo_diffS md cheio,cache=TRUE} -->
<!-- # para usar a escala log: -->
<!-- l_md <- vector("list",5) -->
<!-- names(l_md) <- c("log(modulo_diffS) * d.z | SiteCode", -->
<!--                  "log(modulo_diffS) + d.z | SiteCode", -->
<!--                  "log(modulo_diffS) | SiteCode", -->
<!--                  "d.z | SiteCode", -->
<!--                  "1 | SiteCode") -->
<!-- l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ log_modulo_diffS.z * (d.z + I(d.z^2)) + ( log_modulo_diffS.z * (d.z + I(d.z^2)) | SiteCode), -->
<!--                    family = "binomial", data=df_resultados.EI, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ log_modulo_diffS.z * (d.z + I(d.z^2)) + ( log_modulo_diffS.z + (d.z + I(d.z^2)) | SiteCode), -->
<!--                    family = "binomial", data=df_resultados.EI, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~ log_modulo_diffS.z * (d.z + I(d.z^2)) + ( log_modulo_diffS.z| SiteCode), -->
<!--                    family = "binomial", data=df_resultados.EI, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[4]] <- glmer(cbind(n_nRef,100-n_nRef) ~ log_modulo_diffS.z * (d.z + I(d.z^2)) + ( (d.z + I(d.z^2)) | SiteCode), -->
<!--                    family = "binomial", data=df_resultados.EI, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- l_md[[5]] <- glmer(cbind(n_nRef,100-n_nRef) ~ log_modulo_diffS.z * (d.z + I(d.z^2)) + ( 1 | SiteCode), -->
<!--                    family = "binomial", data=df_resultados.EI, -->
<!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) -->
<!-- AICctab(l_md,weights=TRUE) -->
<!-- ``` -->

<!-- ```{r figura 34 nRef por modulo_diffS diag,fig.height=25,fig.width=8} -->
<!-- p_plot <- simulateResiduals(l_md[["log(modulo_diffS) * d.z | SiteCode"]],n = 1000) -->
<!-- # plot(p_plot) -->
<!-- df_plot <- df_resultados.EI %>%  -->
<!--   select(SiteCode,n_nRef,log_modulo_diffS.z,d.z) %>%  -->
<!--   mutate(quantile_res = p_plot$scaledResiduals, -->
<!--          pearson_res = resid(l_md[["log(modulo_diffS) * d.z | SiteCode"]],type="pearson"), -->
<!--          predict_ = predict(l_md[["log(modulo_diffS) * d.z | SiteCode"]])) -->
<!-- df_plot %>%  -->
<!--   ggplot(aes(x=predict_,y = pearson_res)) + -->
<!--     geom_abline(intercept = 0,slope = 0,color="red") + -->
<!--     geom_smooth(method = "auto",color="blue",se=FALSE) + -->
<!--     geom_point(alpha=0.4) + -->
<!--     facet_wrap(~SiteCode,ncol=4,scales="free") -->
<!-- # df_resultados %>% filter(SiteCode == "MGlavr3") %>% summary -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # lme4::(l_md[["log(modulo_diffS) * d.z | SiteCode"]]) -->
<!-- ``` -->

<!-- # 5 Determinação da escala espacial da paisagem local -->

<!-- __Figura 5.1_ log(S_obs) ~ p + offset(Ntotal)   -->

<!-- ```{r df_se figura 51,eval=TRUE} -->
<!-- # dados -->
<!-- df_se <- read.csv("/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/df_ScaleEffect.csv",header = TRUE,as.is = TRUE) -->
<!-- df_se$raio_km <- factor(df_se$raio_km,levels = unique(df_se$raio_km)) -->
<!-- # graficos exploratórios -->
<!-- # l_p <- list() -->
<!-- l_p[[1]] <- df_se %>% ggplot(aes(x=p,y=S_obs)) + -->
<!--   geom_point(alpha=0.3,aes(size=Ntotal)) + -->
<!--   facet_wrap(~raio_km,ncol=3) + theme(legend.position = "bottom") -->
<!-- # l_p[[1]] -->
<!-- # l_p[[2]] <- df_se %>% select(Ntotal) %>% distinct %>% ggplot(aes(x="",y=Ntotal)) +  -->
<!-- #   geom_boxplot() +  -->
<!-- #   geom_jitter() +  -->
<!-- #   labs(x="") -->
<!-- # l_p[[3]] <- df_se %>% select(S_obs) %>% distinct %>% ggplot(aes(x="",y=S_obs)) +  -->
<!-- #   geom_boxplot() +  -->
<!-- #   geom_jitter() +  -->
<!-- #   labs(x="") -->
<!-- ``` -->

<!-- A média e variância de S_obs não apresenta valores próximos `r mean(df_se$S_obs)/var(df_se$S_obs)`, mostrando que os dados apresentam over-dispersion. Assim irei utilizar a distribuição binomial negativa com Ntotal como offset; como preditoras utilizo p e p^2: -->

<!-- ```{r ajuste de modelos aos dados,echo=TRUE} -->
<!-- library(MASS) -->
<!-- f_glm.nb <- function(data_){ -->
<!--   md_ <- glm.nb(S_obs ~ p + I(p^2) + offset(log(Ntotal)), data = data_) -->
<!-- } -->
<!-- registerDoMC(2) -->
<!-- l_md <- dlply(df_se,"raio_km",f_glm.nb,.parallel = TRUE) -->
<!-- # names(l_md) <- paste0("raio = ",levels(df_se$raio_km),"km") -->
<!-- df_averageSE <- print(AICctab(l_md,weights=TRUE)) %>%  -->
<!--   as.data.frame() -->
<!-- ``` -->

<!-- Explorei paisagens com raios que vão de 0.3 km até 12.0 km variando por 0.1 km. Para determinar qual a melhor escala vou utilizar a média dos raios ponderada pelo peso de evidência: -->

<!-- ```{r} -->
<!-- df_averageSE$raio_paisagem <- row.names(df_averageSE) %>% as.numeric() -->
<!-- df_averageSE$weight <- as.numeric(as.character(df_averageSE$weight)) -->
<!-- df_averageSE$dAICc <- as.numeric(as.character(df_averageSE$dAICc)) -->
<!-- df_ <- df_averageSE %>% filter(dAICc<=2) -->
<!-- raio_medio__delta2 <- weighted.mean(x = df_$raio_paisagem,w = df_$weight) -->
<!-- raio_medio1__total <- weighted.mean(x = df_averageSE$raio_paisagem,w = df_averageSE$weight) -->
<!-- ``` -->



  