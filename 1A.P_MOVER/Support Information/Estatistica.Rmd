---
title: "Apêndice 2: Descrição Estatística"
author: "Mori, Danilo"
date: "31/10/2019"
output: 
  html_document:
    toc: true
    toc_depth: 5
editor_options: 
  chunk_output_type: inline
---

<style>
body {
text-align: justify}
</style>


```{r setup, include=TRUE,echo=FALSE}
knitr::opts_chunk$set(echo = TRUE, tidy = FALSE, include = TRUE, warning = FALSE,cache = TRUE,message=FALSE,eval=TRUE)
# setwd("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/")
knitr::opts_knit$set(root.dir = "/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/simulacao_codigos_e_resultados")
```

```{r pacotes,eval=TRUE,echo=TRUE,warning=FALSE,message=FALSE}
library(parallel)
library(doMC)
library(DHARMa)
library(broom.mixed)
library(gratia)
library(tidymv)
library(MuMIn)
library(mgcv)
library(bbmle)
library(lme4)
library(AICcmodavg)
library(merTools)
library(magrittr)
library(ggplotify)
library(gridExtra)
library(directlabels)
library(ggplot2); theme_set(theme_classic())
library(metR)
library(tidyr)
library(purrr)
library(plyr)
library(dplyr)
```

```{r dados,message=FALSE}
### dados ###
# leitura
df_resultados <- read.csv(file="/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/simulacao_codigos_e_resultados/resultados/df_resultados.csv",
                            header = TRUE,as.is=FALSE)[,1:13]
# padronização
level_k <- as.character(unique(sort(as.numeric(df_resultados$k),decreasing = TRUE)))
df_resultados$k <- factor(df_resultados$k,levels = level_k)
levels(df_resultados$k)[19] <- "0.1"
# z score
f_z <- function(x){
  m <- base::mean(x,na.rm=FALSE)
  sd <- sd(x,na.rm=FALSE)
  output <- (x-m)/sd
  return(output)
} 
# names(df_resultados)
# str(df_resultados)
df_resultados %<>% mutate(diffS_gamma = diffS_mean + min(diffS_mean)*(-1) + 0.01,
                          modulo_diffS = abs(diffS_mean),
                          log10_Sobs=log10(S_obs),
                          log10_U = log10(U_med),
                          log10_d = log10(d))

df_resultados.z <- as.data.frame(apply(df_resultados[,c("p","Ntotal","log10_Sobs","k_1","d_Lplot","d","log10_d","modulo_diffS")],2,f_z))
names(df_resultados.z) <- sapply(names(df_resultados.z), function(x) paste0(x,".z"))
df_resultados %<>% cbind(.,df_resultados.z) %>% 
  select(-k_1,-k_1.z)
###############
df_U <- df_resultados %>% filter(MN=="EE") %>% distinct 
#%>% 
  # mutate(log10_Sobs = log10(S_obs),
         # log10_U = log10(U_med))
```


# 0 - Relação Riqueza na área amostral ~ Proporção de Cobertura vegetal na paisagem local

```{r}
df_md <- df_resultados %>% filter(MN=="EE",k=="0.05") %>% distinct()
md_ <- glm.nb(S_obs ~ p + I(p^2) + offset(log(Ntotal)), data = data_)
```


# 1 - Variables


<!-- Commit com os codigos para gamm nRef [referência]: -->
<!-- 97a682916fd0942c0c75ca44fb6c66857ec95706 -->


__table 1:__
Variáveis utilizadas na descrição estatística

```{r 1 tabela de variaveis,echo=FALSE, eval=TRUE}
df_variaveis <- read.csv("/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/tabela_variaveis.csv",
                         header = TRUE,as.is = FALSE) %>% 
  filter(code != "1-k")
knitr::kable(df_variaveis,caption = "Variables") %>%
  kableExtra::kable_styling()
```

  
    
__Figure 1__ Possible Predictor Variables  
  
    
```{r figura 11 possiveis variaveis preditoras,echo=TRUE,include=FALSE,fig.height=7,fig.align='center',fig.width=7}
l_p <- list()
l_p[[1]] <- ggplot(df_resultados,aes(x=k,y=d)) +
  geom_jitter(alpha=0.3) +
  geom_boxplot(alpha=0.6) +
  coord_flip()
l_p[[2]] <- ggplot(df_resultados,aes(x=k,y=d_Lplot)) +
  geom_jitter(alpha=0.3) +
  geom_boxplot(alpha=0.6) +
  coord_flip()
l_p[[3]] <- ggplot(filter(df_resultados,MN=="EE"&k=="0.99"), aes(x=p,y=S_obs)) +
  geom_point(alpha=0.3)
l_p[[4]] <- ggplot(filter(df_resultados,MN=="EE"&k=="0.99"),aes(x="",y=p)) + geom_jitter(alpha=0.3) + geom_boxplot(alpha=0.6) + labs(x="")
l_p[[5]] <- ggplot(filter(df_resultados,MN=="EE"&k=="0.99"),aes(x="",y=S_obs)) + geom_jitter(alpha=0.3) + geom_boxplot(alpha=0.6) + labs(x="")
layout_mat <- rbind(c(1,1,1,2,2,2),
                    c(3,3,3,4,5,NA))
# do.call("grid.arrange",c(l_p[1:3],layout_matrix=1,top="Possible Predictor Variables"))
grid.arrange(l_p[[1]],l_p[[2]],l_p[[3]],l_p[[4]],l_p[[5]],top="Possible Predictor Variables",layout_matrix=layout_mat)
```


  
# 2 - Number of unrefuted SADs
  
    
__Figura 2.1__ número de SADs não refutadas ~ p *  k * MN. A linha azul é uma estimativa baseada em 'loess'.   
    
```{r n_nRef padroes gerais fig21,eval=FALSE}
l_p <- vector("list",2)
l_p[[1]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[1:10]),
                   aes(x=p,y=n_nRef)) + 
  geom_point() + 
  geom_smooth(method="loess") +
  facet_grid(k~MN)
l_p[[2]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[11:20]),
                   aes(x=p,y=n_nRef)) + 
  geom_point() + 
  geom_smooth(method="loess") +
  facet_grid(k~MN) 
do.call("grid.arrange",c(l_p,ncol=2))
```
    
  
  
  
__Figura 2.2__ número de SADs não refutadas ~ (d * MN|Site ~ p). Site está ordenado pelo valor de p.  
  
  
```{r n_nRef padroes gerais fig22 ,fig.width=8, fig.height=27,eval=FALSE}
df_plot <- df_resultados %>% mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
ggplot(df_plot,aes(x=d.z,y=n_nRef,group=MN)) +
  geom_point(aes(color=MN),alpha=0.3) +
  # geom_line(aes(y=Pr_nRef,color=MN),alpha=0.3) +
  scale_color_manual(values=c("#FF0000", "#000000")) +
  theme_classic() + theme(legend.position="top") + labs(x="d(metros)",y="nRef(count)") +
  facet_wrap(~title,ncol=6)
```


  
__Figura 2.3__ n_nRef ~ variáveis categoricas  
    
## 2.1 GLMM binomial

### Modelo cheio 1: 


__linear term__  
  
i) ~ (p + p^2) * (d + d^2) * MN; if : var_dispersao = contiguous  
ii) ~ ( p + p^2) * k * MN;   if : var_dispersao = category    
  
__random term__
  
a) 1|SiteCode  
b) MN|SiteCode  
c)  (var_dispersao + var_dispersao^2)*MN|SiteCode, if : var = dispersao : contiguous



```{r glmm n_nRef comparacao modelos cheios, echo=TRUE,eval=FALSE,cache=TRUE,message=FALSE,warning=FALSE}
# dados
df_md <- df_resultados %>% 
  select(n_nRef,p,SiteCode,MN,p.z,k,d.z,d_Lplot.z)
df_md[,6:8] <- apply(df_md[,6:8],2,as.character)
df_md %<>% 
  gather(key = var_dispersao, value = value_dispersao, k:d_Lplot.z) 
# funcao ajuste dos modelos
f_md <- function(dados){
  var_dispersao <- unique(dados$var_dispersao)
  if(var_dispersao == "k"){
    l_md <- vector("list",2)
    names(l_md) <- c(paste0(var_dispersao," 1|Site"),
                     paste0(var_dispersao," MN|Site"))
    dados$value_dispersao <- factor(dados$value_dispersao,levels = unique(dados$value_dispersao)[20:1])
    l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN +
                         (1|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN +
                         (MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
  }else{
    dados$value_dispersao <- as.numeric(dados$value_dispersao)
    l_md <- vector("list",3)
    names(l_md) <- c(paste0(var_dispersao," 1|Site"),
                     paste0(var_dispersao," MN|Site"),
                     paste0(var_dispersao," (",var_dispersao,"+",var_dispersao,"^2)*MN|Site"))
    l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * (value_dispersao + I(value_dispersao^2)) * MN + 
                         (1|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * (value_dispersao + I(value_dispersao^2)) * MN + 
                         (MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * (value_dispersao + I(value_dispersao^2)) * MN + 
                         ( (value_dispersao + I(value_dispersao^2) ) * MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    
  }
  return(l_md)
}
registerDoMC(3)
l_nRef__modeloCheio <- dlply(df_md,.(var_dispersao),f_md,.parallel = TRUE)
names(l_nRef__modeloCheio) <- NULL
l_nRef__modeloCheio <- do.call(c,l_nRef__modeloCheio)
#
f_warning <- function(glmm_object){
  # glmm_object <- l_nRef__modeloCheio[[4]]
  v_message <- glmm_object@optinfo$conv$lme4$messages %>% 
    as.character()
  if(length(v_message)==0){v_message <- "OK"}
  if(length(v_message)>1){v_message <- v_message[1] }
  return(v_message)
}
df_auditoria.md <- ldply(l_nRef__modeloCheio,f_warning,.id="glmer") %>% 
  rename(warning_message = V1)
```


```{r l_md_nRef.GLMM, eval=FALSE,echo=FALSE}
save(l_nRef__modeloCheio,file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_GLMM.Rdata")
```
  
__Table 2.1__ Modelos Cheios estimados e avisos de convergência  
  
```{r data frame com os avisos de ajustes,eval=TRUE,echo=FALSE}
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_GLMM.Rdata")
# avaliação e melhora do ajuste dos modelos
## warnings
f_warning <- function(glmm_object){
  # glmm_object <- l_nRef__modeloCheio[[4]]
  v_message <- glmm_object@optinfo$conv$lme4$messages %>% 
    as.character()
  if(length(v_message)==0){v_message <- "OK"}
  if(length(v_message)>1){v_message <- v_message[1] }
  return(v_message)
}
df_auditoria.md <- ldply(l_nRef__modeloCheio,f_warning,.id="glmer") %>% 
  rename(warning_message = V1)
v_glmerUpdate <- df_auditoria.md[df_auditoria.md$warning_message != "OK",]$glmer %>% 
  as.character()
knitr::kable(df_auditoria.md) %>% 
  kableExtra::kable_styling()
```
  
    
#### allFit  
  
  
```{r rotina de avaliacao individual dos modelos cheios 1,echo=TRUE,eval=FALSE}
i <- 1
names(l_nRef__modeloCheio[v_glmerUpdate])[i]
#
## update1:
md_allFit <- allFit(l_nRef__modeloCheio[v_glmerUpdate][[i]],maxfun = 1e5, parallel = 'multicore', ncpus = 3)
```
  
  
  
__1) d_Lplot 1|Site__  

7 optimizer(s) failed

__2) d_Lplot MN|Site__  
  
7 optimizer(s) failed
      
__3) d 1|Site__  

7 optimizer(s) failed
         
__4) d MN|Site__      
  
7 optimizer(s) failed    

  
### Modelo cheio 2: 


```{r glmm n_nRef comparacao modelos cheios2, echo=TRUE,eval=FALSE,cache=TRUE,message=FALSE,warning=FALSE}
# dados
df_md <- df_resultados %>% 
  select(n_nRef,p,SiteCode,MN,p.z,k,d.z,d_Lplot.z)
df_md[,6:8] <- apply(df_md[,6:8],2,as.character)
df_md %<>% 
  gather(key = var_dispersao, value = value_dispersao, k:d_Lplot.z) 
# funcao ajuste dos modelos
f_md <- function(dados){
  var_dispersao <- unique(dados$var_dispersao)
  if(var_dispersao == "k"){
    l_md <- vector("list",2)
    names(l_md) <- c(paste0(var_dispersao," 1|Site"),
                     paste0(var_dispersao," MN|Site"))
    dados$value_dispersao <- factor(dados$value_dispersao,levels = unique(dados$value_dispersao)[20:1])
    l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN +
                         (1|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN +
                         (MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
  }else{
    dados$value_dispersao <- as.numeric(dados$value_dispersao)
    l_md <- vector("list",4)
    names(l_md) <- c(paste0(var_dispersao," 1|Site"),
                     paste0(var_dispersao," MN|Site"),
                     paste0(var_dispersao," ",var_dispersao,"*MN|Site"),
                     paste0(var_dispersao,"^2 (",var_dispersao,"+",var_dispersao,"^2)*MN|Site"))
    l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN + 
                         (1|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN + 
                         (MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN + 
                         (value_dispersao * MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[4]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * (value_dispersao + I(value_dispersao^2)) * MN + 
                         ( (value_dispersao + I(value_dispersao^2) ) * MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    
  }
  return(l_md)
}
registerDoMC(3)
l_nRef__modeloCheio2 <- dlply(df_md,.(var_dispersao),f_md,.parallel = TRUE)
names(l_nRef__modeloCheio2) <- NULL
l_nRef__modeloCheio2 <- do.call(c,l_nRef__modeloCheio2)
#
f_warning <- function(glmm_object){
  v_message <- glmm_object@optinfo$conv$lme4$messages %>% 
    as.character()
  if(length(v_message)==0){v_message <- "OK"}
  if(length(v_message)>1){v_message <- v_message[1] }
  return(v_message)
}
df_auditoria.md <- ldply(l_nRef__modeloCheio2,f_warning,.id="glmer") %>% 
  rename(warning_message = V1)
```


```{r l_nRef__modeloCheio2,eval=FALSE,echo=FALSE}
save(l_nRef__modeloCheio2,file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_GLMM2.Rdata")
```
  
    
__Table 2.2__ Modelos Cheios estimados e avisos de convergência    
    
      
```{r warningns l_nRef__modeloCheio2,eval=TRUE,echo=FALSE}
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_GLMM2.Rdata")
# avaliação e melhora do ajuste dos modelos
## warnings
f_warning <- function(glmm_object){
  v_message <- glmm_object@optinfo$conv$lme4$messages %>% 
    as.character()
  if(length(v_message)==0){v_message <- "OK"}
  if(length(v_message)>1){v_message <- v_message[1] }
  return(v_message)
}
df_auditoria.md <- ldply(l_nRef__modeloCheio2,f_warning,.id="glmer") %>% 
  rename(warning_message = V1)
v_glmerUpdate <- df_auditoria.md[df_auditoria.md$warning_message != "OK",]$glmer %>% 
  as.character()
knitr::kable(df_auditoria.md) %>% 
  kableExtra::kable_styling()
```
  
#### allFit  
  
```{r melhoria de modelo cheio 2,eval=FALSE}
i <- 2
names(l_nRef__modeloCheio2[v_glmerUpdate])[i]
md_allFit <- allFit(l_nRef__modeloCheio2[v_glmerUpdate][[i]],maxfun = 1e5, parallel = 'multicore', ncpus = 3)
```
  
  
__d_Lplot.z 1|Site__    
7 optimizer(s) failed


__d.z 1|Site__   
7 optimizer(s) failed


### Comparação de Modelos Cheios:

```{r l_nRef_ModeloCheioFinal,eval=FALSE,echo=FALSE}
v_glmerOK <- df_auditoria.md[df_auditoria.md$warning_message == "OK",]$glmer %>% 
  as.character()
l_nRef_ModeloCheioFinal <- l_nRef__modeloCheio2[v_glmerOK]
save(l_nRef_ModeloCheioFinal,file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_ModeloCheioFinal.Rdata")
```

```{r nRef modelo cheio final tabela de aIC,results="hide"}
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_ModeloCheioFinal.Rdata")
df_tableGLMM <- print(AICctab(l_nRef_ModeloCheioFinal,weights=TRUE)) %>% 
  as.data.frame()
df_tableGLMM$GLMM <- row.names(df_tableGLMM) %>% gsub(".z","",.)
df_tableGLMM$weight <- as.character(df_tableGLMM$weight)
df_tableGLMM$dAICc <- as.numeric(as.character(df_tableGLMM$dAICc))
rownames(df_tableGLMM) <- NULL
df_tableGLMM <- df_tableGLMM[,c(4,1:3)]
```

__Tabela 2.3__ Comparação baseada em AICc dos modelos cheios  
  
```{r tabela 23}
knitr::kable(df_tableGLMM) %>% 
  kableExtra::kable_styling()
```
  
  
__Tabela 2.4__ Coeficiente de Determinação Condicional e Marginal

```{r tabela 24 coeficiente de determinacao condicional e marginal,cache=TRUE,eval=TRUE,echo=TRUE}
md_nRef <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                   (p.z + I(p.z^2)) * (d.z + I(d.z^2)) * MN + 
                   ( (d.z + I(d.z^2) ) * MN|SiteCode),
                 family = "binomial",data=df_resultados,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)),
                 na.action = "na.fail")
r.squaredGLMM(md_nRef)
```




#### Diagnostico do modelo cheio mais plausível 
  
  
__Figura 2.3__ Resíduos Quantílicos do modelo cheio plausível  
  
    
```{r auditoria mais plausivel md_n.ref1, message=FALSE,eval=FALSE,echo=FALSE}
p_plot <- simulateResiduals(md_nRef,n=250,refit = TRUE)
plot(p_plot)
testDispersion(p_plot)
# ggplot(df_resultados,aes(x=df_resultados$n_nRef)) +
#   geom_histogram(bins=60) + facet_wrap(~MN,ncol=2)
```
  
  
    
__Figura 2.4__ Quantile-quantile plot random effects.    
  
    
```{r figura 24 qqplots random effects}
df_ranef <- ranef(md_nRef)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  ggplot(aes(sample=parameter_value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") + theme_classic() +
  facet_wrap(~parameter_class,scales="free",ncol=3)
```
      
  
  
  
__Figura 2.5__ Predito e observado pelo modelo. Em vermelho linha y=x; em azul um modelo linear por sítio de amostragem.      
    
      
```{r fiigura 25,fig.height=4}
# dados
df_md <- md_nRef@frame
df_md$nRef_observado <- df_md$`cbind(n_nRef, 100 - n_nRef)`[,1]
df_md$nRef_predito <- predict(md_nRef,type="response") * 100
# graficos
ggplot(df_md,aes(x=nRef_observado,y=nRef_predito)) +
  geom_smooth(method = "lm",aes(group=SiteCode),se=FALSE,alpha=0.3) +
  geom_abline(slope = 1,intercept = 0,col="red",alpha=0.8,size=2) +
  geom_point(alpha=0.3) +
  facet_wrap(~MN,ncol=2,scales="free") + theme_classic() + xlim(0,100) + ylim(0,100) 
```
  
  
  
  
__Figura 2.6__ Predito e observado para modelo cheio    
  
```{r avaliacao por site fig 26, fig.width=8, fig.height=30,message=FALSE,eval=TRUE,echo=FALSE}
# Dados
## filtrados para o modelo
df_plot <- df_resultados
df_plot$Pr_nRef <- predict(md_nRef,type="response")*100
# df_plot %>% str
# Graficos
df_plot %<>% mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
ggplot(df_plot,aes(x=d.z,y=n_nRef,group=MN)) +
  geom_point(aes(color=MN),alpha=0.3) +
  geom_line(aes(y=Pr_nRef,color=MN),alpha=0.3) +
  scale_color_manual(values=c("#FF0000", "#000000")) +
  theme_classic() + theme(legend.position="top") + labs(x="d(metros)",y="nRef(count)") +
  facet_wrap(~title,ncol=6)
```


      
  
  
## 2.2 Subset=MNEE

### Comparação e diagnostico Modelos Cheios

```{r comparacao modelos cheios nRefEE,echo=TRUE,eval=TRUE}
# dados
df_md <- df_resultados %>% filter(MN=="EE") %>% 
  distinct() %>% 
  mutate(rep = 1)
df_md <- left_join(x=data.frame(rep=1,
                                md_class=c("glmm d+d^2|Site",
                                           "glmm d|Site",
                                           "glmm 1|Site")),
                   y=df_md,
                   by="rep")
# função de ajuste
f_md <- function(dados){
  md_class <- unique(dados$md_class)
  if(md_class == "glmm d+d^2|Site"){
    md_ <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                      (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                      (d.z + I(d.z^2)|SiteCode),
                 family = "binomial",data=dados,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)),
                 na.action = "na.fail")
  }else if(md_class == "glmm d|Site"){
    md_ <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                      (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                      (d.z|SiteCode),
                 family = "binomial",data=dados,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)),
                 na.action = "na.fail")
  }else{
    md_ <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                      (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                      (1|SiteCode),
                 family = "binomial",data=dados,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)),
                 na.action = "na.fail")
  }
  return(md_)
}
```

```{r dlply f md nRef EE, eval=FALSE,echo=TRUE}
registerDoMC(3)
l_nRefEE_mdCheio <- dlply(df_md,"md_class",f_md,.parallel = TRUE)
```


```{r save l_nRefEE_mdCheio, eval=FALSE}
save(l_nRefEE_mdCheio,file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEE_mdCheio.Rdata")
```


__Tabela 2.2.1__ Comparação de modelos Cheios

```{r AICctab l_nRefEE_mdCheio,echo=FALSE,eval=TRUE}
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEE_mdCheio.Rdata")
AICctab(l_nRefEE_mdCheio,weights=TRUE)
df_md <- df_resultados %>% filter(MN=="EE") %>% distinct()
md_nRefEE <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                      (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                      (d.z + I(d.z^2)|SiteCode),
                 family = "binomial",data=df_md,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)),
                 na.action = "na.fail")
```


__Tabela 2.2.2__ Coeficiente de determinação condicional e marginal do modelo cheio mais plausível

```{r tabela 222,message=FALSE,warning=FALSE}
MuMIn::r.squaredGLMM(md_nRefEE)
```


__Figura 2.2.1__ Resíduos Quantílicos do modelo cheio mais plausível

```{r fig 221 res quantil nrefEE cheio,eval=TRUE,echo=FALSE}
p_plot <- DHARMa::simulateResiduals(md_nRefEE,n=1000)
plot(p_plot)
```

__Figura 2.2.2__ Quantile-quantile plot random effects.    

```{r fig 222, eval=TRUE,echo=FALSE}
df_ranef <- ranef(md_nRefEE)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  ggplot(aes(sample=parameter_value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") +
  facet_wrap(~parameter_class,scales="free",ncol=3)
```
  
    
__Figura 2.2.3__ Predito e observado pelo modelo. Em vermelho linha y=x; em azul um modelo linear por sítio de amostragem.      
    
      
```{r fig 223,fig.height=4}
# dados
df_md <- md_nRefEE@frame
df_md$nRef_observado <- df_md$`cbind(n_nRef, 100 - n_nRef)`[,1]
df_md$nRef_predito <- predict(md_nRefEE,type="response") * 100
# graficos
ggplot(df_md,aes(x=nRef_observado,y=nRef_predito)) +
  geom_smooth(method = "lm",aes(group=SiteCode),se=FALSE,alpha=0.3) +
  geom_abline(slope = 1,intercept = 0,col="red",alpha=0.8,size=2) +
  geom_point(alpha=0.3) 
# +
  # facet_wrap(~MN,ncol=2,scales="free") + theme_classic() + xlim(0,100) + ylim(0,100) 
```


### Seleção de Variáveis e Model Averaging

```{r l_md.dredge_nRefEE,eval=FALSE,echo=FALSE}
# todas as combinações de modelo do modelo cheio
registerDoMC(3)
l_md.dredge_nRefEE <- llply(dredge(md_nRefEE,trace = FALSE,evaluate=FALSE), eval,.parallel = TRUE)
save(l_md.dredge_nRefEE,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md.dredge_nRefEE.Rdata")
```


```{r selecao de variaveis nRefEE,eval=TRUE,echo=FALSE,results='hide'}
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_md.dredge_nRefEE.Rdata")
# AICctab
df_tableGLMM <- print(AICctab(l_md.dredge_nRefEE,weights=TRUE)) %>% 
  as.data.frame()
df_tableGLMM$model_code <- row.names(df_tableGLMM)
df_tableGLMM$weight <- as.character(df_tableGLMM$weight)
df_tableGLMM$dAICc <- as.numeric(as.character(df_tableGLMM$dAICc))
rownames(df_tableGLMM) <- NULL
df_tableGLMM <- df_tableGLMM[,c(4,1:3)]
```

__Tabela 2.2.3__ Modelos com maior peso de evidência

```{r tabela 223,echo=FALSE,eval=TRUE}
knitr::kable(head(df_tableGLMM,n=10)) %>%
  kableExtra::kable_styling()
```



```{r model averaging EE MuMIn e AICcmodavg,message=FALSE,eval=FALSE}
# Model Averaging for SiteCode predictions
mdAvg_nRefEE__MuMIn <- model.avg(l_md.dredge_nRefEE)
save(mdAvg_nRefEE__MuMIn,file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__MuMIn.Rdata")
# Model Averaging for new data predictions
df_pred <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1],
                       d.z=seq(min(df_resultados$d.z),max(df_resultados$d.z),length=40),
                       p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=200))
mdAvg_nRefEE__AICcmodavg <- modavgPred(l_md.dredge_nRefEE,newdata = df_pred) %>%
  cbind(df_pred)
save(mdAvg_nRefEE__AICcmodavg,file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__AICcmodavg.Rdata")
```
  
    
__Figura 2.2.4__ Observado e predito pelo modelo médio

```{r fig 224 nRefEE observado e predito modelo medio, comment=FALSE, message=FALSE,warning=FALSE,results="hide",fig.width=8, fig.height=30}
# Modelo Global
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__MuMIn.Rdata")
# Predição
df_md <- df_resultados %>% filter(MN=="EE")
df_md$Pr_nRef <- predict(mdAvg_nRefEE__MuMIn,type="response")*100
# Gráfico
df_md %<>% mutate(title = paste0(SiteCode," p=",round(p,3))) %>% arrange(p)
df_md$title <- factor(df_md$title,levels = unique(df_md$title))
ggplot(df_md,aes(x=d,y=n_nRef)) +
  geom_point() + geom_line(aes(y=Pr_nRef),color="red") +
  labs(x="Dispersão Média",
       y="Número de SADs não Refutadas",
       title="Prob. Não Refutar uma SAD neutra MN=EE") +
  facet_wrap(~title,ncol=5)
```
  
  
__Figura 2.2.5__ Predito pelo modelo médio para novo conjunto de dados

```{r figura 225 predito modelo medio novo conjunto de dados}
# dados
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__AICcmodavg.Rdata")
df_plot <- mdAvg_nRefEE__AICcmodavg
df_plot %<>% 
  mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
         d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
# graficos
l_p.nRefEE_AICcmodavg <- list()
l_p.nRefEE_AICcmodavg[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Prob de não Refutar",
       fill="Probability") + theme_classic()
l_p.nRefEE_AICcmodavg[[2]] <- ggplot(df_plot,aes(x=p,y=d,fill=lower.CL)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Lower IC (5%)",
       fill="Probability") + theme_classic()
l_p.nRefEE_AICcmodavg[[3]] <- ggplot(df_plot,aes(x=p,y=d,fill=upper.CL)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Upper IC (95%)",
       fill="Probability") + theme_classic()
grid.arrange(l_p.nRefEE_AICcmodavg[[1]],l_p.nRefEE_AICcmodavg[[2]],l_p.nRefEE_AICcmodavg[[3]],
             layout_matrix=rbind(rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 c(2,2,3,3),
                                 c(2,2,3,3))
             )

```




## 2.3 Subset=MNEI

### Comparação e diagnostico Modelos Cheios

```{r comparacao modelos cheios nRefEI,echo=TRUE,eval=TRUE}
# dados
df_md <- df_resultados %>% filter(MN=="EI") %>% 
  distinct() %>% 
  mutate(rep = 1)
df_md <- left_join(x=data.frame(rep=1,
                                md_class=c("glmm d+d^2|Site",
                                           "glmm d|Site",
                                           "glmm 1|Site")),
                   y=df_md,
                   by="rep")
# função de ajuste
f_md <- function(dados){
  md_class <- unique(dados$md_class)
  if(md_class == "glmm d+d^2|Site"){
    md_ <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                      (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                      (d.z + I(d.z^2)|SiteCode),
                 family = "binomial",data=dados,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)),
                 na.action = "na.fail")
  }else if(md_class == "glmm d|Site"){
    md_ <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                      (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                      (d.z|SiteCode),
                 family = "binomial",data=dados,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)),
                 na.action = "na.fail")
  }else{
    md_ <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                      (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                      (1|SiteCode),
                 family = "binomial",data=dados,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)),
                 na.action = "na.fail")
  }
  return(md_)
}
```

```{r dlply f md nRef EI, eval=FALSE,echo=TRUE}
registerDoMC(2)
l_nRefEI_mdCheio <- dlply(df_md,"md_class",f_md,.parallel = TRUE)
```


```{r save l_nRefEI_mdCheio, eval=FALSE}
save(l_nRefEI_mdCheio,file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEI_mdCheio.Rdata")
```


__Tabela 2.3.1__ Comparação de modelos Cheios

```{r AICctab l_nRefEI_mdCheio,echo=FALSE,eval=TRUE}
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEI_mdCheio.Rdata")
AICctab(l_nRefEI_mdCheio,weights=TRUE)
df_md <- df_resultados %>% filter(MN=="EI") %>% distinct()
md_nRefEI <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                      (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                      (d.z + I(d.z^2)|SiteCode),
                 family = "binomial",data=df_md,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)),
                 na.action = "na.fail")
```


__Tabela 2.3.2__ Coeficiente de determinação condicional e marginal do modelo cheio mais plausível

```{r tabela 232,message=FALSE,warning=FALSE}
MuMIn::r.squaredGLMM(md_nRefEI)
```


__Figura 2.3.1__ Resíduos Quantílicos do modelo cheio mais plausível

```{r fig 231 res quantil nrefEE cheio,eval=TRUE,echo=FALSE}
p_plot <- DHARMa::simulateResiduals(md_nRefEI,n=1000)
plot(p_plot)
```

__Figura 2.3.2__ Quantile-quantile plot random effects.    

```{r fig 232, eval=TRUE,echo=FALSE}
df_ranef <- ranef(md_nRefEI)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  ggplot(aes(sample=parameter_value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") +
  facet_wrap(~parameter_class,scales="free",ncol=3)
```
  
    
__Figura 2.3.3__ Predito e observado pelo modelo. Em vermelho linha y=x; em azul um modelo linear por sítio de amostragem.      
    
      
```{r fig 233,fig.height=4}
# dados
df_md <- md_nRefEI@frame
df_md$nRef_observado <- df_md$`cbind(n_nRef, 100 - n_nRef)`[,1]
df_md$nRef_predito <- predict(md_nRefEI,type="response") * 100
# graficos
ggplot(df_md,aes(x=nRef_observado,y=nRef_predito)) +
  geom_smooth(method = "lm",aes(group=SiteCode),se=FALSE,alpha=0.3) +
  geom_abline(slope = 1,intercept = 0,col="red",alpha=0.8,size=2) +
  geom_point(alpha=0.3) 
# +
  # facet_wrap(~MN,ncol=2,scales="free") + theme_classic() + xlim(0,100) + ylim(0,100) 
```


### Seleção de Variáveis e Model Averaging

```{r l_md.dredge_nRefEI,eval=FALSE,echo=FALSE}
# todas as combinações de modelo do modelo cheio
registerDoMC(3)
l_md.dredge_nRefEI <- llply(dredge(md_nRefEI,trace = FALSE,evaluate=FALSE), eval,.parallel = TRUE)
save(l_md.dredge_nRefEI,file = "~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_md.dredge_nRefEI.Rdata")
```


```{r selecao de variaveis nRefEI,eval=TRUE,echo=FALSE,results='hide'}
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_md.dredge_nRefEI.Rdata")
# AICctab
df_tableGLMM <- print(AICctab(l_md.dredge_nRefEI,weights=TRUE)) %>% 
  as.data.frame()
df_tableGLMM$model_code <- row.names(df_tableGLMM)
df_tableGLMM$weight <- as.character(df_tableGLMM$weight)
df_tableGLMM$dAICc <- as.numeric(as.character(df_tableGLMM$dAICc))
rownames(df_tableGLMM) <- NULL
df_tableGLMM <- df_tableGLMM[,c(4,1:3)]
```

__Tabela 2.3.3__ Modelos com maior peso de evidência

```{r tabela 233,echo=FALSE,eval=TRUE}
knitr::kable(head(df_tableGLMM,n=10)) %>%
  kableExtra::kable_styling()
```



```{r model averaging EI MuMIn e AICcmodavg,message=FALSE,eval=FALSE}
# Model Averaging for SiteCode predictions
mdAvg_nRefEI__MuMIn <- model.avg(l_md.dredge_nRefEI)
save(mdAvg_nRefEI__MuMIn,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__MuMIn.Rdata")
# Model Averaging for new data predictions
df_pred <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1],
                       d.z=seq(min(df_resultados$d.z),max(df_resultados$d.z),length=40),
                       p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=200))
mdAvg_nRefEI__AICcmodavg <- modavgPred(l_md.dredge_nRefEI,newdata = df_pred) %>%
  cbind(df_pred)
save(mdAvg_nRefEI__AICcmodavg,file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__AICcmodavg.Rdata")
```
    
  
__Figura 2.3.4__ Observado e predito pelo modelo médio
  
```{r fig 234 nRefEI observado e predito modelo medio, comment=FALSE, message=FALSE,warning=FALSE,results="hide",fig.width=8, fig.height=30}
# Modelo Global
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__MuMIn.Rdata")
# Predição
df_md <- df_resultados %>% filter(MN=="EI")
df_md$Pr_nRef <- predict(mdAvg_nRefEI__MuMIn,type="response")*100
# Gráfico
df_md %<>% mutate(title = paste0(SiteCode," p=",round(p,3))) %>% arrange(p)
df_md$title <- factor(df_md$title,levels = unique(df_md$title))
ggplot(df_md,aes(x=d,y=n_nRef)) +
  geom_point() + geom_line(aes(y=Pr_nRef),color="red") +
  labs(x="Dispersão Média",
       y="Número de SADs não Refutadas",
       title="Prob. Não Refutar uma SAD neutra MN=EI") +
  facet_wrap(~title,ncol=5)
```



__Figura 2.3.5__ Predito pelo modelo médio para novo conjunto de dados

```{r figura 235 predito modelo medio novo conjunto de dados}
# dados
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__AICcmodavg.Rdata")
df_plot <- mdAvg_nRefEI__AICcmodavg
df_plot %<>% 
  mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
         d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
# graficos
l_p.nRefEI_AICcmodavg <- list()
l_p.nRefEI_AICcmodavg[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Prob de não Refutar",
       fill="Probability") + theme_classic()
l_p.nRefEI_AICcmodavg[[2]] <- ggplot(df_plot,aes(x=p,y=d,fill=lower.CL)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Lower IC (5%)",
       fill="Probability") + theme_classic()
l_p.nRefEI_AICcmodavg[[3]] <- ggplot(df_plot,aes(x=p,y=d,fill=upper.CL)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Upper IC (95%)",
       fill="Probability") + theme_classic()
grid.arrange(l_p.nRefEI_AICcmodavg[[1]],l_p.nRefEI_AICcmodavg[[2]],l_p.nRefEI_AICcmodavg[[3]],
             layout_matrix=rbind(rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 c(2,2,3,3),
                                 c(2,2,3,3))
             )
```


## Figura Final
  
### Gráficos diagnosticos

```{r eval=FALSE,echo=FALSE}
df_md <- df_resultados %>% filter(MN=="EE") %>% distinct()
md_nRefEE <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                     (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                     (d.z + I(d.z^2)|SiteCode),
                   family = "binomial",data=df_md,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)),
                   na.action = "na.fail")
df_md <- df_resultados %>% filter(MN=="EI") %>% distinct()
md_nRefEI <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                      (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                      (d.z + I(d.z^2)|SiteCode),
                 family = "binomial",data=df_md,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)),
                 na.action = "na.fail")
```



```{r FF nRef: graficos diagnosticos,eval=TRUE,echo=FALSE}
l_p <- list()
##############################
########### MNEE #############
##############################
# modelo médio
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__MuMIn.Rdata")
## Predição
df_md <- df_resultados %>% filter(MN=="EE")
df_md$Pr_nRef <- predict(mdAvg_nRefEE__MuMIn,type="response")*100
l_p[[1]] <- ggplot(df_md,aes(x=n_nRef,y=Pr_nRef)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  geom_smooth(method = "gam",aes(group=SiteCode),se = FALSE) +
  geom_abline(intercept = 0,slope=1,color="red") +
  geom_point(alpha=0.3) +
  labs(x="observado",y="predito") +
  facet_wrap(~MN,ncol=1)
## qqnorm ranef
df_ranef <- ranef(md_nRefEE)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
l_p[[2]] <- df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  ggplot(aes(sample=parameter_value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") +
  facet_wrap(~parameter_class,scales="free",ncol=3)
## diagnostico DHARMa
p_plot <- DHARMa::simulateResiduals(md_nRefEE,n=1000)
p1 <-  as.ggplot(~plotQQunif(p_plot))
p2 <-  as.ggplot(~plotResiduals(p_plot))
l_p[[3]] <- as.ggplot(grid.arrange(p1,p2,ncol=2))
##############################
########### MNEI #############
##############################
# modelo médio
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__MuMIn.Rdata")
## Predição
df_md <- df_resultados %>% filter(MN=="EI")
df_md$Pr_nRef <- predict(mdAvg_nRefEI__MuMIn,type="response")*100
l_p[[4]] <- ggplot(df_md,aes(x=n_nRef,y=Pr_nRef)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  geom_smooth(method = "gam",aes(group=SiteCode),se = FALSE) +
  geom_abline(intercept = 0,slope=1,color="red") +
  geom_point(alpha=0.3) +
  labs(x="observado",y="predito") +
  facet_wrap(~MN,ncol=1)
## qqnorm ranef
df_ranef <- ranef(md_nRefEI)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
l_p[[5]] <- df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  ggplot(aes(sample=parameter_value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") +
  facet_wrap(~parameter_class,scales="free",ncol=3)
## diagnostico DHARMa
p_plot <- DHARMa::simulateResiduals(md_nRefEI,n=1000)
p1 <-  as.ggplot(~plotQQunif(p_plot))
p2 <-  as.ggplot(~plotResiduals(p_plot))
l_p[[6]] <- as.ggplot(grid.arrange(p1,p2,ncol=2))
##############################
##############################
##############################
grid.arrange(grobs=l_p,
             layout_matrix=rbind(rep(c(1,4),each=2),
                                 rep(c(1,4),each=2),
                                 rep(c(2,5),each=2),
                                 rep(c(3,6),each=2),
                                 rep(c(3,6),each=2))
             )
```


### Probabilidade de Não Refutar  
  
__Figura 2.4.1__ modavgPred(type="response")  
  
```{r 241 figura final nRef,eval=TRUE,echo=FALSE}
#############
# dados
## MNEE
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__AICcmodavg.Rdata")
mdAvg_nRefEE__AICcmodavg$MN <- "EE"
## MNEI
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__AICcmodavg.Rdata")
mdAvg_nRefEI__AICcmodavg$MN <- "EI"
## df comum
df_plot <- rbind(mdAvg_nRefEE__AICcmodavg,mdAvg_nRefEI__AICcmodavg)
df_plot %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
                    d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
## Gráficos
l_p.nRefEE_AICcmodavg <- list()
labels_IC <- c(lower.CL="IC 5%", upper.CL="IC 95%")
## predição média para ambos modelos
l_p.nRefEE_AICcmodavg[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(
    # title="Probabilidade de Não Refutar",
       fill="Probability") +
  theme_classic() + facet_wrap(~MN,ncol=2) + theme(legend.position="top")
## IC para MNEE
df_plotEE <- df_plot %>% filter(MN=="EE") %>%
  gather(key = IC_class ,value = IC_pred,lower.CL:upper.CL)
l_p.nRefEE_AICcmodavg[[2]] <- ggplot(df_plotEE,aes(x=p,y=d,fill=IC_pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  theme_classic() + facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) + theme(legend.position='none')
## IC para MNEI
df_plotEI <- df_plot %>% filter(MN=="EI") %>%
  gather(key = IC_class ,value = IC_pred,lower.CL:upper.CL)
l_p.nRefEE_AICcmodavg[[3]] <- ggplot(df_plotEI,aes(x=p,y=d,fill=IC_pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  theme_classic() + facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) + theme(legend.position='none')
## Arranjo dos gráficos
grid.arrange(l_p.nRefEE_AICcmodavg[[1]],l_p.nRefEE_AICcmodavg[[2]],l_p.nRefEE_AICcmodavg[[3]],top="Prob(não refutar)",
             layout_matrix=rbind(rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 c(2,2,3,3),
                                 c(2,2,3,3))
             )
# p1
```
  

__Figura 2.4.2__ arm::invlogit(modavgPred(type="link"))
  
```{r load l_mdPredict nRef,eval=TRUE,echo=FALSE}
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_mdPredict__nRef.Rdata")
```

```{r figura 242,eval=TRUE,echo=FALSE}
df_plot <- bind_rows(l_mdPredict,.id = "MN")
df_plot %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
                    d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
df_plot1 <- apply(df_plot[,c(3:4,6:7)],2,arm::invlogit) %>% as.data.frame
df_plot <- cbind(df_plot[c("MN","p","d")],
                 df_plot1)

## Gráficos
l_p.nRefEE_response <- list()
labels_IC <- c(lower.CL="IC 5%", upper.CL="IC 95%")
## predição média para ambos modelos
l_p.nRefEE_response[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(
    # title="Probabilidade de Não Refutar",
       fill="Probability") +
  theme_classic() + facet_wrap(~MN,ncol=2) + theme(legend.position="top")
## IC para MNEE
df_plotEE <- df_plot %>% filter(MN=="EE") %>%
  gather(key = IC_class ,value = IC_pred,lower.CL:upper.CL)
l_p.nRefEE_response[[2]] <- ggplot(df_plotEE,aes(x=p,y=d,fill=IC_pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  theme_classic() + facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) + theme(legend.position='none')
## IC para MNEI
df_plotEI <- df_plot %>% filter(MN=="EI") %>%
  gather(key = IC_class ,value = IC_pred,lower.CL:upper.CL)
l_p.nRefEE_response[[3]] <- ggplot(df_plotEI,aes(x=p,y=d,fill=IC_pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  theme_classic() + facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) + theme(legend.position='none')
## Arranjo dos gráficos
grid.arrange(l_p.nRefEE_response[[1]],l_p.nRefEE_response[[2]],l_p.nRefEE_response[[3]],top="Prob(não refutar)",
             layout_matrix=rbind(rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 c(2,2,3,3),
                                 c(2,2,3,3))
             )

```



### Log Odds Ratio(EE/EI)
  
  
```{r echo=FALSE,eval=FALSE}
# predição na escala da função de ligação
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_md.dredge_nRefEE.Rdata")
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_md.dredge_nRefEI.Rdata")
```

__Janela de Código 2.4.1__ modavgPred(type="link")

```{r predito na escala da funcao de ligacao nRef ambos modelos, eval=FALSE,echo=TRUE}
# Model Averaging for new data predictions
df_pred <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1],
                       d.z=seq(min(df_resultados$d.z),max(df_resultados$d.z),length=40),
                       p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=200))
l_md <- list()
l_md[[1]] <- l_md.dredge_nRefEE
l_md[[2]] <- l_md.dredge_nRefEI
names(l_md) <- c("EE","EI")
# funcao
f_modavgPred <- function(md_object, df = df_pred, type_ = "link"){
  md_avg <- modavgPred(md_object, newdata = df, type = type_ ) %>%
  cbind(df)
}
registerDoMC(2)
l_mdPredict <- llply(l_md,f_modavgPred,.parallel = TRUE)
```

```{r echo=FALSE,eval=FALSE}
save(l_mdPredict,file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_mdPredict__nRef.Rdata")
```


```{r load l_mdPredict nRef 1,eval=TRUE,echo=FALSE}
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_mdPredict__nRef.Rdata")
```


__Figura 2.4.2__ log odds ratio auto coerência. Nas duas ultimas linhas no eixo y está a variável no respectivo histogram na primeira coluna.   
  
```{r calculo do log Odds ratio e figura de autocoerencia,eval=TRUE,echo=TRUE,fig.width=10}
#
df_plot_logOR <- data.frame(p.z = l_mdPredict[["EE"]]$p.z,
                            d.z = l_mdPredict[["EE"]]$d.z,
                            logOR_EE.EI = l_mdPredict[["EE"]]$mod.avg.pred - l_mdPredict[["EI"]]$mod.avg.pred,
                            lower.logOR_EE.EI = l_mdPredict[["EE"]]$lower.CL - l_mdPredict[["EI"]]$lower.CL,
                            upper.logOR_EE.EI = l_mdPredict[["EE"]]$upper.CL - l_mdPredict[["EI"]]$upper.CL,
                            logOdds_EE = l_mdPredict[["EE"]]$mod.avg.pred,
                            lower.logOdds_EE = l_mdPredict[["EE"]]$lower.CL,
                            upper.logOdds_EE = l_mdPredict[["EE"]]$upper.CL,
                            logOdds_EI = l_mdPredict[["EI"]]$mod.avg.pred,
                            lower.logOdds_EI = l_mdPredict[["EI"]]$lower.CL,
                            upper.logOdds_EI = l_mdPredict[["EI"]]$upper.CL)

df_plot_logOR[,3:5] %>% 
  gather(key=logOR_class, value=logOR_value,logOR_EE.EI:upper.logOR_EE.EI) %>%
  ggplot(aes(y=logOR_value,x=logOR_class)) + labs(x="",y="") +
  geom_boxplot() +
  geom_jitter(alpha=0.3) 
#+ 
# +
  # facet_wrap(~logOR_class,ncol=3,dir = "v")

l_p <- list()
l_p[[1]] <- df_plot_logOR[,3:5] %>% 
  gather(key=logOR_class, value=logOR_value,logOR_EE.EI:upper.logOR_EE.EI) %>%
  ggplot(aes(x=.$logOR_value)) + labs(x="",y="") +
  geom_histogram(bins=60) + facet_wrap(~logOR_class,ncol=3,dir = "v")
for(i in 3:5){
  l_p[[i-1]] <- df_plot_logOR[,c(i,i+3,i+6)] %>% 
    gather(key = "logOdds_MN", value = "logOdds_value", names(.)[-1]) %>% 
    ggplot(aes_string(x=names(.)[3],y=names(.)[1])) + 
    geom_point(alpha=0.3) +
    facet_wrap(~logOdds_MN,ncol=1) + labs(x="",y="")
}
grid.arrange(l_p[[1]],l_p[[2]],l_p[[3]],l_p[[4]],
             layout_matrix = rbind(c(1,1,1),
                                   2:4)
             )
```
    
__Figura 2.4.3__ Log odds ratio EE/EI  

```{r fig 243, eval=TRUE,fig.width=10}
df_plot_logOR %<>% 
  mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
         d = d.z * sd(df_resultados$d) + mean(df_resultados$d))
df_ <- apply(df_plot_logOR[,3:5], 2, f_z) %>% as.data.frame
names(df_) <- sapply(names(df_),function(x) paste0(x,".z"))
df_ <- cbind(df_plot_logOR,df_)
l_p <- list()  
v_limits <- c(min = min(c(df_plot_logOR$logOR_EE.EI,
                          df_plot_logOR$lower.logOR_EE.EI,
                          df_plot_logOR$upper.logOR_EE.EI)),
              max = max(c(df_plot_logOR$logOR_EE.EI,
                          df_plot_logOR$lower.logOR_EE.EI,
                          df_plot_logOR$upper.logOR_EE.EI)),
              avg = mean(df_plot_logOR$logOR_EE.EI)
              )
l_p[[1]] <- ggplot(df_plot_logOR,aes(x=p,y=d,fill=logOR_EE.EI)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(v_limits[1],v_limits[2]),
                       midpoint = v_limits[3], 
                       low="red", high="blue",mid="green") +
  labs(
    # title="Probabilidade de Não Refutar",
       fill="log Odds Ratio( EE / EI ) ") +
  scale_fill_distiller(palette = "Spectral") +
  theme(legend.position="top")
labels_IC <- c(lower.logOR_EE.EI="IC 5%", upper.logOR_EE.EI="IC 95%")
l_p[[2]] <- df_plot_logOR %>%
  gather(key = IC_class ,value = IC_pred,lower.logOR_EE.EI:upper.logOR_EE.EI) %>% 
  ggplot(aes(x=p,y=d,fill=IC_pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(v_limits[1],v_limits[2]),
                       midpoint = v_limits[3], 
                       low="red", high="blue",mid="green") +
  scale_fill_distiller(palette = "Spectral") +
  facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) + theme(legend.position='none')
## Arranjo dos gráficos
grid.arrange(l_p[[1]],l_p[[2]],
                   layout_matrix = rbind(1,1,2))

```


#### Estudo log Odds Ratio (EE/EI)

__figura 2.4.4__ Probabilidade ~ log Odds

```{r estudo log odds ratio nao truncado, fig.height=3,fig.width=10}
df_plot <- bind_rows(l_mdPredict,.id = "MN")
df_plot %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
                    d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
df_ <- apply(df_plot[,c(3:4,6:7)],2,arm::invlogit) %>% as.data.frame
names(df_) <- sapply(names(df_), function(x) paste0(x,"_response"))
df_plot <- cbind(df_plot,df_)
l_p <- list()
l_p[[1]] <- df_plot %>% 
  ggplot(aes(x=mod.avg.pred,y=mod.avg.pred_response)) +
  geom_point(alpha=0.3) +
  facet_wrap(~MN,ncol=2) + labs(x="log Odds",y="Prob","modelo médio",title="fit")
l_p[[2]] <- df_plot %>% 
  ggplot(aes(x=upper.CL,y=upper.CL_response)) +
  geom_point(alpha=0.3) +
  facet_wrap(~MN,ncol=2) + labs(x="log Odds",y="Prob","modelo médio",title="upper")
l_p[[3]] <- df_plot %>% 
  ggplot(aes(x=lower.CL,y=lower.CL_response)) +
  geom_point(alpha=0.3) +
  facet_wrap(~MN,ncol=2) + labs(x="log Odds",y="Prob","modelo médio",title="lower")
do.call("grid.arrange",c(l_p,ncol=3,top="não truncado"))
```

```{r estudo log odds ratio truncado, fig.height=3,fig.width=10}
# truncar o log odds para poder avaliar o log odds ratio
v_range <- c(min = df_plot %>% filter(MN=="EE") %>% .$lower.CL %>% min,
             max = df_plot %>% filter(MN=="EE") %>% .$upper.CL %>% max)
## fit
df_plot$mod.avg.pred[df_plot$mod.avg.pred>v_range[2]] <- v_range[2] + 1 
df_plot$mod.avg.pred[df_plot$mod.avg.pred<v_range[1]] <- v_range[1] - 1 
## lower
df_plot$lower.CL[df_plot$lower.CL>v_range[2]] <- v_range[2] + 1 
df_plot$lower.CL[df_plot$lower.CL<v_range[1]] <- v_range[1] - 1 
## upper
df_plot$upper.CL[df_plot$upper.CL>v_range[2]] <- v_range[2] + 1 
df_plot$upper.CL[df_plot$upper.CL<v_range[1]] <- v_range[1] - 1 
###
l_p <- list()
l_p[[1]] <- df_plot %>%
  ggplot(aes(x=mod.avg.pred,y=mod.avg.pred_response)) +
  geom_point(alpha=0.3) +
  facet_wrap(~MN,ncol=2) + labs(x="log Odds",y="Prob","modelo médio",title="fit")
l_p[[2]] <- df_plot %>% 
  ggplot(aes(x=upper.CL,y=upper.CL_response)) +
  geom_point(alpha=0.3) +
  facet_wrap(~MN,ncol=2) + labs(x="log Odds",y="Prob","modelo médio",title="upper")
l_p[[3]] <- df_plot %>% 
  ggplot(aes(x=lower.CL,y=lower.CL_response)) +
  geom_point(alpha=0.3) +
  facet_wrap(~MN,ncol=2) + labs(x="log Odds",y="Prob","modelo médio",title="lower")
do.call("grid.arrange",c(l_p,ncol=3,top="truncado [min(EE), max(EE)]"))
```

__Figura 2.4.5__ Log odds ratio não truncado e truncado
 
```{r fig 245}
# dados geral
df_plot <- bind_rows(l_mdPredict,.id = "MN")
df_plot %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
                    d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
df_ <- apply(df_plot[,c(3:4,6:7)],2,arm::invlogit) %>% as.data.frame
names(df_) <- sapply(names(df_), function(x) paste0(x,"_response"))
df_plot <- cbind(df_plot,df_)
############################################
############### não truncado ###############
############################################
df_EE <- df_plot %>% filter(MN == "EE")
df_EI <- df_plot %>% filter(MN == "EI")
df_plot_logOR <- cbind(df_EE[,c("p","d")],
                       logOR_EE.EI = df_EE$mod.avg.pred - df_EI$mod.avg.pred,
                       lower.logOR_EE.EI = df_EE$lower.CL - df_EI$lower.CL,
                       upper.logOR_EE.EI = df_EE$upper.CL - df_EI$upper.CL)
v_limits <- c(min = min(c(df_plot_logOR$logOR_EE.EI,
                          df_plot_logOR$lower.logOR_EE.EI,
                          df_plot_logOR$upper.logOR_EE.EI)),
              max = max(c(df_plot_logOR$logOR_EE.EI,
                          df_plot_logOR$lower.logOR_EE.EI,
                          df_plot_logOR$upper.logOR_EE.EI)),
              avg = mean(df_plot_logOR$logOR_EE.EI)
              )
l_p <- list()  
l_p[[1]] <- ggplot(df_plot_logOR,aes(x=p,y=d,fill=logOR_EE.EI)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(v_limits[1],v_limits[2]),
                       midpoint = v_limits[3], 
                       low="red", high="blue",mid="green") +
  labs(
    # title="Probabilidade de Não Refutar",
       fill="não truncado ") +
  scale_fill_distiller(palette = "Spectral") +
  theme(legend.position="top")
labels_IC <- c(lower.logOR_EE.EI="IC 5%", upper.logOR_EE.EI="IC 95%")
l_p[[2]] <- df_plot_logOR %>%
  gather(key = IC_class ,value = IC_pred,lower.logOR_EE.EI:upper.logOR_EE.EI) %>% 
  ggplot(aes(x=p,y=d,fill=IC_pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(v_limits[1],v_limits[2]),
                       midpoint = v_limits[3], 
                       low="red", high="blue",mid="green") +
  scale_fill_distiller(palette = "Spectral") +
  facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) + theme(legend.position='none')
############################################
################# truncado #################
############################################
# truncar o log odds para poder avaliar o log odds ratio
v_range <- c(min = df_plot %>% filter(MN=="EE") %>% .$lower.CL %>% min,
             max = df_plot %>% filter(MN=="EE") %>% .$upper.CL %>% max)
## fit
df_plot$mod.avg.pred[df_plot$mod.avg.pred>v_range[2]] <- v_range[2] + 1 
df_plot$mod.avg.pred[df_plot$mod.avg.pred<v_range[1]] <- v_range[1] - 1 
## lower
df_plot$lower.CL[df_plot$lower.CL>v_range[2]] <- v_range[2] + 1 
df_plot$lower.CL[df_plot$lower.CL<v_range[1]] <- v_range[1] - 1 
## upper
df_plot$upper.CL[df_plot$upper.CL>v_range[2]] <- v_range[2] + 1 
df_plot$upper.CL[df_plot$upper.CL<v_range[1]] <- v_range[1] - 1
# 
df_EE <- df_plot %>% filter(MN == "EE")
df_EI <- df_plot %>% filter(MN == "EI")
df_plot_logOR <- cbind(df_EE[,c("p","d")],
                       logOR_EE.EI = df_EE$mod.avg.pred - df_EI$mod.avg.pred,
                       lower.logOR_EE.EI = df_EE$lower.CL - df_EI$lower.CL,
                       upper.logOR_EE.EI = df_EE$upper.CL - df_EI$upper.CL)
v_limits <- c(min = min(c(df_plot_logOR$logOR_EE.EI,
                          df_plot_logOR$lower.logOR_EE.EI,
                          df_plot_logOR$upper.logOR_EE.EI)),
              max = max(c(df_plot_logOR$logOR_EE.EI,
                          df_plot_logOR$lower.logOR_EE.EI,
                          df_plot_logOR$upper.logOR_EE.EI)),
              avg = mean(df_plot_logOR$logOR_EE.EI)
              )
l_p[[3]] <- ggplot(df_plot_logOR,aes(x=p,y=d,fill=logOR_EE.EI)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(v_limits[1],v_limits[2]),
                       midpoint = 0, 
                       low="red", high="blue",mid="green") +
  labs(
    # title="Probabilidade de Não Refutar",
       fill="truncado") +
  scale_fill_distiller(palette = "Spectral") +
  theme(legend.position="top")
labels_IC <- c(lower.logOR_EE.EI="IC 5%", upper.logOR_EE.EI="IC 95%")
l_p[[4]] <- df_plot_logOR %>%
  gather(key = IC_class ,value = IC_pred,lower.logOR_EE.EI:upper.logOR_EE.EI) %>% 
  ggplot(aes(x=p,y=d,fill=IC_pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(v_limits[1],v_limits[2]),
                       midpoint = 0, 
                       low="red", high="blue",mid="green") +
  scale_fill_distiller(palette = "Spectral") +
  facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) + theme(legend.position='none')
## Arranjo dos gráficos
grid.arrange(l_p[[1]],l_p[[2]],l_p[[3]],l_p[[4]],
                   layout_matrix = rbind(c(1,3),
                                         c(1,3),
                                         c(1,3),
                                         c(1,3),
                                         c(1,3),
                                         c(1,3),
                                         c(1,3),
                                         c(2,4),
                                         c(2,4),
                                         c(2,4),
                                         c(2,4)))
```
 


  
### Figura Final  

```{r load l_mdPredict nRef figura final,eval=TRUE,echo=FALSE}
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_mdPredict__nRef.Rdata")
```

  
```{r figura final nRef,echo=FALSE,eval=TRUE,fig.width=10,message=FALSE,warning=FALSE}
# dados
df_plot <- bind_rows(l_mdPredict,.id = "MN")
df_plot %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
                    d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
df_ <- apply(df_plot[,c(3:4,6:7)],2,arm::invlogit) %>% as.data.frame
names(df_) <- sapply(names(df_), function(x) paste0(x,"_response"))
df_plot <- cbind(df_plot,df_)
# plots Probabilidad de não refutar
l_p <- list()
labels_IC <- c(lower.CL_response="IC 5%", upper.CL_response="IC 95%")
## predição média para ambos modelos
l_p[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred_response)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() +
  scale_fill_distiller(limits = c(0,1),palette = "Spectral") +
  labs(title="Probability") +
  theme_classic() + 
  facet_wrap(~MN,ncol=2) + 
  theme(legend.position="top",legend.title = element_blank()) +
  geom_contour(aes(z=mod.avg.pred_response),alpha=0.4, col="black",
               breaks = c(0.10,0.25,0.5,0.75,0.90)) +
  geom_text_contour(aes(z=mod.avg.pred_response),stroke=0.2,
                    breaks = c(0.10,0.25,0.5,0.75,0.90),
                    rotate = FALSE,
                    size=3)
## IC para MNEE
df_plotEE <- df_plot %>% filter(MN=="EE") %>%
  gather(key = IC_class ,value = IC_pred,lower.CL_response:upper.CL_response)
l_p[[2]] <- ggplot(df_plotEE,aes(x=p,y=d,fill=IC_pred)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() +
  scale_fill_distiller(limits = c(0,1),palette = "Spectral") +
  theme_classic() + 
  facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) +
  theme(legend.position='none') +
  geom_contour(aes(z=IC_pred),alpha=0.4, col="black",
               breaks = c(0.10,0.25,0.5,0.75,0.90)) +
  geom_text_contour(aes(z=IC_pred),stroke=0.2,
                    breaks = c(0.10,0.25,0.5,0.75,0.90),
                    rotate = FALSE,
                    size=2.7)
## IC para MNEI
df_plotEI <- df_plot %>% filter(MN=="EI") %>%
  gather(key = IC_class ,value = IC_pred,lower.CL_response:upper.CL_response)
l_p[[3]] <- ggplot(df_plotEI,aes(x=p,y=d,fill=IC_pred)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() +
  scale_fill_distiller(limits = c(0,1),palette = "Spectral") +
  theme_classic() + 
  facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) +
  theme(legend.position='none') +
  geom_contour(aes(z=IC_pred),alpha=0.4, col="black",
               breaks = c(0.10,0.50,0.90)) +
  geom_text_contour(aes(z=IC_pred),stroke=0.2,
                    breaks = c(0.10,0.50,0.90),
                    rotate = FALSE,
                    size=2.7)
# plots para log odds ratio
# dados
df_EE <- df_plot %>% filter(MN == "EE")
df_EI <- df_plot %>% filter(MN == "EI")
df_plot_logOR <- cbind(df_EE[,c("p","d")],
                       logOR_EE.EI = df_EE$mod.avg.pred - df_EI$mod.avg.pred,
                       lower.logOR_EE.EI = df_EE$lower.CL - df_EI$lower.CL,
                       upper.logOR_EE.EI = df_EE$upper.CL - df_EI$upper.CL)
## graficos
v_limits <- c(min = min(c(df_plot_logOR$logOR_EE.EI,
                          df_plot_logOR$lower.logOR_EE.EI,
                          df_plot_logOR$upper.logOR_EE.EI)),
              max = max(c(df_plot_logOR$logOR_EE.EI,
                          df_plot_logOR$lower.logOR_EE.EI,
                          df_plot_logOR$upper.logOR_EE.EI)),
              avg = mean(df_plot_logOR$logOR_EE.EI))
l_p[[4]] <- ggplot(df_plot_logOR,aes(x=p,y=d,fill=logOR_EE.EI)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() + theme_classic() +
  scale_fill_distiller(limits = c(v_limits[1],v_limits[2]),
                       palette = "Spectral") +
  labs(title="log OR(EE/EI)") +
  theme(legend.position="top",
        legend.title = element_blank()) +
  geom_contour(aes(z=logOR_EE.EI),alpha=0.4, col="black",
               breaks = c(-5,0,5,30)) +
  geom_text_contour(aes(z=logOR_EE.EI),stroke=0.2,
                    breaks = c(-5,0,5,30),
                    rotate = FALSE,
                    size=3)
labels_IC2 <- c(lower.logOR_EE.EI="IC 5%", upper.logOR_EE.EI="IC 95%")
l_p[[5]] <- df_plot_logOR %>%
  gather(key = IC_class ,value = IC_pred,lower.logOR_EE.EI:upper.logOR_EE.EI) %>% 
  ggplot(aes(x=p,y=d,fill=IC_pred,z=IC_pred)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() + 
  theme_classic() +
  scale_fill_distiller(limits = c(v_limits[1],v_limits[2]),
                       palette = "Spectral") +
  theme(legend.position='none')  +
  facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC2)) +
  geom_contour(aes(z=IC_pred),alpha=0.4, col="black",
               breaks = c(-5,0,5,30)) +
  geom_text_contour(aes(z=IC_pred),stroke=0.2,
                    breaks = c(-5,0,5,30),
                    rotate = FALSE,
                    size=2.7)
## Arranjo dos gráficos
# l_p[[1]],l_p[[2]],l_p[[3]],l_p[[4]],l_p[[5]],
lay_mat <- rbind(c(rep(1,4),c(4,4)),
                 c(rep(1,4),c(4,4)),
                 c(rep(1,4),c(4,4)),
                 c(rep(1,4),c(4,4)),
                 rep(c(2,3,5),each=2),
                 rep(c(2,3,5),each=2))
grid.arrange(grobs = l_p, layout_matrix = lay_mat)
```



```{r eval=FALSE}
df_EE <- df_plot %>% filter(MN == "EE")
df_EI <- df_plot %>% filter(MN == "EI")
df_plot_logOR <- cbind(df_EE[,c("p","d")],
                       logOR_EE.EI = df_EE$mod.avg.pred - df_EI$mod.avg.pred,
                       lower.logOR_EE.EI = df_EE$lower.CL - df_EI$lower.CL,
                       upper.logOR_EE.EI = df_EE$upper.CL - df_EI$upper.CL)
# df_plot_logOR$logOR_EE.EI %>% summary
## graficos
v_limits <- c(min = min(c(df_plot_logOR$logOR_EE.EI,
                          df_plot_logOR$lower.logOR_EE.EI,
                          df_plot_logOR$upper.logOR_EE.EI)),
              max = max(c(df_plot_logOR$logOR_EE.EI,
                          df_plot_logOR$lower.logOR_EE.EI,
                          df_plot_logOR$upper.logOR_EE.EI)),
              avg = mean(df_plot_logOR$logOR_EE.EI))
l_p1 <- ggplot(df_plot_logOR,aes(x=p,y=d,fill=logOR_EE.EI)) +
  geom_tile() + theme_classic() +
  # scale_fill_gradient2(limits = c(v_limits[1],v_limits[2]),
  #                      # midpoint = 0, 
  #                      low="red", high="blue",mid="green") +
  coord_cartesian(expand = FALSE) + 
  labs(title="log OR(EE/EI)") +
  theme(legend.position="top",
        legend.title = element_blank()) +
  scale_fill_distiller(limits = c(v_limits[1],v_limits[2]),
                       palette = "Spectral",
                       breaks = c(-30,0,30,60,80)) +
  geom_contour(aes(z=logOR_EE.EI),alpha=0.4, col="black",
               breaks = c(-5,0,5,30)) +
#+
  # stat_contour(aes(x=p,y=d,z=logOR_EE.EI),alpha=0.4,col="black",
               # breaks = c(-10,0,10,30,60))
  geom_text_contour(aes(z=logOR_EE.EI),stroke=0.2,
                    breaks = c(-5,0,5,30),
                    rotate = FALSE) +
  # geom_vline(xintercept = 0.25,color="red")
  geom_hline(yintercept = 9.2,color="red")

l_p1
# direct.label(l_p1, list(top.pieces,color='black'))
```



#### Stats

##### log OR
  
Para d = 20, qual intervalo de p logOR c [-5,5]?      
  
```{r}
l_range <- list()
l_range[[1]] <- df_plot_logOR %>% filter(d == max(.$d)) %>% 
  filter(logOR_EE.EI >-5 & logOR_EE.EI<5) %>% .$p %>% range %>% round(.,3) #logOR_EE.EI %in% (-5:5)
l_range[[2]] <- df_plot_logOR %>% filter(d == max(.$d)) %>% 
  filter(lower.logOR_EE.EI >-5 & lower.logOR_EE.EI<5) %>% .$p %>% range %>% round(.,3) #logOR_EE.EI %in% (-5:5)
l_range[[3]] <- df_plot_logOR %>% filter(d == max(.$d)) %>% 
  filter(upper.logOR_EE.EI >-5 & upper.logOR_EE.EI<5) %>% .$p %>% range %>% round(.,3) #logOR_EE.EI %in% (-5:5)
names(l_range) <- c("fit","lower","upper")
l_range %<>% bind_rows() %>% as.data.frame()
l_range$range <- c("min","max")
l_range <- l_range[,c(4,1:3)]
l_range <- bind_rows(l_range,
                     cbind(data.frame(range = "diff"),
                           as.data.frame(t(apply(l_range[,2:4],2,diff))))
          )
l_range
```


Para p->0 para qual d logOR < -5?

```{r}
df_plot_logOR %>% 
  filter(p == min(.$p)) %>%
  filter(logOR_EE.EI < -5) %>%
  .$d %>% range
```

##### Pr(nRef) subset == EE

Para d=max, qual p Pr(nRef) < 0.75

```{r}
df_EE %>% 
  filter(d == max(.$d)) %>% 
  filter(mod.avg.pred_response < 0.75) %>% 
  .$p %>% range %>% round(.,digits = 3)
```

Para p=min, qual d Pr(nRef) < 0.75

```{r}
df_EE %>% 
  filter(p == min(.$p)) %>% 
  filter(mod.avg.pred_response < 0.75) %>% 
  .$d %>% range %>% round(.,digits = 3)
```

Para d=max, qual p Pr(nRef) =< 0.10

```{r}
df_EE %>% 
  filter(d == max(.$d)) %>% 
  filter(mod.avg.pred_response <= 0.1) %>% 
  .$p %>% range %>% round(.,digits = 3)
```

Para p=min, qual d Pr(nRef) =< 0.10

```{r}
df_EE %>% 
  filter(p == min(.$p)) %>% 
  filter(mod.avg.pred_response <= 0.1) %>% 
  .$d %>% range %>% round(.,digits = 3)
```
  
Qual o máximo da área de baixo Pr(nRef)?  
  
```{r}
df_EE %>% 
  filter(d == max(.$d)) %>% 
  filter(lower.CL_response <= 0.1) %>% 
  .$p %>% range %>% round(.,digits = 3)
```

```{r}
df_EE %>% 
  filter(p == min(.$p)) %>% 
  filter(lower.CL_response <= 0.1) %>% 
  .$d %>% range %>% round(.,digits = 3)
```

Qual o máximo da área de alto Pr(nRef)?  
  
```{r}
df_EE %>% 
  filter(d == max(.$d)) %>% 
  filter(upper.CL_response  < 0.75) %>% 
  .$p %>% range %>% round(.,digits = 3)
```

```{r}
df_EE %>% 
  filter(p == min(.$p)) %>% 
  filter(upper.CL_response < 0.75) %>% 
  .$d %>% range %>% round(.,digits = 3)
```

##### Pr(nRef) subset == EI

Para d=max, qual p Pr(nRef) < 0.75

```{r}
df_EI %>% 
  filter(d == max(.$d)) %>% 
  filter(mod.avg.pred_response >= 0.90) %>% 
  .$p %>% range %>% round(.,digits = 3)
```

Para p=max, qual d Pr(nRef) < 0.75

```{r}
df_EI %>% 
  filter(p == max(.$p)) %>% 
  filter(mod.avg.pred_response >= 0.5) %>% 
  .$d %>% range %>% round(.,digits = 3)
```

Para d=max, qual p Pr(nRef) =< 0.10

```{r}
df_EI %>% 
  filter(d == max(.$d)) %>% 
  filter(mod.avg.pred_response <= 0.1) %>% 
  .$p %>% range %>% round(.,digits = 3)
```

Para p=min, qual d Pr(nRef) =< 0.10

```{r}
df_EI %>% 
  filter(p == max(.$p)) %>% 
  filter(mod.avg.pred_response <= 0.1) %>% 
  filter(d > 2) %>% 
  .$d %>% range %>% round(.,digits = 3)
```
  
Qual o máximo da área de baixo Pr(nRef)?  
  
```{r}
df_EI %>% 
  filter(d == max(.$d)) %>% 
  filter(lower.CL_response <= 0.1) %>% 
  .$p %>% range %>% round(.,digits = 3)
```

```{r}
df_EI %>% 
  filter(p == min(.$p)) %>%
  filter(lower.CL_response <= 0.1) %>% 
  filter(d > 2) %>% 
  .$d %>% range %>% round(.,digits = 3)
```

Qual o máximo da área de alto Pr(nRef)?  
  
```{r}
df_EI %>% 
  filter(d == max(.$d)) %>% 
  filter(upper.CL_response  >= 0.9) %>% 
  .$p %>% range %>% round(.,digits = 3)
```

```{r}
df_EI %>% 
  filter(p == max(.$p)) %>% 
  filter(upper.CL_response  >= 0.9) %>% 
  .$d %>% range %>% round(.,digits = 3)
```



# 3 Bias in species richness 

__diffS = (S_MN - S_obs)/S_obs__

__Figura 3.1.1__ Padrões Gerais diffS

```{r fig 31 padroes gerais diffS,message=FALSE,eval=TRUE,echo=FALSE,fig.height=6}
# gráfico
df_resultados %>% ggplot(aes(x=p,y=diffS_mean,group=MN)) +
  geom_smooth(method = "loess",col="blue") +
  geom_point(aes(color=MN),alpha=0.3) +
  scale_color_manual(values=c("#FF0000", "#000000")) +
  labs(title="diffS = (S - Sobs)/Sobs",x="p",y="diffS",subtitle = "k") +
  facet_wrap(~k,ncol=5,scales="free")
# # graficos
# filter(df_resultados,MN=="EE") %>% select(diff_S0, p, d, Stotal, Ntotal) %>% ggpairs() + labs(title="MNEE")
# do.call("grid.arrange",c(l_p,ncol=1))
```

```{r fig 31 continuacao,echo=FALSE,fig.height=4}
df_resultados %>% ggplot(aes(x=d,y=diffS_mean,color=p)) +
  geom_point(alpha=0.3) + 
  geom_line(aes(group=SiteCode),alpha=0.2) + 
  geom_smooth(method = "loess",color="red",se = FALSE) +
  labs(subtitle = "d") +
  facet_wrap(~MN,ncol=2,scales = "free")
```

```{r fig 31 cont2,echo=FALSE}
df_resultados %>% ggplot(aes(x=.$diffS_mean)) +
  geom_histogram(bins = 60) + facet_wrap(~MN,ncol=2,scales = "free") + labs(subtitle = "histogram",x="")

# ggplot(df_resultados,aes(x=df_resultados$n_nRef)) +
#   geom_histogram(bins=60) + facet_wrap(~MN,ncol=2)
```



## MNEE

### Modelo cheio e diagnostico

```{r diff_S MNEE modelo cheio,echo=TRUE}
# dados
df_md <- df_resultados %>% filter(MN=="EE") %>% 
  distinct() %>% 
  mutate(rep = 1)
df_md <- left_join(x=data.frame(rep=1,
                                md_class=c("d 1|Site",
                                           "d d|Site",
                                           "d d^2|Site",
                                           "1 1|Site",
                                           "1")),
                   y=df_md,
                   by="rep")
# função de ajuste
f_md <- function(dados){
  md_class <- unique(dados$md_class)
  if(md_class == "d 1|Site"){
    md_ <- lmer(diffS_mean ~ 
                  (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                  (1|SiteCode),
                   data=dados, na.action = "na.fail")
  }else if(md_class == "d d|Site"){
    md_ <- lmer(diffS_mean ~ 
                  (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                  (d.z|SiteCode),
                   data=dados, na.action = "na.fail")
  }else if(md_class == "d d^2|Site"){
    md_ <- lmer(diffS_mean ~ 
                  (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                  (d.z + I(d.z^2)|SiteCode),
                   data=dados, na.action = "na.fail")
  }else if(md_class == "1 1|Site"){
    md_ <- lmer(diffS_mean ~ 1 + 
                  (1|SiteCode), 
                data=dados,na.action = "na.fail")
  }else{
    md_ <- lm(diffS_mean ~ 1, 
              data=dados,na.action = "na.fail")
  }
  return(md_)
}
l_md_diffS <- dlply(df_md,.(md_class),f_md)
AICctab(l_md_diffS,weights=T)
```

__Tabela 3.2.1__ Coeficientes de determinação condicional e marginal

```{r}
md_diffS <- l_md_diffS[["1 1|Site"]]
MuMIn::r.squaredGLMM(md_diffS)
```



__Figura 3.2.1__ Resíduos Quantílicos do modelo mais plausível

```{r fig 321}
p_plot <- simulateResiduals(md_diffS)
plot(p_plot)
```


__Figura 3.2.2__ Quantile-quantile plot random effects.    

```{r fig 322, eval=TRUE,echo=FALSE}
df_ranef <- ranef(md_diffS)$SiteCode
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  ggplot(aes(sample=parameter_value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") +
  facet_wrap(~parameter_class,scales="free",ncol=3)
```
  
__Figura 3.2.3__ Predito e observado  
  
```{r fig 323}
#
df_pred <- cbind(md_diffS@frame,
                 predictInterval(md_diffS,type = "linear.prediction",level = 0.95))
df_pred$mean_fit <- predict(md_diffS,re.form=~0)
df_pred$se.mean_fit <- se.fixef(md_diffS)
f_md <- function(dados){
  lm_ <- lm(diffS_mean ~ 1, data=dados)
  df_ <- broom::tidy(lm_) %>% as.data.frame()
  return(df_)
}
registerDoMC(2)
df_pred %<>% inner_join(x = .,
                        y = ddply(.,"SiteCode",f_md,.parallel=TRUE),
                        by = "SiteCode")
#
# df_pred %>% names
df_pred %>%
  ggplot(aes(x="",y=diffS_mean)) +
  # geom_crossbar(aes(ymin = mean_fit - se.mean_fit,
                    # middle = mean_fit,
                    # ymax = mean_fit + se.mean_fit),
               # color = "red",alpha = 0.6,outlier.shape = NA) +
  geom_boxplot(aes(ymin = mean_fit - 1.96 * se.mean_fit,
                    lower = mean_fit - se.mean_fit,
                    middle = mean_fit,
                    upper = mean_fit + se.mean_fit,
                    ymax = mean_fit + 1.96*se.mean_fit),
               color = "red",alpha = 0.6,outlier.shape = NA) + #,stat="identity"
  # facet_wrap(~SiteCode,ncol=6) +
  # geom_boxplot(aes(ymin = estimate - 1.96 * std.error,
  #                  lower = estimate - std.error,
  #                  middle = estimate,
  #                  upper = estimate + std.error,
  #                  ymax = estimate + 1.96 * std.error),
  #              color = "blue",alpha = 0.6,outlier.shape = NA,stat = "identity") +
  # geom_pointrange(aes(ymin = lwr,
  #                     middle = fit,
  #                     ymax = upr),
  #                 color = "green", alpha = 0.6,outlier.shape = NA) +
  geom_jitter(alpha=0.3)
```

```{r}
sjPlot::tab_model(md_diffS,digits = 4)
df_pred %>% ddply("SiteCode",summarise,estimate = head(estimate,1)) %>% .$estimate %>% range() %>% formatC(.,format="e",digits = 2)
df <- df_pred %>% select(mean_fit,se.mean_fit) %>% head(.,n=1) %>% 
  mutate(lowerIC = mean_fit - 1.92 * se.mean_fit,
         upperIC = mean_fit + 1.92 * se.mean_fit)
apply(df,2, function(X) formatC(X,digits = 2,format = "e"))
```
  
## MNEI  
   
     
### Modelo Cheio e Diagnóstico
  
  
```{r diff_S MNEI modelo cheio,echo=TRUE}
# dados
df_md <- df_resultados %>% filter(MN=="EI") %>% 
  distinct() %>% 
  mutate(rep = 1)
df_md <- left_join(x=data.frame(rep=1,
                                md_class=c("d 1|Site",
                                           "d d|Site",
                                           "d d^2|Site")),
                   y=df_md,
                   by="rep")
# função de ajuste
f_md <- function(dados){
  md_class <- unique(dados$md_class)
  if(md_class == "d 1|Site"){
    md_ <- lmer(diffS_mean ~ 
                  (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                  (1|SiteCode),
                   data=dados, na.action = "na.fail")
  }else if(md_class == "d d|Site"){
    md_ <- lmer(diffS_mean ~ 
                  (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                  (d.z|SiteCode),
                   data=dados, na.action = "na.fail")
  }else{ #(md_class == "d d^2|Site")
    md_ <- lmer(diffS_mean ~ 
                  (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                  (d.z + I(d.z^2)|SiteCode),
                   data=dados, na.action = "na.fail")
  }
  return(md_)
}
registerDoMC(2)
l_md_diffS <- dlply(df_md,.(md_class),f_md,.parallel = TRUE)
#
f_warning <- function(glmm_object){
  v_message <- glmm_object@optinfo$conv$lme4$messages %>% 
    as.character()
  if(length(v_message)==0){v_message <- "OK"}
  if(length(v_message)>1){v_message <- v_message[1] }
  return(v_message)
}
#
############################
#### warning convergence ###
############################
ldply(l_md_diffS,f_warning,.id="glmer") %>% 
  rename(warning_message = V1)
############################
#### todos os otimizadores ###
############################
allFit(l_md_diffS[["d d|Site"]],maxfun = 1e5, parallel = 'multicore', ncpus = 3)
############################
#### AICctab ###
############################
l_md <- l_md_diffS[c(1,3)]
AICctab(l_md,weights=TRUE)
```


```{r}
p_plot <- simulateResiduals(l_md[["d d|Site"]])
plot(p_plot)
```

```{r}
df_ranef <- ranef(l_md[["d d|Site"]])$SiteCode
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  ggplot(aes(sample=parameter_value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") +
  facet_wrap(~parameter_class,scales="free",ncol=3)
```

```{r}
df_pred <- cbind(l_md_diffS[[3]]@frame,
                 predictInterval(l_md_diffS[[3]],type = "linear.prediction",level = 0.95))
df_pred %>% ggplot(aes(x=diffS_mean,y=fit)) +
  geom_abline(intercept = 0,slope = 1,color="red") +
  geom_smooth(method = "loess",se = FALSE,color="blue",aes(group=SiteCode),alpha=0.3,size=0.2) +
  coord_cartesian(expand = FALSE) + labs(x="observado",y="predito") +
  geom_point(alpha=0.3)
```


### Seleção de Variáveis e Model Averaging

```{r l_md.dredge_diffS,eval=FALSE,echo=FALSE}
df_md <- df_resultados %>% filter(MN=="EI") %>% 
  distinct()
md_diffS <- lmer(diffS_mean ~ 
                  (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                  (d.z|SiteCode),
                   data=df_md, na.action = "na.fail")
registerDoMC(2)
l_md.dredge_diffS <- llply(dredge(md_diffS,trace = FALSE,evaluate=FALSE), eval,.parallel = TRUE)
```


```{r selecao de variaveis diffS_EI,eval=FALSE,echo=FALSE,results='hide'}
# AICctab
df_tableGLMM <- print(AICctab(l_md.dredge_diffS,weights=TRUE)) %>% 
  as.data.frame()
df_tableGLMM$model_code <- row.names(df_tableGLMM)
df_tableGLMM$weight <- as.character(df_tableGLMM$weight)
df_tableGLMM$dAICc <- as.numeric(as.character(df_tableGLMM$dAICc))
rownames(df_tableGLMM) <- NULL
df_tableGLMM <- df_tableGLMM[,c(4,1:3)]
```

__Tabela 3.3.3__ Modelos com maior peso de evidência

```{r diffS EI tabela 333,echo=FALSE,eval=TRUE}
knitr::kable(head(df_tableGLMM,n=10)) %>%
  kableExtra::kable_styling()
```



```{r model averaging diffS EI MuMIn e AICcmodavg,message=FALSE,eval=FALSE}
# Model Averaging for SiteCode predictions
mdAvg_diffS_EI__MuMIn <- model.avg(l_md.dredge_diffS)
save(mdAvg_diffS_EI__MuMIn,file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_diffS_EI__MuMIn.Rdata")
# Model Averaging for new data predictions
df_pred <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1],
                       d.z=seq(min(df_resultados$d.z),max(df_resultados$d.z),length=40),
                       p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=200))
mdAvg_diffS_EI__AICcmodavg <- modavgPred(l_md.dredge_diffS,newdata = df_pred) %>%
  cbind(df_pred)
save(mdAvg_diffS_EI__AICcmodavg,file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_diffS_EI__AICcmodavg.Rdata")
```
    
  
__Figura 2.3.4__ Observado e predito pelo modelo médio
  
```{r fig 234 diffS EI observado e predito modelo medio, comment=FALSE, message=FALSE,warning=FALSE,results="hide",fig.width=8, fig.height=30}
# Modelo Global
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_diffS_EI__MuMIn.Rdata")
# Predição
df_md <- df_resultados %>% filter(MN=="EI")
df_md$fit <- predict(mdAvg_diffS_EI__MuMIn,type="response")
# Gráfico
df_md %<>% mutate(title = paste0(SiteCode," p=",round(p,3))) %>% arrange(p)
df_md$title <- factor(df_md$title,levels = unique(df_md$title))
ggplot(df_md,aes(x=d,y=diffS_mean)) +
  geom_point() + geom_line(aes(y=fit),color="red") +
  labs(x="Dispersão Média",
       y="Viés da riqueza estimada",
       title="diffS MN=EI") +
  facet_wrap(~title,ncol=5)
```



__Figura 2.3.5__ Predito pelo modelo médio para novo conjunto de dados

```{r figura 235 diffS EI predito modelo medio novo conjunto de dados, fig.width=5,fig.height=8}
# dados
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_diffS_EI__AICcmodavg.Rdata")
df_plot <- mdAvg_diffS_EI__AICcmodavg
df_plot %<>% 
  mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
         d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
# graficos
v_range <- df_resultados %>% filter(MN == "EE") %>% .$diffS_mean %>% range
v_limits <- df_plot %>% select(mod.avg.pred,upper.CL,lower.CL) %>% as.matrix %>% as.vector %>% range
l_p <- list()
df_plot$MN <- "EI"
l_p[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred,z=mod.avg.pred)) +
  geom_tile() +
  coord_cartesian(expand = FALSE) +
  scale_fill_gradient2(midpoint=0, low="blue", high="red",mid="green",limits=v_limits) +
  # scale_colour_gradient(limits=v_limits) +
  stat_subset(aes(subset = mod.avg.pred >= v_range[1] & mod.avg.pred <= v_range[2]),
              alpha=0.5,color="black",size=0.1) +
  geom_contour(breaks=c(-0.6,-0.25,0.25,0.75,1.5,2.5),color="black",alpha=0.5) +
  geom_text_contour(aes(z=mod.avg.pred),stroke=0.2,
                    breaks = c(-0.6,-0.25,0.25,0.75,1.5,2.5),
                    rotate = FALSE,
                    size=2.7) +
  labs(title="Viés da Riqueza Estimada",
       fill="") + theme_classic() + 
  theme(legend.position="top") +
  facet_wrap(~MN,ncol=1)
df_plot$lowerIC <- "Lower IC (5%)"
l_p[[2]] <- ggplot(df_plot,aes(x=p,y=d,fill=lower.CL,z=lower.CL)) +
  geom_tile() +
  coord_cartesian(expand = FALSE) +
  scale_fill_gradient2(midpoint=0, low="blue", high="red",mid="green",limits=v_limits) +
  # scale_colour_gradient(limits=v_limits) +
  stat_subset(aes(subset = lower.CL >= v_range[1] & lower.CL <= v_range[2]),
              alpha=0.5,color="black",size=0.01) +
  geom_contour(breaks=c(-0.6,-0.25,0.25,0.75,1.5,2.5),
               color="black",alpha=0.5) +
  labs(title="",
       fill="") + theme_classic() + 
  theme(legend.position="none") +
  facet_wrap(~lowerIC,ncol=1)
df_plot$upperIC <- "Upper IC (95%)"
l_p[[3]] <- ggplot(df_plot,aes(x=p,y=d,fill=upper.CL,z=upper.CL)) +
  geom_tile() +
  coord_cartesian(expand = FALSE) +
  scale_fill_gradient2(midpoint=0, low="blue", high="red",mid="green",limits=v_limits) +
  # scale_colour_gradient(limits=v_limits) +
  stat_subset(aes(subset = upper.CL >= v_range[1] & upper.CL <= v_range[2]),
              alpha=0.5,color="black",size=0.01) +
  geom_contour(breaks=c(-0.6,-0.25,0.25,0.75,1.5,2.5),
               color="black",alpha=0.5) +
  labs(title="",
       fill="") + theme_classic() + 
  theme(legend.position="none") +
  facet_wrap(~upperIC,ncol=1)

grid.arrange(grobs = l_p,
             layout_matrix=rbind(rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 c(2,2,3,3),
                                 c(2,2,3,3))
             )
```

### graficos diagnostico


```{r}
df_md <- df_resultados %>% filter(MN=="EE") %>% distinct
md_diffS.EE <- lmer(diffS_mean ~ 1 + (1|SiteCode),data=df_md,na.action = "na.fail")
df_predEE <- predictInterval(md_diffS.EE,level = 0.95) %>% 
  apply(., 2, mean) %>% t %>% as.data.frame()
```




```{r}
# modelos cheios
df_md <- df_resultados %>% filter(MN=="EE") %>% distinct
md_diffS.EE <- lmer(diffS_mean ~ 1 + (1|SiteCode),data=df_md,na.action = "na.fail")
df_predEE <- predictInterval(md_diffS.EE,level = 0.95) %>% 
  apply(., 2, mean) %>% t %>% as.data.frame() %>% 
  mutate(rep=1)
df_md <- df_resultados %>% filter(MN=="EI") %>% distinct
md_diffS.EI <- lmer(diffS_mean ~ 
                      (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                      (d.z|SiteCode),
                    data=df_md, na.action = "na.fail")
# graficos
l_p <- list()
##############################
########### MNEE #############
##############################
df_md <- filter(df_resultados,MN=="EE") %>% distinct()
l_p[[1]] <- ggplot(df_md,aes(x="",y=diffS_mean)) +
  geom_jitter(alpha=0.3) +
  geom_hline(yintercept = c(df_predEE$upr,df_predEE$lwr),color="blue",size=1) +
  geom_hline(yintercept=df_predEE$fit,color="red",size=1) +
  theme(axis.ticks.x = element_blank()) +
  labs(x="",y="observado") + coord_cartesian(expand = FALSE) + facet_wrap(~MN,ncol=1)
df_ranef <- ranef(md_diffS.EE)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
l_p[[2]] <- df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  ggplot(aes(sample=parameter_value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") +
  facet_wrap(~parameter_class,scales="free",ncol=1)  
p_plot <- DHARMa::simulateResiduals(md_diffS.EE,n=1000)
p1 <-  as.ggplot(~plotQQunif(p_plot))
p2 <-  as.ggplot(~plotResiduals(p_plot,main="Residual vs. predicted"))
l_p[[3]] <- as.ggplot(grid.arrange(p1,p2,ncol=2))
##############################
########### MNEI #############
##############################
# modelo médio
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_diffS_EI__MuMIn.Rdata")
## Predição
df_md <- df_resultados %>% filter(MN=="EI")
df_md$fit <- predict(mdAvg_diffS_EI__MuMIn,type="response")
l_p[[4]] <- ggplot(df_md,aes(x=diffS_mean,y=fit)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  geom_smooth(method = "gam",aes(group=SiteCode),se = FALSE) +
  geom_abline(intercept = 0,slope=1,color="red") +
  geom_point(alpha=0.3) +
  labs(x="observado",y="predito") +
  facet_wrap(~MN,ncol=1)
## qqnorm ranef
df_ranef <- ranef(md_diffS.EI)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
l_p[[5]] <- df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  ggplot(aes(sample=parameter_value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") +
  facet_wrap(~parameter_class,scales="free",ncol=3)
## diagnostico DHARMa
p_plot <- DHARMa::simulateResiduals(md_diffS.EI,n=1000)
p1 <-  as.ggplot(~plotQQunif(p_plot))
p2 <-  as.ggplot(~plotResiduals(p_plot))
l_p[[6]] <- as.ggplot(grid.arrange(p1,p2,ncol=2))
##############################
########### arrange ##########
##############################
grid.arrange(grobs=l_p,
             layout_matrix=rbind(rep(c(1,4),each=2),
                                 rep(c(1,4),each=2),
                                 c(2,NA,5,5),
                                 rep(c(3,6),each=2),
                                 rep(c(3,6),each=2))
)

```








# 4 - Taxa de Especiação Estimada
  
__Figura 4.1__ Padrões Gerais  
    
    
```{r U padroes gerais,eval=FALSE,echo=FALSE,fig.height=5,fig.width=10,warning=F,message=F}
l_p <- list()
l_p[[1]] <- ggplot(df_U,aes(x=U_med)) +
  geom_histogram(bins=60)
l_p[[2]] <- ggplot(df_U,aes(x=log10(U_med))) +
  geom_histogram(bins=60)
l_p[[3]] <- ggplot(df_U,aes(x=S_obs,y=U_med)) +
  geom_point(alpha=0.3) +
  geom_smooth(method = "loess",se = FALSE,color="red",alpha=0.5)
l_p[[4]] <- ggplot(df_U,aes(x=log10(S_obs),y=log10(U_med))) +
  geom_point(alpha=0.3) +
  geom_smooth(method = "loess",se = FALSE,color="red",alpha=0.5)
l_p[[5]] <- ggplot(df_U,aes(x=p,y=U_med)) +
  geom_point(alpha=0.3) +
  geom_smooth(method = "loess",se = FALSE,color="red",alpha=0.5)
l_p[[6]] <- ggplot(df_U,aes(x=p,y=log10(U_med))) +
  geom_point(alpha=0.3) +
  geom_smooth(method = "loess",se = FALSE,color="red",alpha=0.5)
l_p[[7]] <- ggplot(df_U,aes(x=d,y=U_med)) +
  geom_point(alpha=0.3) +
  geom_smooth(method = "loess",se = FALSE,color="red",alpha=0.5)
l_p[[8]] <- ggplot(df_U,aes(x=d,y=log10(U_med))) +
  geom_point(alpha=0.3) +
  geom_smooth(method = "loess",se = FALSE,color="red",alpha=0.5)
grid.arrange(grobs=l_p,
             layout_matrix = rbind(c(1,3,5,7),
                                   c(2,4,6,8)))
```
Figura 4.1: Taxa de chegada de ancestrais na paisagem (U_med); número de espécies na área amostral (S_obs); proporção de cobertura vegetal na paisagem (p); distância média de dispersão per capita (d)

__Figura 4.2__ Padrões gerais por Sítio de Amostragem: U_med

```{r fig 42,eval=FALSE,echo=FALSE,fig.width=8, fig.height=27,warning=FALSE,message=FALSE,include=FALSE,eval=FALSE}
df_plot <- df_U %>%
  mutate(title = paste0(SiteCode," p=",round(p,3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
df_plot %>% ggplot(aes(x=d,y=U_med)) +
  geom_smooth(method = "loess",se = FALSE,color="red",alpha=0.5) +
  geom_point(alpha=0.5) + 
  facet_wrap(~title,ncol=5) #,scales="free"
```

```{r eval=FALSE,message=FALSE,warning=FALSE,fig.width=8, fig.height=27}
,fig.width=8, fig.height=27
df_plot <- df_U %>%
  mutate(title = paste0(SiteCode," p=",round(p,3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
df_plot %>% ggplot(aes(x=d,y=log10(U_med))) +
  geom_smooth(method = "loess",se = FALSE,color="red",alpha=0.5) +
  geom_point(alpha=0.5) + 
  facet_wrap(~title,ncol=5,top="log10(U) ~ d|Site~p")
```

## 4.1 - Efeito da Riqueza

```{r efeito da riqueza na taxa de chegada de especies raras lmer,eval=T,include=TRUE,echo=FALSE}
# U_med na escala log10
lmer_log10U <- lmer(log10_U ~ log10_Sobs + (1|SiteCode),data=df_U)
summary(lmer_log10U)
p_plot <- simulateResiduals(lmer_log10U)
plot(p_plot)
lmer_U <- lmer_log10U
```
Para os dois modelos observamos desvios do esperado para resíduos quantílicos uniformes; porém o que descreve o log10(U) parece ter uma distribuição de resíduos em função do preditor linear melhor distribuidos. Assim irei continuar com o log10(U). Para a variável resposta log10(U) o qqplot sugere que exista um possível desvio devido a outliers.

```{r}
df_ranef <- ranef(lmer_U)$SiteCode
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
df_ranef %<>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  arrange(parameter_value) #%>% 
l_p <- list()
l_p[[1]] <- ggplot(df_ranef,aes(sample=parameter_value)) +
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red")
l_p[[2]] <- ggplot(df_ranef,aes(x="",y=parameter_value)) +
  geom_boxplot() +
  labs(y="log10(U)")
# df_ranef <- inner_join(x=df_ranef,
#                        y=distinct(select(df_U,SiteCode, log10_Sobs)),
#                        by="SiteCode")
# l_p[[3]] <- ggplot(df_ranef,aes(x=log10_Sobs,y=parameter_value)) +
#   geom_point() +
#   geom_smooth(method="loess",formula=y~x,se=F) +
#   labs(y="log10(U)")
grid.arrange(grobs=l_p,ncol=2,top="Intercept SiteCode")
# boxplot(df_ranef$parameter_value)
# v_siteOut <- df_ranef %>% filter(parameter_value < -0.5) %>% .$SiteCode %>% as.character()
```

```{r}
df_md <- df_U %>% filter(!(SiteCode %in% v_siteOut))
lmer_U_sOut <- update(lmer_U,data=df_md)
p_plot <- simulateResiduals(lmer_U)
summary(lmer_U)
plot(p_plot)
p_plot <- simulateResiduals(lmer_U_sOut)
summary(lmer_U_sOut)
plot(p_plot)
# plot(lmer_U_sOut)
```
O modelo sem os outliers apresenta desvios do esperado pela regressão quantilica 

```{r message=FALSE,warning=FALSE}
df_newdat <- expand.grid(SiteCode=df_U$SiteCode[1], 
                         log10_Sobs = seq(min(df_U$log10_Sobs),max(df_U$log10_Sobs), length=150))
df_pred <- cbind(lmer_U@frame,
                 predictInterval(lmer_U,type = "linear.prediction",level = 0.95))
df_pred %>% #mutate(fit_response = exp(fit)) %>% 
  ggplot(aes(x=log10_U,y=fit)) +
  geom_point(alpha=0.3) +
  geom_abline(intercept = 0,slope = 1,color="red") +
  geom_smooth(method = "lm",se = FALSE,color="blue",formula = y~0+x) + #,aes(group=SiteCode),alpha=0.3,size=0.2
  geom_smooth(method = "loess",se=TRUE,color="green",formula = y~0+x) +
  coord_cartesian(expand = TRUE) + labs(x="observado",y="predito")
```
O modelo consegue realizar uma boa descrição linear dos dados (linha vermelha [y:x], linha azul[lm]), porém há muito mais informação do que o modelo consegue descrever (linha verde[loess]).


```{r}
MuMIn::r.squaredGLMM(lmer_U)
# summary(lmer_U)
```

__bootstrap da predição__

```{r fig.width=10,fig.height=6,fig.width=8}
#new data
df_newdat <- expand.grid(SiteCode=df_U$SiteCode[1], 
                         log10_Sobs = seq(min(df_U$log10_Sobs),max(df_U$log10_Sobs), length=150))
## Passo 2: crie as função que devem ser calculadas dos modelos a cada simulação
## Previstos por efeitos fixos e aleatórios
f1 <- function(.) predict(., newdata=df_newdat)
## Previstos por efeitos fixos (argumento re.form=~0)
f2 <- function(.) predict(., newdata=df_newdat, re.form=~0)
## Os dois bootstraps. Ajuste o argumento ncpus para o numero de cores de seu computador
b3 <- bootMer(lmer_U, FUN = f1, nsim=1000, parallel="multicore", ncpus=2)
b4 <- bootMer(lmer_U, FUN = f2, nsim=1000, parallel="multicore", ncpus=2)
## calcula as médias e intervalos de confiança quantílicos para cada combinação de preditoras
## no novo conjunto de dados
df_newdat$mean <- apply(b3$t,2,mean)
df_newdat$IC.low <- apply(b3$t,2,quantile, 0.025)
df_newdat$IC.upp <- apply(b3$t,2,quantile, 0.975)
df_newdat$mean.fixed <- apply(b4$t,2,mean)
df_newdat$IC.low.fixed <- apply(b4$t,2,quantile, 0.025)
df_newdat$IC.upp.fixed <- apply(b4$t,2,quantile, 0.975)
df_newdat %<>% mutate(std_mean = 10^(mean),
                      std_IC.low = 10^(IC.low),
                      std_IC.upp = 10^(IC.upp),
                      std_mean.fixed = 10^(mean.fixed),
                      std_IC.low.fixed = 10^(IC.low),
                      std_IC.upp.fixed = 10^(IC.upp.fixed))

## graficos
l_p <- list()
# summary(lmer_U)
l_p[[1]] <- df_U %>% 
  ggplot(aes(x=log10_Sobs,y=log10_U)) + 
  geom_ribbon(aes(y = mean, ymin=IC.low, ymax=IC.upp), data=df_newdat, fill="grey15", alpha=0.5) +
  geom_ribbon(aes(y=mean, ymin=IC.low.fixed, ymax=IC.upp.fixed), data=df_newdat, fill="white", alpha=0.5) +
  geom_line(aes(x=log10_Sobs, y=mean.fixed), data=df_newdat,color="red") +
  geom_point(alpha=0.3) + labs(x="log10(Sobs)",y="log10(U)",title="log10(U) = N(-4.175,0.05838) + 0.971*log10(Sobs)")
l_p[[1]]
# l_p[[2]] <- df_U %>% 
#   ggplot(aes(x=10^log10_Sobs,y=U_med)) + 
#   geom_ribbon(aes(y = std_mean, ymin=std_IC.low, ymax=std_IC.upp), data=df_newdat, fill="grey15", alpha=0.5) +
#   geom_ribbon(aes(y=std_mean, ymin=std_IC.low.fixed, ymax=std_IC.upp.fixed), data=df_newdat, fill="white", alpha=0.5) +
#   geom_line(aes(x=10^log10_Sobs, y=std_mean.fixed), data=df_newdat,color="red") +
#   geom_point(alpha=0.3) + labs(x="Sobs",y="U",title="U = [10 ^ N(-4.175,0.05838)] * Sobs ^ 0.971")
# grid.arrange(grobs=l_p,ncol=2)
```
relação entre proporção de cobertura vegetal e log10(Sobs)

```{r}
df_md <- df_U %>% select(p,log10_Sobs) %>% distinct
ggplot(df_md,aes(x=p,y=log10_Sobs)) + geom_point() + geom_smooth(method = "lm",formula=y~x)
md_pSobs<- lm(log10_Sobs ~ p, data=df_md)
summary(md_pSobs)
```




## GAMMM

Seguindo Pedersen et al. 2019:
há duas possibilidades que nos interessam: um smoother por sítio de amostragem com uma mesma penalização; e um smoother e penalização por sítio de amostragem.

Inicio a modelagem pressupondo GAMM com smoother por sítio de amostragem com uma mesma penalização, offset(beta * log10(Sobs)) e distância média de dispersão na escala padrão



```{r gamm U 1, eval=FALSE, echo=TRUE}
beta_log10_Sobs <- fixef(lmer_U)[2] %>% as.numeric() %>% round(.,digits = 3)
l_md <- list()
l_md[[1]] <- gam(log10_U ~ offset(beta_log10_Sobs*log10_Sobs) +
                 s(d.z,bs="tp",k=10) + s(p.z,bs="tp",k=10) + ti(d.z,p.z,bs=c("tp","tp"),k=c(10,10)) +
                 s(d.z,SiteCode,bs="fs",k=10,xt = list("tp")),
                data = df_U, family=gaussian,method = "REML")
l_md[[2]] <- gam(log10_U ~ offset(beta_log10_Sobs*log10_Sobs) +
                 s(d.z,bs="cr",k=10) + s(p.z,bs="cr",k=10) + ti(d.z,p.z,bs=c("cr","cr"),k=c(10,10)) +
                 s(d.z,SiteCode,bs="fs",k=10,xt = list("cr")),
                data = df_U, family=gaussian,method = "REML")
```

```{r save l_md.U_gamEstudo,eval=FALSE,echo=FALSE}
names(l_md) <- c("tp","cr") #,"cc","ps","gp"
l_md_log10_U <- l_md
save(l_md_log10_U,file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_md_log10_U.Rdata")
```

```{r load l_md.U_gamEstudo,eval=TRUE,echo=FALSE}
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_md_log10_U.Rdata")
# l_md <- l_md_log10_U[1:2]
AICctab(l_md)
# df_U %>% names
```
Para a variável d na escala padrão a base 'cr' é a única plausível

```{r predito por md_U d escala padrao ,fig.width=9, fig.height=29}
# dados
md_U <- l_md_log10_U[["cr"]]
df_ <- cbind(cbind(data.frame(fit = md_U$fitted.values,
                              residuals = md_U$residuals),
             md_U$model))
# variaveis para grafico
df_plot <- inner_join(x=distinct(select(df_U,p,SiteCode)),
                      y=df_,
                      by="SiteCode") %>%
  mutate(title = paste0(SiteCode," p=",round(p,3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
# gráfico
df_plot %>% ggplot(aes(x=d.z,y=log10_U)) +
  geom_point(alpha=0.5) + 
  geom_line(aes(x=d.z,y=fit),color="red") + #
  # scale_colour_manual(values=c("red", "blue")) +
  theme(legend.position = "top") +
  facet_wrap(~title,ncol=5,scales="free")
```

na escala padrão, os valores baixos de d.z, que ocorrem nos percentis elevados (e.g.0.99), são muito próximos entre si e aqueles em valores mais altos mais espaçados. Isso pq o kernel de dispersão é exponencial. Uma maneira de ponderar este efeito é transformando a variável d para a escala log:

```{r echo=TRUE,eval=FALSE}
beta_log10_Sobs <- fixef(lmer_U)[2] %>% as.numeric() %>% round(.,digits = 3)
l_md <- list()
l_md[[1]] <- gam(log10_U ~ offset(beta_log10_Sobs*log10_Sobs) +
                 s(log10_d.z,bs="tp",k=10) + s(p.z,bs="tp",k=10) + ti(log10_d.z,p.z,bs=c("tp","tp"),k=c(10,10)) +
                 s(log10_d.z,SiteCode,bs="fs",k=10,xt = list("tp")),
                data = df_U, family=gaussian,method = "REML")
l_md[[2]] <- gam(log10_U ~ offset(beta_log10_Sobs*log10_Sobs) +
                 s(log10_d.z,bs="cr",k=10) + s(p.z,bs="cr",k=10) + ti(log10_d.z,p.z,bs=c("cr","cr"),k=c(10,10)) +
                 s(log10_d.z,SiteCode,bs="fs",k=10,xt = list("cr")),
                data = df_U, family=gaussian,method = "REML")
```

```{r}
names(l_md) <- c("tp","cr") #,"cc","ps","gp"
l_md_U_log10_dz <- l_md
save(l_md_U_log10_dz,file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_md_U_log10_dz.Rdata")
```

```{r}
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_md_U_log10_dz.Rdata")
AICctab(l_md_U_log10_dz,weights=TRUE)
```
para a variável log10(d) o mais plausível é a função de base 'tp' 

```{r md_U escala d na escala log10, eval=TRUE,echo=FALSE,fig.width=9, fig.height=29}
# dados
md_U <- l_md_U_log10_dz[["tp"]]
df_ <- cbind(cbind(data.frame(fit = md_U$fitted.values,
                              residuals = md_U$residuals),
             md_U$model))
# variaveis para grafico
df_plot <- inner_join(x=distinct(select(df_U,p,SiteCode)),
                      y=df_,
                      by="SiteCode") %>%
  mutate(title = paste0(SiteCode," p=",round(p,3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
# gráfico
df_plot %>% ggplot(aes(x=log10_d.z,y=log10_U)) +
  geom_point(alpha=0.5) + 
  geom_line(aes(x=log10_d.z,y=fit),color="red") + #
  # scale_colour_manual(values=c("red", "blue")) +
  theme(legend.position = "top") +
  facet_wrap(~title,ncol=5,scales="free")
```

A transformação da variável d pela transformação log permitiu reduzir o overfit na região de transição entre patamares nos valores baixos do preditor continuo. Porém em alguns casos ainda há overfit. Um possivel problema é o número de funções base:

```{r}
gam.check(md_U)
summary(md_U)
```
o gam.check sugere que aumentar o número de funções base para s(log10_d.z)


```{r warning=FALSE,message=FALSE}
# md_U <- md_U_GS_tp
df_ <- cbind(cbind(data.frame(fit = md_U$fitted.values,
                        residuals = md_U$residuals),
             md_U$model))

l_p <- list()
l_p[[1]] <- ggplot(df_, aes(x=p.z,y=residuals)) +
  geom_smooth(method="loess") +
  geom_point(alpha=0.3)
l_p[[2]] <- ggplot(df_, aes(x=log10_d.z,y=residuals)) +
  geom_smooth(method="loess") +
  geom_point(alpha=0.3)
l_p[[3]] <- ggplot(df_, aes(x=log10_U,y=fit)) +
  geom_smooth(method="loess") +
  geom_point(alpha=0.3)
grid.arrange(grobs=l_p,ncol=3, top="deviance residual and fit ~ observed") #,top="deviance residual ~ continuous predictors"
gratia::appraise(md_U)
```
Talvez se aumentar o número de funções de base possa ser possível obter melhor ajuste:

```{r}
beta_log10_Sobs <- fixef(lmer_U)[2] %>% as.numeric() %>% round(.,digits = 3)
l_md <- list()
l_md[[1]] <- md_U
l_md[[2]] <- gam(log10_U ~ offset(beta_log10_Sobs*log10_Sobs) +
                   s(log10_d.z,bs="tp",k=15) + s(p.z,bs="tp",k=10) + ti(log10_d.z,p.z,bs=c("tp","tp"),k=c(15,10)) +
                   s(log10_d.z,SiteCode,bs="fs",k=15,xt = list("tp")),
                 data = df_U, family=gaussian,method = "REML")
names(l_md) <- c("k=10","k=15")
# AICctab(l_md)
l_md_U_k15 <- l_md 
save(l_md_U_k15,file = "~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_md_U_k15.Rdata")
# summary(l_md_U_k15[["k=15"]])
# gam.check(l_md_U_k15[["k=15"]])
```

```{r}
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_md_U_k15.Rdata")
AICctab(l_md_U_k15)
md_U <- l_md_U_k15[["k=15"]]
```



```{r predito por md_U_GS ,fig.width=9, fig.height=29}
# dados
# df_ <- rbind.fill(cbind(cbind(data.frame(fit = md_U_GS$fitted.values,
#                                          residuals = md_U_GS$residuals,
#                         model = "cr"),
#              md_U_GS$model)),
#              cbind(cbind(data.frame(fit = md_U_GS_tp$fitted.values,
#                                     residuals = md_U_GS_tp$residuals,
#                         model = "tp"),
#              md_U_GS_tp$model)))
# load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_md_log10_U.Rdata")
# md_U <- l_md_log10_U[["cr"]]
df_ <- cbind(cbind(data.frame(fit = md_U$fitted.values,
                              residuals = md_U$residuals),
             md_U$model))
# df_$model %>% table
# variaveis para grafico
df_plot <- inner_join(x=distinct(select(df_U,p,SiteCode)),
                      y=df_,
                      by="SiteCode") %>%
  mutate(title = paste0(SiteCode," p=",round(p,3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
# gráfico
df_plot %>% ggplot(aes(x=log10_d.z,y=log10_U)) +
  geom_point(alpha=0.5) + 
  geom_line(aes(x=log10_d.z,y=fit),color="red") + #
  # scale_colour_manual(values=c("red", "blue")) +
  theme(legend.position = "top") +
  facet_wrap(~title,ncol=5,scales="free")
```
Ainda há muitos problemas na fase de patamares



### observado e predito por sítio de amostragem

```{r}
gratia::appraise(md_U)
```

Pré requisitos para obter a distribuição a posteriori

```{r}
# dados gerais
gamm <- md_U
## dados para predição
df_newdata <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1],
                          log10_d.z=seq(min(df_U$log10_d.z),max(df_U$log10_d.z),length=40),
                          p.z=seq(min(df_U$p.z),max(df_U$p.z),length=200),
                          log10_Sobs = 0)
df_newdata$predict <- predict(gamm, newdata = df_newdata, type = "response")
df_newdata %<>% mutate(p = (p.z + mean(df_resultados$p)) * sd(df_resultados$p),
                       log10_d = (log10_d.z + mean(df_resultados$log10_d)) * sd(df_resultados$log10_d),
                       d = 10^(log10_d),
                       U = 10^predict)

ggplot(df_newdata,aes(x=p,y=d,fill=U)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() +
  scale_fill_distiller(palette = "Spectral") +
  theme_classic() + 
  # facet_wrap(~IC_pred,ncol=1) +
  # theme(legend.position=element_blank(),legend.title = element_blank()) +
  geom_contour(aes(z=U),alpha=0.4, col="black",
               breaks = round(quantile(df_newdata$U,probs = c(0.1,0.25,0.5,0.75,0.9)),5)) +
  geom_text_contour(aes(z=U),stroke=0.2,
                    breaks = round(quantile(df_newdata$U,probs = c(0.1,0.25,0.5,0.75,0.9)),5),
                    rotate = FALSE,
                    size=2.7)
df_U %>% select(d,log10_d,log10_d.z) %>% summary
df_newdata %>% select(d,log10_d,log10_d.z) %>% summary
df_resultados %>% select(d,log10_d,log10_d.z) %>% summary
```



```{r U_med predito e observado para o modelo cheio,fig.width=8, fig.height=30,eval=FALSE}

# broom::augment(lm(c(1:100) ~ c(100:1))) %>% names
# lm(df_U$log10_U ~ gamm$y)

# dados para predição
df_newdata <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1],
                          log10_d.z=seq(min(df_U$log10_d.z),max(df_U$log10_d.z),length=40),
                          p.z=seq(min(df_U$p.z),max(df_U$p.z),length=200),
                          log10_Sobs = 0)
v_predict <- predict(gamm, newdata = df_newdata, type = "response")
beta <- coef(gamm)
V <- vcov.gam(gamm)
##  simulação de parâmetros
num_beta_vecs <- 10000
Cv <- chol(V)
set.seed(1)
nus <- rnorm(num_beta_vecs * length(beta))
beta_sims <- beta + t(Cv) %*% matrix(nus, nrow = length(beta), ncol = num_beta_vecs)
# dim(beta_sims)
matrix_lprediction <- predict(gamm,type="lpmatrix") 
predict_link <- matrix_lprediction %*% beta_sims
df_pred <- t(apply(predict_link,1,function(X) quantile(X,probs = c(0.05,0.50,0.95)))) %>% 
  as.data.frame()
names(df_pred) <- c("IClower","median","ICupper")
df_plot <- cbind(df_,df_pred) 
# %>% 
  # mutate(
    # fit = exp(median),
    #      lower = exp(IClower),
    #      upper = exp(ICupper),
    #      fit_predict = exp(.fitted),
         # p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
         # d = d.z * sd(df_resultados$d) + mean(df_resultados$d))
# df_ %>% summary
# grafico
# grafico
df_plot %<>% mutate(title = paste0(SiteCode," p=",round(p,3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
ggplot(df_plot,aes(x=d,y=U_med)) +
  geom_point(alpha=0.4) +
  geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.3,fill="blue") +
  geom_line(aes(y=fit),color="red",alpha=0.6) +
  # geom_ribbon(aes(ymin=fit_response - 1.96 * se.fit_response,
  #                 ymax=fit_response + 1.96 * se.fit_response),
  #             color="blue",alpha=0.4) +
  labs(title="U; gam(bs=cr)") +
  facet_wrap(~title,ncol=5,scales = "free")
```


### predito

The following code was adapted from Gavin Simpson (2016) blog post [acessado em abril de 2020]:  
  https://fromthebottomoftheheap.net/2016/12/15/simultaneous-interval-revisited/ 
  https://mikl.dk/post/2019-prediction-intervals-for-gam/
  

<!-- ##################################################### -->
<!-- ##################################################### -->
<!-- ##################################################### -->
<!-- # ggplot(df_plot,aes(x=p,y=d,fill=lower)) + -->
<!-- #   coord_cartesian(expand = FALSE) +  -->
<!-- #   geom_tile() + -->
<!-- #   scale_fill_distiller(palette = "Spectral") + -->
<!-- #   labs(title="Especiation rate to obtain the observed species richness at equilibrium") + -->
<!-- #   theme_classic() +  -->
<!-- #   facet_wrap(~variable,ncol=1) + -->
<!-- #   theme(legend.position="top",legend.title = element_blank()) #+ -->
<!-- #   # geom_contour(aes(z=upper),alpha=0.4, col="black", -->
<!-- #   #              breaks = round(quantile(df_plot$fit,probs = c(0.1,0.25,0.5,0.75,0.9)),5) ) + -->
<!-- #   # geom_text_contour(aes(z=upper),stroke=0.2, -->
<!-- #   #                   breaks = formatC(quantile(df_plot$fit,probs = c(0.1,0.25,0.5,0.75,0.9)),format = "e", digits = 3), -->
<!-- #   #                   rotate = FALSE, -->
<!-- #   #                   size=3) -->
<!-- # df_plot %>% -->
<!-- #   gather(key=estimates_class,value=estimates_value,fit:upper) %>% -->
<!-- #   ggplot(aes(x=.$estimates_value)) + geom_histogram(bins=60) + facet_wrap(~estimates_class,ncol=3,scales="free") -->
<!-- # summary(do.call("c",df_plot[,8:10])) -->

<!-- ##################################################### -->
<!-- ##################################################### -->
<!-- ##################################################### -->



```{r figura final gam U df para predicao, eval=FALSE,echo=TRUE}
# dados
## sem Sobs
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_md.U_mdCheio_semSobs.Rdata")
gamm <- l_md.U_mdCheio[["gamm d|Site common"]]
# rotina para obter o intervalo de confiabilidade
## objetos do modelo estimado
beta <- coef(gamm)
V <- vcov(gamm)
##  simulação de parâmetros
num_beta_vecs <- 10000
Cv <- chol(V)
set.seed(as.numeric(Sys.time()))
nus <- rnorm(num_beta_vecs * length(beta))
beta_sims <- beta + t(Cv) %*% matrix(nus, nrow = length(beta), ncol = num_beta_vecs)
# dim(beta_sims)
## para novo conjunto de dados
df <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1],
                  d.z=seq(min(df_resultados$d.z),max(df_resultados$d.z),length=40),
                  p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=200))
matrix_lprediction <- predict(gamm,newdata=df,type="lpmatrix") 
predict_link <- matrix_lprediction %*% beta_sims
df_pred <- t(apply(predict_link,1,function(X) quantile(X,probs = c(0.05,0.50,0.95)))) %>% 
  as.data.frame()
names(df_pred) <- c("IClower","median","ICupper")
df_plot <- cbind(df,df_pred) %>% 
  mutate(fit = exp(median),
         lower = exp(IClower),
         upper = exp(ICupper),
         p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
         d = d.z * sd(df_resultados$d) + mean(df_resultados$d))
write.csv(df_plot,file = "~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/df_plotPredU_sSobs.csv",row.names = FALSE)
```


```{r U predito, fig.height=6,fig.width=13.5}
# dados
df_plot <- read.csv("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/df_plotPredU.csv",
                    header = TRUE,as.is = TRUE)
## graficos
l_p <- list()
# 
df_plot$IC_pred <- "5% quantile"
l_p[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=lower)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() +
  scale_fill_distiller(palette = "Spectral") +
  theme_classic() + 
  facet_wrap(~IC_pred,ncol=1) +
  theme(legend.position="bottom",legend.title = element_blank()) +
  geom_contour(aes(z=lower),alpha=0.4, col="black",
               breaks = round(quantile(df_plot$lower,probs = c(0.1,0.25,0.5,0.75,0.9)),5)) +
  geom_text_contour(aes(z=lower),stroke=0.2,
                    breaks = round(quantile(df_plot$lower,probs = c(0.1,0.25,0.5,0.75,0.9)),5),
                    rotate = FALSE,
                    size=2.7)
#
df_plot$variable <- "median"
l_p[[2]] <- ggplot(df_plot,aes(x=p,y=d,fill=fit)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() +
  scale_fill_distiller(palette = "Spectral") +
  theme_classic() + 
  facet_wrap(~variable,ncol=1) +
  theme(legend.position="bottom",legend.title = element_blank()) +
  geom_contour(aes(z=fit),alpha=0.4, col="black",
               breaks = round(quantile(df_plot$fit,probs = c(0.1,0.25,0.5,0.75,0.9)),5) ) +
  geom_text_contour(aes(z=fit),stroke=0.2,
                    breaks = formatC(quantile(df_plot$fit,probs = c(0.1,0.25,0.5,0.75,0.9)),format = "e", digits = 3),
                    rotate = FALSE,
                    size=3)
#
df_plot$IC_pred <- "95% quantile"
l_p[[3]] <- ggplot(df_plot,aes(x=p,y=d,fill=upper)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() +
  scale_fill_distiller(palette = "Spectral") +
  theme_classic() + 
  facet_wrap(~IC_pred,ncol=1) +
  theme(legend.position="bottom",legend.title = element_blank()) +
  geom_contour(aes(z=upper),alpha=0.4, col="black",
               breaks = round(quantile(df_plot$upper,probs = c(0.1,0.25,0.5,0.75,0.9)),5)) +
  geom_text_contour(aes(z=upper),stroke=0.2,
                    breaks = round(quantile(df_plot$upper,probs = c(0.1,0.25,0.5,0.75,0.9)),5),
                    rotate = FALSE,
                    size=2.7)
grid.arrange(grobs=l_p,ncol=3,top="Speciation Rate")
```









## 5 Congruência entre nRef e diffS:

```{r}
ggplot(df_resultados,aes(x=diffS_mean,y=n_nRef)) +
  coord_cartesian(expand = TRUE) +
  geom_hex(bins = 30) +
  scale_fill_continuous(type = "viridis") +
  geom_vline(xintercept = c(-0.25,0.25),color="red") +
  labs(x="diffS",y="nRef") +
  theme(legend.position = "top") +
  theme_classic() +
  facet_wrap(~MN,ncol=2,scales="free")
```





###############################################



```{r}
df_resultados %>% 
  ggplot(aes(x=p,y=d)) +
  coord_cartesian(expand = TRUE) +
  geom_hex(bins = 60) +
  scale_fill_continuous(type = "viridis") +
  geom_smooth(method="loess")
####
df_resultados %>% 
  ggplot(aes(x=d)) +
  geom_histogram(bins = 60)
df_resultados %>% 
  ggplot(aes(x=p)) +
  geom_histogram(bins = 60)
```

