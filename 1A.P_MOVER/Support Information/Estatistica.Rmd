---
title: "Estatistica"
author: "Mori, Danilo"
date: "31/10/2019"
output: 
  html_document:
    toc: true
    toc_depth: 5
editor_options: 
  chunk_output_type: inline
---

<style>
body {
text-align: justify}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, tidy = FALSE, include = TRUE, warning = FALSE,cache = TRUE,message=FALSE,eval=TRUE)
knitr::opts_knit$set(root.dir = "~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/")
setwd("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/")
```

```{r pacotes,eval=TRUE}
library(gtools)
library(doMC)
library(mgcv)
library(gratia)
library(GUILDS)
library(broom)
library(bbmle)
library(gamm4)
library(lme4)
library(merTools)
library(magrittr)
library(gridExtra)
library(plotly)
library(sjPlot)
library(sjlabelled)
library(sjmisc)
library(ggplot2)
library(stringr)
library(tidyr)
library(plyr)
library(purrr)
library(dplyr)
```

```{r dados}
### dados ###
# leitura
df_resultados <- read.table(file="./resultados/df_resultados.csv",header = TRUE,sep = ";",dec = ".",as.is=FALSE)
df_resultados$k.0_1 <- 1 - df_resultados$k.0
# padronização
level_k <- unique(as.character(df_resultados$k))
df_resultados$k <- factor(as.character(df_resultados$k),levels = level_k)
levels(df_resultados$k)[19] <- "0.1"
df_resultados %<>% mutate(L_plot = 100*sqrt(Ntotal/DA),
                          d_Lplot = d / L_plot,
                          log_Stotal=log(Stotal))
# z score
f_z <- function(x){
  m <- base::mean(x,na.rm=TRUE)
  sd <- sd(x,na.rm=TRUE)
  output <- (x-m)/sd
  return(output)
} 
# names(df_resultados)
df_resultados.z <- as.data.frame(apply(df_resultados[c("p","Ntotal","log_Stotal","k.0","k.0_1","d_Lplot")],2,f_z))
names(df_resultados.z) <- sapply(names(df_resultados.z), function(x) paste(gsub(".0","",x),".z",sep=""))
df_resultados %<>% cbind(.,df_resultados.z)
names(df_resultados)[c(5:6,26,33)] <- c("n_nRef","n_Ref","d_Lplot","d_Lplot.z")
df_resultados.U <- df_resultados %>% filter(MN=="EE") %>% distinct() 
# summary(df_resultados)
```

# Número de SADs preditas não refutadas

## Padrões gerais

```{r n_nRef padroes gerais}
l_p <- vector("list",2)
l_p[[1]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[1:10]),
                   aes(x=p,y=n_nRef)) + 
  geom_point() + 
  geom_smooth(method="loess") +
  facet_grid(k~MN)
l_p[[2]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[11:20]),
                   aes(x=p,y=n_nRef)) + 
  geom_point() + 
  geom_smooth(method="loess") +
  facet_grid(k~MN) 
do.call("grid.arrange",c(l_p,ncol=2))
```

__Figura 1.1__ número de SADs não refutadas ~ p * I(1-k) * MN. A linha azul é uma estimativa baseada em 'loess'. 

Para descrever estatisticamente o número de SADs preditas não refutadas iremos utilizar a distribuição binomial com função de ligação logito. Agruparemos os dados pelo sítio de amostragem. Esperamos que MNEE apresente melhor congruência com o observado para sítios em paisagens com proporção intermediária de cobertura vegetal e para cenários de extrema limitação de dispersão. Uma interpretação desta predição pode ser obtida se possibilitarmos que, para cada sítios de amostragem, a probabilidade de uma predição ser refutada seja uma função da variável de dispersão para cada modelo, ou seja, (dispersão * modelo neutro | sítio de amostragem). O modelo cheio considera a interação de terceira ordem entre as preditoras cobertura vegetal (p, contínua), dispersão (k, categorica; k_1, contínua; d_Lplot, contínua) e a classe do modelo neutro (MNEE e MNEI). Utilizamos uma abordagem baseada em seleção de modelos para determinar a relação entre as variáveis mais parcimoniosa.

## GLMM binomial

### Modelo cheio: escolha das variáveis de dispersão e da estrutura aleatória


```{r n_nRef comparacao modelos cheios}
l_md <- vector("list",8)
names(l_md) <- c("k0 1|Site","k0 MN|Site","k0 k0*MN|Site",
                 "kf 1|Site","kf MN|Site",
                 "d/L_plot 1|Site","d/L_plot MN|Site","d/L_plot d/L_plot*MN|Site")
l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + (1|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + (MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + (MN*k_1.z|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[4]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k * MN + (1|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[5]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k * MN + (MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[6]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + (1|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[7]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + (MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[8]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + (MN*d_Lplot.z|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
AICctab(l_md,weights=T)
```

O único modelo plausível é aquele com função de ligação logito, a variável d/L_plot e a estrutura aleatória MN * d/L_plot|SiteCode. Segue avaliação do pressuposto binomial(link=cloglog):

```{r auditoria mais plausivel md_n.ref1}
md_nRef <- l_md[["d/L_plot d/L_plot*MN|Site"]]
p_plot <- DHARMa::simulateResiduals(md_nRef,n=1000)
plot(p_plot)
```

__Figura 1.2__ Resíduos Quantílicos do modelo cheio para n_nRef ~ p*d_Lplot*MN + (d_Lplot*MN|SiteCode)

Os resíduos quantílicos apontam que a distribuição dos resíduos não adere à distribuição uniforme, o que indica que a distribuição binomial(link=cloglog) não é um bom pressuposto para o conjunto dos dados. Segue resíduos pearson:

```{r auditoria mais plausivel md_n.ref2}
l_p <- vector("list",4)
l_p[[1]] <- plot(md_nRef, sqrt(abs(resid(.)))~fitted(.),
                 type=c("p","smooth"),ylab=expression(sqrt(abs(resid))))
l_p[[2]] <- plot(md_nRef,resid(.,type="pearson")~p.z,
      type=c("p","smooth"),
      id=0.05,idLabels=~SiteCode)
l_p[[3]] <- plot(md_nRef,resid(.,type="pearson")~d_Lplot.z,
      type=c("p","smooth"),
      id=0.05,idLabels=~SiteCode)
l_p[[4]] <- plot(md_nRef,MN~resid(.,type="pearson"),
      type=c("p","smooth"),
      id=0.05,idLabels=~SiteCode)
do.call("grid.arrange",c(l_p,ncol=2))
```

__Figura 1.3__ Resíduos "Pearson" do modelo cheio para n_ref ~ p * I(d/L_plot)*MN + (I(d/L_plot)|SiteCode)

Os resíduos de Pearson indicam que podem existir outliers: alguns sítios apresentam erros agrupados em valores extremos. Pelo gráfico dos resíduos por MN parecem existir 5 sítios em que apresentam comportamento muito distinto dos demais.

```{r selecao do modelo cheio sem os sitios outliers}
# prepração dos dados
df_md_n_nRef <- augment(md_nRef)
df_md_n_nRef$.pearson_resid <- resid(md_nRef,type="pearson")
Sites <- df_md_n_nRef %>% 
  filter(.pearson_resid>100 | .pearson_resid< -50) %>% .$SiteCode %>% as.character()
df_resultados.s_out <- df_resultados %>% filter(!(SiteCode %in% Sites))
# seleção do modelo mais plausível
l_md <- vector("list",8)
names(l_md) <- c("k0 1|Site","k0 MN|Site","k0 k0*MN|Site",
                 "kf 1|Site","kf MN|Site",
                 "d/L_plot 1|Site","d/L_plot MN|Site","d/L_plot d/L_plot*MN|Site")
l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + (1|SiteCode),
                   family = "binomial",data=df_resultados.s_out,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + (MN|SiteCode),
                   family = "binomial",data=df_resultados.s_out,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + (MN*k_1.z|SiteCode),
                   family = "binomial",data=df_resultados.s_out,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[4]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k * MN + (1|SiteCode),
                   family = "binomial",data=df_resultados.s_out,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[5]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k * MN + (MN|SiteCode),
                   family = "binomial",data=df_resultados.s_out,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[6]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + (1|SiteCode),
                   family = "binomial",data=df_resultados.s_out,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[7]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + (MN|SiteCode),
                   family = "binomial",data=df_resultados.s_out,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[8]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + (MN*d_Lplot.z|SiteCode),
                   family = "binomial",data=df_resultados.s_out,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
AICctab(l_md,weights=T)
```

A seleção de modelos é robusta à remoção dos outliers: o único plausível é link=cloglog, d/L_plot e d/L_plot *MN | SiteCode

```{r auditoria md_n.ref sem outliers 1}
p_plot <- DHARMa::simulateResiduals(l_md[["d/L_plot d/L_plot*MN|Site"]],n=1000)
plot(p_plot)
```

__figura 1.4__ Resíduos Quantílicos do modelo cheio sem outliers


O pressuposto de binomial(link=cloglog) continua não sendo adequado.

### Seleção de Variáveis


Sigo com a seleção das variáveis. A estrutura aleatória completa é (MN * d_Lplot.z | SiteCode) para os modelos que possuirem a interação MN*d_Lplot.z, para os demais modelos que não apresentam esse termo a estrutura aleatória segue a relação de MN e d_Lplot.z na estrutura fixa. 

```{r n_nRef selecao de modelos}
l_md <- vector("list",19)
names(l_md) <- c("p*d*MN",# modelo cheio
                 "p*d*MN-p:d:MN", #MC - 3a ordem
                 "p*(d+MN)","d*(p+MN)","MN*(p+d)", #2 interações
                 "p*d+MN","p*MN+d","d*MN+p", #1 interação + preditor
                 "p*d","p*MN","d*MN", #1 interação
                 "p+d+MN",#aditivo 3
                 "p+d","p+MN","d+MN", #aditivo 2 
                 "p","d","MN", #preditor isolado
                 "1") #nulo
#modelo cheio
l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + (d_Lplot.z * MN|SiteCode), family = "binomial",data=df_resultados,
              control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
#modelo cheio - interação 3a ordem
l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN - p.z:d_Lplot.z:MN + (d_Lplot.z * MN|SiteCode), family = "binomial",data=df_resultados,
              control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
#2 interações
l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * (d_Lplot.z + MN) + (MN+d_Lplot.z|SiteCode), family = "binomial",data=df_resultados,
              control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[4]] <- glmer(cbind(n_nRef,100-n_nRef) ~ d_Lplot.z * (p.z + MN) + (d_Lplot.z * MN|SiteCode), family = "binomial",data=df_resultados,
              control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[5]] <- glmer(cbind(n_nRef,100-n_nRef) ~ MN * (p.z + d_Lplot.z) + (d_Lplot.z * MN|SiteCode), family = "binomial",data=df_resultados,
              control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
#1 interação + preditor
l_md[[6]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z + MN + (MN+d_Lplot.z|SiteCode), family = "binomial",data=df_resultados,
              control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[7]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * MN + d_Lplot.z + (MN+d_Lplot.z|SiteCode), family = "binomial",data=df_resultados,
              control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[8]] <- glmer(cbind(n_nRef,100-n_nRef) ~ d_Lplot.z * MN + p.z + (d_Lplot.z * MN|SiteCode), family = "binomial",data=df_resultados,
              control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
#1 interação
l_md[[9]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z + (d_Lplot.z|SiteCode), family = "binomial",data=df_resultados,
              control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[10]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * MN + (MN|SiteCode), family = "binomial",data=df_resultados,
              control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[11]] <- glmer(cbind(n_nRef,100-n_nRef) ~ d_Lplot.z * MN + (d_Lplot.z * MN|SiteCode), family = "binomial",data=df_resultados,
              control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
#aditivo 3
l_md[[12]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z + d_Lplot.z + MN + (MN+d_Lplot.z|SiteCode), family = "binomial",data=df_resultados,
              control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
#aditivo 2
l_md[[13]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z + d_Lplot.z + (d_Lplot.z|SiteCode), family = "binomial",data=df_resultados,
              control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[14]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z + MN + (MN|SiteCode), family = "binomial",data=df_resultados,
              control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[15]] <- glmer(cbind(n_nRef,100-n_nRef) ~ d_Lplot.z + MN + (MN+d_Lplot.z|SiteCode), family = "binomial",data=df_resultados,
              control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
#aditivo 1
l_md[[16]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z + (1|SiteCode), family = "binomial",data=df_resultados,
              control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[17]] <- glmer(cbind(n_nRef,100-n_nRef) ~ d_Lplot.z + (d_Lplot.z|SiteCode), family = "binomial",data=df_resultados,
              control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[18]] <- glmer(cbind(n_nRef,100-n_nRef) ~ MN + (MN|SiteCode), family = "binomial",data=df_resultados,
              control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
# nulo
l_md[[19]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 1 + (1|SiteCode), family = "binomial",data=df_resultados,
              control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
AICctab(l_md,weights=T)
```

O único modelo plausível com 0.909 do peso de evidência é o modelo cheio.

Como visto anteriormente este modelo não apresenta pressupostos que se aproximam do observado para os dados.   

__Tabela 1__ Modelo mais plausível para descrever o número de SADs não refutadas  

```{r tabela do modelo plausivel}
# tab_model(l_md[["p*d*MN"]])
summary(l_md[["p*d*MN"]])
```

O R2 marginal é baixo (0.088) enquanto o R2 condicional é elevado (0.836). Segue avaliação visual da congruência com o observado comparando a probabilidade de se refutar uma predição neutra e a estimada pelo modelo.

```{r auditoria modelo mais plausivel md_nRef}
df_plot <- df_resultados %>% select(SiteCode,p.z,d_Lplot.z,MN,n_nRef) %>% mutate(p_nRef = n_nRef/100)
df_plot$predict <- predict(l_md[["p*d*MN"]],type="response")
# grafico

sites <- levels(df_plot$SiteCode)
l_p <- vector("list",length = 103)
for(i in 1:length(sites)){
  df_ <- filter(df_plot,SiteCode == sites[i])
  # l_p[[i]] <- ggplot(df_,aes(x=p_nRef,y=predict,colour=MN,shape=MN)) + 
  #   geom_point() +
  #   geom_abline(slope=1,intercept = 0,color="red") +
  #   scale_color_manual(values=c("#000000", "#0000FF")) +
  #   labs(title = sites[i])
  plot(df_$predict ~ df_$p_nRef,
       xlim=c(0,1),ylim=c(0,1),col=df_$MN,
       main=sites[i])
  abline(a=0,b=1,color="red",add=TRUE)
}
# do.call("grid.arrange",c(l_p,ncol=10))
```

__Figura 1.5__ Probabilidade de não refutar uma SAD neutra observada ~ predita pelo modelo mais plausível.

Observamos que para alguns sítios os valores se aproximam de uma relação linear, como esperado pelo modelo, contudo para outros valores observa-se tendência não lineares onde alguns valores são bem ajustados enquanto outros aumentam e diminuiem. Isso pode indicar que seja mais adequado considerar um modelo que possibilite maior flexibilidade para estimar a tendência global dos dados. 

Em resumo:  
i) O modelo mais plausível apresenta R2_marginal > 80%, porém pouco é explicado pela estrutura fixa do modelo (R2_condicional < 10%);        
ii) Os modelos neutros apresentam variância distinta: enquanto MNEE varia em valores próximos de 98 SADs não refutadas para a maior parte dos sítios, MNEI varia em [0;100].  
iii) O pressuposto de linearidade pode não ser suficiente para estimar a tendência global para todos os sítios de amostragem.  

### Infêrência

Uma avaliação direta da predição de que MNEE pode apresentar melhor congruência para paisagens com proporções intermediárias de cobertura vegetal é a de comparar a inclinação e intercepto do efeito do aumento da dispersão entre os modelos neutros por sítio e então plotar as estimativas pela proporção de cobertura vegetal. 

```{r inferencia n_nRef, warning=FALSE,message=FALSE}
# dados brutos
df_coef.Site <- coef(l_md[["p*d*MN"]])$SiteCode
## arrumando os nomes
df_coef.Site$SiteCode <- row.names(coef(l_md[["p*d*MN"]])$SiteCode) 
row.names(df_coef.Site) <- NULL
names(df_coef.Site) <- c("intercept","p_coef","d_Lplot_coef","MNEI","p__d_Lplot_coef","p__MNEI","d_Lplot__MNEI","p__d_Lplot__MNEI","SiteCode")
# multiplicao pelo respectivo valor de p.z
df_ <- df_coef.Site[,c(2,5,6,8,9)] %>% inner_join(x=.,
                            y=distinct(select(df_resultados,SiteCode,p.z,p)),
                            by="SiteCode") %>% 
  adply(.,1,.fun=function(X) data.frame(coef_p = X$p.z * X$p_coef,
                                        coef_p__d_Lplot = X$p.z * X$p__d_Lplot_coef,
                                        coef_p__MNEI = X$p.z * X$p__MNEI,
                                        coef_p__d_Lplot__MNEI = X$p.z * X$p__d_Lplot__MNEI
                                        )
        )
# merge
df_coef.Site %<>% inner_join(x=.,
                            y=df_[,5:11],
                            by="SiteCode") %>% 
  select(SiteCode, p.z, p, intercept, coef_p, d_Lplot_coef, MNEI, coef_p__d_Lplot, coef_p__MNEI, d_Lplot__MNEI,coef_p__d_Lplot__MNEI)

```


```{r}



# estimativas da estrutura aleatória
df_coef.Site <- ranef(l_md[["p*d*MN"]])$SiteCode
names(df_coef.Site)[c(1,3,4)] <- c("intercept","slope","slope0_MNEI")
df_coef.Site %<>% 
  mutate(intercept_MNEI = intercept + MNEI, slope_MNEI = slope + slope0_MNEI) %>% 
  select(SiteCode,intercept,slope,intercept_MNEI,slope_MNEI)

df_coef.Site <- rbind(
 mutate(filter(gather(df_coef.Site, coef, est, -SiteCode),coef %in% c("(Intercept)","d_Lplot.z")),MN="EE"),
 mutate(filter(gather(df_coef.Site, coef, est, -SiteCode),coef %in% c("MNEI","MNEI:d_Lplot.z")),MN="EI")
)
# arrumando os nomes
df_coef.Site$coef[df_coef.Site$coef %in% c("(Intercept)","MNEI")] = "intercept"
df_coef.Site$coef[df_coef.Site$coef %in% c("(Intercept)","MNEI")] = "intercept"


tidy(l_md[["p*d*MN"]])
```



## Métrica de Congruência alternativa: p-valor

```{r avaliação do p-valor médio}
l_p <- vector("list",2)
l_p[[1]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[1:10]),
                   aes(x=p,y=p.value_mean)) + 
  geom_point() + 
  geom_smooth(method="loess") +
  facet_grid(k~MN)
l_p[[2]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[11:20]),
                   aes(x=p,y=p.value_mean)) + 
  geom_point() + 
  geom_smooth(method="loess") +
  facet_grid(k~MN) 
do.call("grid.arrange",c(l_p,ncol=2)) 
```

A contagem de SADs que apresentam p-valor >= 5% leva à inflação de zeros; quando avaliamos a probabilidade de se obter a estatística D uma vez que a hipótese nula que os dois vetores são amostra de uma mesma distribuição teórica (p-valor) como amostra de congruência observamos que a variância esta melhor distribuida para MNEE. MNEI apresenta valores mais próximos de zero, que na variável n_nRef reflete em grande variação. Assim para a variável n_nRef a variação está melhor distribuida para a variável MNEI e para a variável p-valor a variação. Vou utilizar o modelo cheio para avaliar se para a variável p-valor.

##


### GLMM for p-valor

```{r p_value}
# l_md <- vector("list",5)
# names(l_md) <- c("gamma id","gamma log","gamma inv","normal id","normal log")
# l_md[[1]] <- glmer(p.value_mean ~ p.z*d_Lplot.z*MN + (MN|SiteCode),
                   # data = df_resultados,
                   # family = Gamma(link = identity))
# l_md[[2]] <- glmer(p.value_mean ~ p.z*k_1.z*MN + (k_1.z*MN|SiteCode),
#                    data = df_resultados,
#                    family = Gamma(link = log))
# l_md[[3]] <- glmer(p.value_mean ~ p.z*k_1.z*MN + (k_1.z*MN|SiteCode),
#                    data = df_resultados,
#                    family = Gamma(link = inverse))
md_p.value <- lmer(p.value_mean ~ p.z*d_Lplot.z*MN + (d_Lplot.z*MN|SiteCode),
                   data = df_resultados)
par_md <- getME(md_p.value,c("theta","fixef"))
md_p.value <- lmer(p.value_mean ~ p.z*d_Lplot.z*MN + (d_Lplot.z*MN|SiteCode),
                   data = df_resultados,start = par_md)
p_plot <- DHARMa::simulateResiduals(md_p.value,n=1000)
plot(p_plot)
library(sjPlot)
library(sjlabelled)
library(sjmisc)
library(ggplot2)
sjPlot::tab_model(md_p.value)
```

O modelo que descreve p-valor apresenta R2 marginal pequeno (0.099) e e o R2 condicional aceitável. Porém como os outros modelos ainda não apresenta bom ajuste com os dados.


## GAMM binomial

Alternativamente podemos utilizar generalized additive models para descrever estatisticamente a tendência global dos dados.


gam(cbind(n_nRef,100-n_nRef) ~ s(p.z,by=MN,bs="tp") + s(d_Lplot.z,by=MN,bs="tp") + ti(p.z,d_Lplot.z,by=MN,bs="tp"))


```{r gam binomial n_nRef}
ctrl <- as.list(3)
l_md <- vector("list",3)
names(l_md) <- c("1|SiteCode","MN|SiteCode","MN * disp|SiteCode")
l_md[[1]] <- gam(cbind(n_nRef,100-n_nRef) ~ MN + s(p.z,by=MN,bs="tp") + s(d_Lplot.z,by=MN,bs="tp") + ti(p.z,d_Lplot.z,by=MN,bs="tp") +
                   s(SiteCode,bs="re"),
                 family = "binomial",
                 data = df_resultados, method = "REML",control=ctrl)
l_md[[2]] <- gam(cbind(n_nRef,100-n_nRef) ~ s(p.z,by=MN,bs="tp") + s(d_Lplot.z,by=MN,bs="tp") + ti(p.z,d_Lplot.z,by=MN,bs="tp") +
                   s(SiteCode,by=MN,bs="re"),
                 family = "binomial",
                 data = df_resultados, method = "REML",control=ctrl)
```

```{r}
gratia::draw(l_md[[2]])
gam.check(l_md[[2]])
summary(l_md[[2]])
p_plot <- DHARMa::simulateResiduals(l_md[[1]],n=1000)
plot(p_plot)
```

# U - taxa de especiação necessária para obter a riqueza observada no equilíbrio  

## Padrões Gerais  

```{r padroes gerais U,echo=FALSE,fig.width=6,fig.height=4}
# graficos
l_p <- vector("list",4)
l_p[[1]] <- ggplot(df_resultados,aes(x=k,y=U_med)) + 
  geom_point() +
  geom_line(aes(group=SiteCode)) + 
  geom_boxplot(aes(group=k))
l_p[[2]] <- ggplot(df_resultados,aes(x=p,y=U_med)) +
  geom_point() +
  geom_smooth(method = "auto") +
  labs(y="")
l_p[[3]] <- ggplot(df_resultados,aes(x=log(Stotal),y=U_med)) +
  geom_point() +
  geom_smooth(method = "auto")
l_p[[4]] <- ggplot(df_resultados,aes(x=p,y=log(Stotal))) +
  geom_point() + 
  geom_smooth(method="auto")
do.call("grid.arrange",c(l_p,ncol=2))
```

__Figura 1__ Padrões gerais de U_med: ~ k (% de propágulos até a vizinhança imediata da planta progenitora); ~ Stotal (riqueza observada na área amostral). E o padrão empírico encontrado nos dados Stotal ~ p  
    
  
```{r padroes gerais U por SiteCode,echo=FALSE,fig.height=50,fig.width=12}
# dados
df_plot <- df_resultados %>% select(SiteCode,p,U_med,k,d_Lplot) %>% 
  mutate(label_facet.wrap = paste0(SiteCode,";p=",round(p,4))) %>% 
  distinct() %>% arrange(p)
levels_label <- unique(df_plot$label_facet.wrap)
df_plot$label_facet.wrap <- factor(df_plot$label_facet.wrap,levels = levels_label)
# graficos
l_p <- vector("list",2)
l_p[[1]] <- ggplot(df_plot,aes(x=k,U_med)) +
  geom_point() +
  geom_line(aes(group=SiteCode)) +
  facet_wrap(~label_facet.wrap,ncol=5,scales="free") +
  ggtitle(label="eixo x = k")
l_p[[2]] <- ggplot(df_plot,aes(x=d_Lplot,U_med)) +
  geom_point() +
  geom_line(aes(group=SiteCode)) +
  facet_wrap(~label_facet.wrap,ncol=5,scales="free") +
  ggtitle(label="eixo x = d / L_plot")  
do.call("grid.arrange",c(l_p,ncol=1))
```

__Figura 2__ Padrões gerais de U_med por SiteCode: ~ k (% de propágulos até a vizinhança imediata da planta progenitora); ~ d / L_plot (distância média de dispersão / Lado do área amostral)


## Descrição Estatística:

Para descrever o padrão de U em função da proporção de habitat disponível e da diminuição da limitação de dispersão vamos utilizar GAMM (generalized additive mixed models, Wood 2017). Há pelo menos 3 formas de descrevermos o padrão global (Pedersen et al. 2019): a) um intercepto por SiteCode (1|SiteCode); b) um smoother por SiteCode (dispersão | SiteCode), porém com penalização para aqueles smoothers muito distintos do padrão global; e c) um smoother por SiteCode (dispersão | SiteCode) com seu próprio parâmetro de 'flexibilidade' (smoothing parameter).   
  
GAMM oferecem grande flexibilidade ao custo de aumento do número de parâmetros estimados e do custo computacional, além da perda de interpretabilidade. Então irei começar por um modelo cuja estrutura aleatória é a mais simples possível (1 intercepto por SiteCode) para poder oferecer mais flexibilidade para o tensor(variável_dispersão,p).   

### Seleção de Modelo cheio  

- 2 famílias: gaussian e gamma  
- 3 funções de ligação: identity (apenas para gaussian), log, inverse  
- 2 variáveis concorrentes para descrever a dispersão: (1 - k) e (d/L_plot)  
- log_Stotal.z como preditora linear  
- (1|SiteCode) como estrutura aleatória  

__exemplo de código:__  
gam(U_med ~ s(d_Lplot.z) + s(p.z) + ti(d_Lplot.z,p.z) +  
                      log_Stotal.z +  
                      s(SiteCode,bs="re"),  
                    family="gaussian",  
                    data = df_resultados, method = "REML",control=ctrl)  

__Tabela de Seleção do Modelo Mais plausível:__    

```{r selecao de modelo cheio GAMM(U)}
ctrl <- list(nthreads=3) #número de cores para paralelizar
l_md <- vector("list",length = 15)
names(l_md) <- c("d id normal","d log normal", "d inverse normal", "d log gamma", "d inverse gamma",
                 "1-k id normal","1-k log normal", "1-k inverse normal", "1-k log gamma", "1-k inverse gamma",
                 "k.f id normal","k.f log normal", "k.f inverse normal", "k.f log gamma", "k.f inverse gamma")
l_md[[1]] <- gam(U_med ~ s(d_Lplot) + s(p) + ti(d_Lplot,p) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family="gaussian",
                data = df_resultados.U, method = "REML",control=ctrl)
l_md[[2]] <- gam(U_med ~ s(d_Lplot) + s(p) + ti(d_Lplot,p) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=gaussian(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md[[3]] <- gam(U_med ~ s(d_Lplot) + s(p) + ti(d_Lplot,p) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=gaussian(link = "inverse"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md[[4]] <- gam(U_med ~ s(d_Lplot) + s(p) + ti(d_Lplot,p) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md[[5]] <- gam(U_med ~ s(d_Lplot) + s(p) + ti(d_Lplot,p) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "inverse"),
                data = df_resultados.U, method = "REML",control=ctrl)
# k_1 
l_md[[6]] <- gam(U_med ~ s(k.0_1) + s(p) + ti(k.0_1,p) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family="gaussian",
                data = df_resultados.U, method = "REML",control=ctrl)
l_md[[7]] <- gam(U_med ~ s(k.0_1) + s(p) + ti(k.0_1,p) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=gaussian(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md[[8]] <- gam(U_med ~ s(k.0_1) + s(p) + ti(k.0_1,p) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=gaussian(link = "inverse"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md[[9]] <- gam(U_med ~ s(k.0_1) + s(p) + ti(k.0_1,p) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md[[10]] <- gam(U_med ~ s(k.0_1) + s(p) + ti(k.0_1,p) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "inverse"),
                data = df_resultados.U, method = "REML",control=ctrl)
# k.f 
l_md[[11]] <- gam(U_med ~ s(p,k,bs="fs") + k +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family="gaussian",
                data = df_resultados.U, method = "REML",control=ctrl)
l_md[[12]] <- gam(U_med ~ s(p,k,bs="fs") + k +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=gaussian(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md[[13]] <- gam(U_med ~ s(p,k,bs="fs") + k +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=gaussian(link = "inverse"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md[[14]] <- gam(U_med ~ s(p,k,bs="fs") + k +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md[[15]] <- gam(U_med ~ s(p,k,bs="fs") + k +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "inverse"),
                data = df_resultados.U, method = "REML",control=ctrl)
AICctab(l_md,weights = TRUE)
```

O modelos cheio mais plausível possui família Gamma e função de ligação 'log" e utiliza a preditora d / L_plot.

### Auditoria do modelo cheio mais plausível

<!-- Protocolo de Wood (in Checking and Selecting GAMs): -->

<!-- 1) Residual Checking:   -->
<!-- a) fitted ~ residuals (1|SiteCode) -->
<!-- a) fitted ~ residuals (1|SiteCode) -->
<!-- b) residuals ~ preditoras   -->

```{r auditoria md mais plausivel U 01} 
# Dados
md_U <- l_md[["d log gamma"]]
# summary(md_U)
## gam.check
par(mfrow=c(2,2))
gam.check(md_U)
## intercepto por sitecode
df_ <- data.frame(term=names(coef(l_md[[1]])),coef=as.numeric(coef(l_md[[1]])))
df_ %>% filter(grepl("SiteCode",term)) %>% ggplot(aes(x="",y=coef)) + 
  geom_boxplot() + geom_jitter()
# df_ %>% filter(grepl("SiteCode",term)) %>% summary
```

__Figura 3__ gam.check(modelo cheio mais plausível)  


```{r auditoria md mais plausivel U 2,warning=FALSE,message=FALSE}
p_plot <- DHARMa::simulateResiduals(md_U,n=1000)
plot(p_plot)
```

__Figura 3.2__ DHARMa::simulateResiduals(modelo cheio mais plausível)


O Modelo mais plausível diverge do pressuposto de que a variável resposta pode ser aproximada por uma distribuição Gamma(link=log) para ambos diagnósticos. O gam.check indica que k=9 não é suficiente para modelar a variável d/L_plot.  
  
Segue avaliação dos efeitos:  
  

<!-- o que são os efeitos estimados? -->

```{r auditoria md_U mais plausível U 3,fig.width=12}
gratia::draw(md_U)
par(mfrow=c(2,2))
plot(md_U)
```

__Figura 4__ gratia::draw(md_U)

A função que plota o gráfico dos efeitos acusa um erro: Removed 951 rows containing non-finite values (stat_contour). Esse problema decorreria de U_med->0 que na escala log -> a infinito? O quê de fato esta sendo plotado?[ESTUDAR] draw.derivates()?  


__tabela __ Concurvidade dos smoothers

```{r concurvidade md_U}
concurvity(md_U,full = TRUE)
```

Os três indices variam entre 0 e 1, quando igual a 1 então o smoother apresenta concurvidade com algum outro smoother. O intercepto geral ('para'), o smoother de s(p) e o smoother s(log_Stotal) apresenta concurvidade 



```{r auditoria md_U 4}
df_ <- augment(md_U) %>% mutate(.predict=exp(.fitted))
# gráficos exploratórios
par(mfrow=c(1,2))
hist(df_$.predict,breaks = 60)
hist(df_resultados.U$U_med,breaks = 60)
#
summary(df_)
```

__Figura 5.1__ 

O summary da tabela de md_U mostra que tanto U_med como o predito (na escala de U_med) estão dentro do esperado: valores positivos entre 0 e 1. O aviso de erro pode ser resultado do uso da função stat_contour (OLHAR HELP).


```{r auditoria predicao md_U mais plausivel,fig.height=30,fig.width=12}
# graficos por sitecode
ggplot(df_,aes(x=.predict,y=U_med)) +
  geom_point() +
  geom_abline(slope = 1,intercept=0,color="red") +
  geom_smooth(method="auto") +
  facet_wrap(~SiteCode,ncol=5,scales = "free")
```

__Figura 5.2__ Observado X Predito U ~ s(%d.z) + s(p.z) + ti(%d.z,p.z) + log_Stotal.z + s(SiteCode,bs="re")  
  
  
Para alguns sítios observa-se que a nuvem dos pontos se aproxima à reta, contudo para outros sítios o smoother global não descreve o padrão não-linear  (figura 5.2). Uma possibilidade é ajustar um smoother por SiteCode: a) compartilhando um mesmo parâmetro de penalidade (menor flexibilidade); b) com uma réplica do smoother global para cada sítio (mais flexível, muito mais oneroso computacionalmente).

Em resumo, o modelo mais plausível i) não pode ser aproximado por uma distribuição Gamma com função de ligação log; e o smoother s(p) apresenta concurvidade com outros smoothers. Há formas alternativas de modelar a relação dispersão * p: te(dispersão,p) e t2(dispersão,p). 

```{r md_U comparacao s+ti te e t2}
# Dados
l_md <- vector("list",5)
names(l_md) <- c("s+ti","s + s","s(d) + ti(d,p)","te","t2")
l_md[[1]] <- gam(U_med ~ s(d_Lplot.z) + s(p.z) + ti(d_Lplot.z,p.z) +
                  log_Stotal.z +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados.U, method = "REML",control=as.list(3))
l_md[[2]] <- gam(U_med ~ s(d_Lplot.z) + s(p.z) +
                  log_Stotal.z +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados.U, method = "REML",control=as.list(3))
l_md[[3]] <- gam(U_med ~ s(d_Lplot.z) + ti(d_Lplot.z,p.z) +
                  log_Stotal.z +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados.U, method = "REML",control=as.list(3))
l_md[[4]] <- gam(U_med ~ te(d_Lplot.z,p.z) +
                  log_Stotal.z +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados.U, method = "REML",control=as.list(3))
l_md[[5]] <- gam(U_med ~ t2(d_Lplot.z,p.z) +
                  log_Stotal.z +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados.U, method = "REML",control=as.list(3))
AICctab(l_md,weights=T)
```


O único modelo plausível, somando 0.82 do peso de evidência, pressupóem o smoother individual de d/L_plot e o tensor entre d/L_plot e de p; o segundo modelo mais plausível, com 0.18 de peso de evidência, considera adicionalmente o smoother individual para p. Os modelos com tensores te e t2 apresentam menos parâmetros porém não estão dentro do intervalo de plausibilidade; o modelo menos plausível considera os smoothers indivíduais de d/L_plot e p, mas desconsidera o tensor das preditoras. Os resultados corroboram o hipótese de que o smoother individual de p é concurvo ao tensor de d e p. Segue auditoria do modelo mais plausível:


```{r auditoria 1 s(d)+ti(d,p)}
par(mfrow=c(2,2))
gam.check(l_md[["s(d) + ti(d,p)"]])
```


```{r auditoria 2 s(d)+ti(d,p)}
p_plot <- DHARMa::simulateResiduals(l_md[["s(d) + ti(d,p)"]],n=1000)
plot(p_plot)
```

Ambos diagnostico apontam que o pressuposto de distribuição gamma com função de ligação log não é uma boa aproximação, e pela comparação com o modelo anterior o ajuste do modelo com relação ao segundo mais plausível piorou. Segue avaliação dos efeitos:  
  

```{r auditoria 3 s(d)+ti(d,p)}
gratia::draw(l_md[["s(d) + ti(d,p)"]])
# gratia::draw(l_md[["s+ti"]])
```
  
O gráfico de efeitos do smoother de d/L_plot mostra que o desvio padrão da estimativa aumenta com o aumento do preditor. Idealmente deveria ser homogeneo ao longo do gradite do preditor (REF). Segue avaliaão da concurvidade entre os smoothers:  
  
```{r auditoria 4 s(d)+ti(d,p)}
concurvity(l_md[["s(d) + ti(d,p)"]])
```

O diagnostico de concurvidade indica que não há problemas. Ainda há possibilidade de aumentar o número de funções bases para ajustar o padrão, pois gam.check indica que talvez seja necessário aumentar o número de funções base para o smoother de d/L_plot

```{r auditoria 5 s(d) + ti(d,p)}
l_md[[3]] <- gam(U_med ~ s(d_Lplot.z,k=10) + ti(d_Lplot.z,p.z) +
                  log_Stotal.z +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados.U, method = "REML",control=as.list(3))
gam.check(l_md[[3]]) 
gratia::draw(l_md[[3]])
```

Para k maiores (20,40) o diagnóstico da gam.check continua indicando que k não é suficiente, porem ao aumentar k promove o aumento de sobreajuste do modelo sem melhoras no pressuposto de distribuição gamma com função de ligação log.  


#### Exploração de outras estruturas aleatórias

```{r estruturas aleatorias alternativas U_med d}
l_md <- vector("list",2)
names(l_md) <- c("(1|SiteCode)","d|SiteCode,lambda comum") #,"d|SiteCode,lambda por SiteCode")
l_md[[1]] <- gam(U_med ~ s(d_Lplot.z) + ti(d_Lplot.z,p.z) +
                  log_Stotal.z +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados.U, method = "REML",control=as.list(3))
l_md[[2]] <- gam(U_med ~ s(d_Lplot.z) + ti(d_Lplot.z,p.z) +
                  log_Stotal.z +
                  s(d_Lplot.z,SiteCode,bs="fs",m=2),
                family=Gamma(link = "log"),
                data = df_resultados.U, method = "REML",control=as.list(3))
# l_md[[3]] <- gam(U_med ~ s(d_Lplot.z) + ti(d_Lplot.z,p.z) +
#                   log_Stotal.z +
#                   s(d_Lplot.z,by=SiteCode,m=1) + s(SiteCode,bs="re"),
#                 family=Gamma(link = "log"),
#                 data = df_resultados.U, method = "REML",control=as.list(3))
AICctab(l_md,weights=TRUE)
```

O modelo que permite um smoother de dispersão por sitecode com lambda comum é o mais plausível. Segue auditoria do modelo:

```{r auditoria 1 d|SiteCode lambda comum}
par(mfrow=c(2,2))
gam.check(l_md[[2]])
```


```{r auditoria 2 d|SiteCode lambda comum}
p_plot <- DHARMa::simulateResiduals(l_md[[2]],n=1000)
plot(p_plot)
```

Observa-se piora na adequação ao pressuposto de distribuição gamma(link=log)

```{r auditoria 3 d|SiteCode lambda comum}
gratia::draw(l_md[[2]])
```


#### Alternativas de configuração de gam  
  
i) mudança no tipo de funções base utilizada, o método padrão é o ts (thin plate regression spline).  
ii) modificar em qual grau da derivada a flexibilidade do smoother é penalizada.  

Como ii é feito por padrão, vou explorar i. O modelo que considera os smoothers indivíduais de d e p vai ser usado na exploração dos tipos de smoother. 

opções:

1) tp; 2) ts; 3) ds; 4) cr; cc; cs; 5) sos; cp; 6) mrf; 7) gp; 8) so; sw; sf 

```{r comparação entre tipos de smoothers,include=FALSE,echo=FALSE}
l_md <- vector("list",)
names(l_md) <- c()

```



<!-- __t2__ -->

<!-- ```{r auditoria 1 t2} -->
<!-- par(mfrow=c(2,2)) -->
<!-- gam.check(l_md[["t2"]]) -->
<!-- ``` -->


<!-- ```{r auditoria 2 t2} -->
<!-- p_plot <- DHARMa::simulateResiduals(l_md[["t2"]],n=1000) -->
<!-- plot(p_plot) -->
<!-- ``` -->

<!-- Ambos diagnostico apontam que o pressuposto de distribuição gamma com função de ligação log não é uma boa aproximação, e pela comparação com o modelo anterior o ajuste do modelo com relação ao segundo mais plausível piorou. Segue avaliação dos efeitos:   -->


<!-- ```{r auditoria 3 t2} -->
<!-- gratia::draw(l_md[["t2"]]) -->
<!-- ``` -->

<!-- O gráfico de efeitos do smoother de d/L_plot mostra que o desvio padrão da estimativa aumenta com o aumento do preditor. Idealmente deveria ser homogeneo ao longo do gradite do preditor (REF). Segue avaliaão da concurvidade entre os smoothers:   -->

<!-- ```{r auditoria 4 t2} -->
<!-- concurvity(l_md[["t2"]]) -->
<!-- ``` -->

<!-- __te__ -->

<!-- ```{r auditoria 1 te} -->
<!-- par(mfrow=c(2,2)) -->
<!-- gam.check(l_md[["te"]]) -->
<!-- ``` -->


<!-- ```{r auditoria 2 te} -->
<!-- p_plot <- DHARMa::simulateResiduals(l_md[["te"]],n=1000) -->
<!-- plot(p_plot) -->
<!-- ``` -->


<!-- ```{r auditoria 3 te} -->
<!-- gratia::draw(l_md[["te"]]) -->
<!-- ``` -->


<!-- ```{r auditoria 4 te} -->
<!-- concurvity(l_md[["te"]]) -->
<!-- ``` -->


<!-- __s+s__ -->

<!-- ```{r auditoria 1 s + s} -->
<!-- par(mfrow=c(2,2)) -->
<!-- gam.check(l_md[["s + s"]]) -->
<!-- ``` -->


<!-- ```{r auditoria 2 s+s} -->
<!-- p_plot <- DHARMa::simulateResiduals(l_md[["s + s"]],n=1000) -->
<!-- plot(p_plot) -->
<!-- ``` -->


<!-- ```{r auditoria 3 s+s} -->
<!-- gratia::draw(l_md[["s + s"]]) -->
<!-- ``` -->


<!-- ```{r auditoria 4 s+s} -->
<!-- concurvity(l_md[["s + s"]]) -->
<!-- ``` -->




<!-- <!-- O Modelo mais plausível diverge do pressuposto de que a variável resposta pode ser aproximada por uma distribuição Gamma(link=log) para ambos diagnósticos.   --> -->
<!-- <!-- Uma abordagem é avaliar as diferentes configurações que os smoothers podem ter (Pederson et al. 2019): a) número de funções bases e/ou local dos knots; b) os tipos de smoothers para utilizar (cubic ou thin plate regression spline)[QUAIS OUTROS EU POSSO APLICAR?]; c) determinar em qual derivada a penalização sera feita (importante para evitar curcuvidade entre smooothers como do smoother global e aquele por Sitecode); d) modificar a "estrutura" aleatória (figura 4 Perdesen et al. 2017). O maquinário de ajuste de GAM no R já estima o número ótimo de funções base (?,Pedersen et al. 2019,?Wood 2017?), então esta será a última opção a ser explorada (?). --> -->

<!-- ```{r md_U comparacao entre smoothers1,echo=TRUE,include=FALSE,eval=FALSE} -->
<!-- l_md <- vector("list",4) -->
<!-- names(l_md) <- c("tp","cr tp cr","tp cr tp", "tp tp cr") -->
<!-- l_md[[1]] <- gam(U_med ~ s(d_Lplot.z,bs="tp") + s(p.z,bs="tp") + ti(d_Lplot.z,p.z,bs="tp") + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=as.list(3)) -->
<!-- # não rodou -->
<!-- # l_md[[2]] <- gam(U_med ~ s(d_Lplot.z,bs="cr") + s(p.z,bs="cr") + ti(d_Lplot.z,p.z,bs="cr") + -->
<!-- #                   log_Stotal.z + -->
<!-- #                   s(,SiteCode,bs="re"), -->
<!-- #                 family=Gamma(link = "log"), -->
<!-- #                 data = df_resultados, method = "REML",control=as.list(3)) -->
<!-- l_md[[2]] <- gam(U_med ~ s(d_Lplot.z,bs="cr") + s(p.z,bs="tp") + ti(d_Lplot.z,p.z,bs="cr") + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=as.list(3)) -->
<!-- l_md[[3]] <- gam(U_med ~ s(d_Lplot.z,bs="tp") + s(p.z,bs="cr") + ti(d_Lplot.z,p.z,bs="tp") + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=as.list(3)) -->
<!-- l_md[[4]] <- gam(U_med ~ s(d_Lplot.z,bs="tp") + s(p.z,bs="tp") + ti(d_Lplot.z,p.z,bs="cr") + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=as.list(3)) -->
<!-- ## tabela de seleção ## -->
<!-- ## Pedersen et al. 2017. Support Information -->
<!-- # AIC_table <- AIC(l_md[[1]],l_md[[2]],l_md[[3]],l_md[[4]],l_md[[5]]) %>% -->
<!-- #   rownames_to_column(var= "Model")%>% -->
<!-- #   mutate(data_source = rep(c("CO2","bird_data"), each =5))%>% -->
<!-- #   group_by(data_source)%>% -->
<!-- #   mutate(deltaAIC = AIC - min(AIC))%>% -->
<!-- #   ungroup()%>% -->
<!-- #   dplyr::select(-data_source)%>% -->
<!-- #   mutate_at(.vars = vars(df,AIC, deltaAIC),  -->
<!-- #             .funs = funs(round,.args = list(digits=0))) -->
<!-- AICctab(l_md,weights=TRUE) -->
<!-- gam.check(l_md[[2]]) -->
<!-- # p_plot <- DHARMa::simulateResiduals(l_md[[6]]$mer,n = 1000) -->
<!-- # plot(p_plot) -->
<!-- gratia::draw(l_md[[3]]) -->
<!-- ``` -->

<!-- Utilizar bs="cr" para a variável d e para o tensor entre p e d; e utilizar bs="tp" é o método mais plausível. Porém o smoother s(d) descreve um padrão que não observo nos dados: uma fase polinomial para dispersão baixa. Notariamente para ambas preditoras k e d há uma fase logistica no começo e então uma fase polinomial para distâncias altas.  -->

<!-- <!--O padrão descrito pelo smoother pode ser resultado da interpolação entre diferentes curvas cubicas que tentam acertas a fase de mudança brusca da logistica para sítios que apresentam diferentes 'ranges' de d.--> -->

<!-- <!-- 1) bs=“tp” Thin plane regression spline (TPRS) Advantages: Can smooth wrt any number of covariates;invariant to rotation of covariate axes ;can select penalty order; No knots and some optimality properties Disadvantages: Computationally costly for large data sets. Not invariant to covariate rescaling.   --> -->
<!-- <!-- 2) bs=“ts” TPRS with Shrinkage. Advantages: As TPRS, but smothness can zero term completely. Disadvantages: Same as TRRS   --> -->
<!-- <!-- 3) bs=“cr” Cubic Regression Spline (CRS). Advantages: Computationally cheap. Directly interpretable parameters.(JR: but seriously, don’t interpret the parameters) Disadvantages: Can only smooth wrt to 1 covariate. Knot based. Doesn’t have have TPRS optimality.   --> -->
<!-- <!-- 4) bs=“cs” CRS with Shrinkage. Advantages: AS CRS, but smoothness can go to zero completely Disadvantages: AS CRS   --> -->
<!-- <!-- 5) bs=“cc” Cyclic CRS. Advantages: AS CRS, but start point same as end point. Disadvantages: As CRS.   --> -->
<!-- <!-- 6) bs=“pp” P-splines. Advantages: Any combination of basis and penality order available. Perform well in tensor products. Disadvantages: Based on equally spaced knots. Penalties awkward to intepret. No optimality properties available.   --> -->

<!-- <!-- A smoother que parece  --> -->

<!-- ```{r md_U comparação entre smoothers2,echo=FALSE,include=FALSE,eval=FALSE} -->
<!-- l_md <- vector("list",4) -->
<!-- names(l_md) <- c("tp","ts","cr","cs","pp", -->
<!--                  "tp","ts","cr","cs","pp", -->
<!--                  "cr tp cr","tp cr tp", "tp tp cr") -->
<!-- l_md[[1]] <- gam(U_med ~ s(d_Lplot.z,bs="tp") + s(p.z,bs="tp") + ti(d_Lplot.z,p.z,bs="tp") + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=as.list(3)) -->
<!-- l_md[[1]] <- gam(U_med ~ s(d_Lplot.z,bs="tp") + s(p.z,bs="tp") + ti(d_Lplot.z,p.z,bs="tp") + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=as.list(3)) -->

<!-- ``` -->




<!-- ```{r atualizacao de l_md.U.3,echo=FALSE,include=FALSE,eval=FALSE} -->
<!-- teste_md.U <- gam(U_med ~ s(d_Lplot.z,bs="cr",k = 40) + s(p.z,bs="tp") + ti(d_Lplot.z,p.z,bs="cr") + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=as.list(3)) -->
<!-- gam.check(teste_md.U) -->
<!-- ``` -->

<!-- O valor padrão de k=9, utilizei duas alternativas: k=20 e k=40. Para ambas o número de k parece ser insuficiente (k-edf->0 e p-valor<2e-16), isso pode indicar que seja necessário considerar um smoother por sitecode. Alternativamente vou primeiro avaliar se a variável k pode ser aproximada por uma distribuição Gamma(link=log), o segundo modelo mais plausível. Além disso há formas alternativamente de se especificar o tensor entre as variáveis continuas (s+ti,te,t2). -->

<!-- ```{r auditoria md mais plausivel U 1,echo=FALSE,include=FALSE,eval=FALSE} -->
<!-- # Dados -->
<!-- l_md <- vector("list",6) -->
<!-- names(l_md) <- c("d s+ti","d te","d t2", -->
<!--                  "1-k s+ti","1-k te","1-k t2") -->
<!-- l_md[[1]] <- gam(U_med ~ s(d_Lplot.z,bs="cr") + s(p.z,bs="tp") + ti(d_Lplot.z,p.z,bs="cr") + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--             data = df_resultados, method = "REML",control=as.list(3)) -->
<!-- l_md[[2]] <- gam(U_med ~ te(d_Lplot.z,p.z,bs=c("cr","tp")) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--             data = df_resultados, method = "REML",control=as.list(3)) -->
<!-- l_md[[3]] <- gam(U_med ~ t2(d_Lplot.z,p.z,bs=c("cr","tp")) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--             data = df_resultados, method = "REML",control=as.list(3)) -->
<!-- l_md[[4]] <- gam(U_med ~ s(k_1.z,bs="cr") + s(p.z,bs="tp") + ti(k_1.z,p.z,bs="cr") + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--             data = df_resultados, method = "REML",control=as.list(3)) -->
<!-- l_md[[5]] <- gam(U_med ~ te(k_1.z,p.z,bs=c("cr","tp")) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--             data = df_resultados, method = "REML",control=as.list(3)) -->
<!-- l_md[[6]] <- gam(U_med ~ t2(k_1.z,p.z,bs=c("cr","tp")) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--             data = df_resultados, method = "REML",control=as.list(3)) -->
<!-- AICctab(l_md,weights=TRUE) -->
<!-- ``` -->

<!-- A variável d é sempre a mais plausível e o único modelo dentro do intervalo de plausibilidade é 'd s+ti'. Vou avaliar os modelos para entender como os modelos estão se comportando em função das variáveis.  -->


<!-- __d s+ti, dAICc = 0__   -->

<!-- ```{r auditoria dos modelos segundo o rank md_U segunda tentativa 0,echo=FALSE,include=FALSE,eval=FALSE} -->
<!-- par(mfrow=c(2,2)) -->
<!-- gam.check(l_md[["d s+ti"]]) -->
<!-- # par(mfrow=c(2,2)) -->
<!-- gratia::draw(l_md[["d s+ti"]]) -->
<!-- ``` -->



<!-- __d t2, dAICc = 1073.0__   -->

<!-- ```{r auditoria dos modelos segundo o rank md_U segunda tentativa 1,echo=FALSE,include=FALSE,eval=FALSE} -->
<!-- par(mfrow=c(2,2)) -->
<!-- gam.check(l_md[["d t2"]]) -->
<!-- # par(mfrow=c(1,2)) -->
<!-- gratia::draw(l_md[["d t2"]]) -->
<!-- ``` -->



<!-- __d te, dAICc = 1079.0__   -->

<!-- ```{r auditoria dos modelos segundo o rank md_U segunda tentativa 2,echo=FALSE,include=FALSE,eval=FALSE} -->
<!-- par(mfrow=c(2,2)) -->
<!-- gam.check(l_md[["d te"]]) -->
<!-- # par(mfrow=c(1,2)) -->
<!-- gratia::draw(l_md[["d te"]]) -->
<!-- ``` -->


<!-- __1-k s+ti, dAICc = 1285.2__   -->

<!-- ```{r auditoria dos modelos segundo o rank md_U segunda tentativa 3,echo=FALSE,include=FALSE,eval=FALSE} -->
<!-- par(mfrow=c(2,2)) -->
<!-- gam.check(l_md[["1-k s+ti"]]) -->
<!-- par(mfrow=c(2,2)) -->
<!-- # plot(l_md[["1-k s+ti"]],scheme=2) -->
<!-- gratia::draw(l_md[["1-k s+ti"]]) -->
<!-- ``` -->

<!-- __1-k te, dAICc = 1557.6__   -->

<!-- ```{r auditoria dos modelos segundo o rank md_U segunda tentativa 4,echo=FALSE,include=FALSE,eval=FALSE} -->
<!-- par(mfrow=c(2,2)) -->
<!-- gam.check(l_md[["1-k te"]]) -->
<!-- par(mfrow=c(2,2)) -->
<!-- gratia::draw(l_md[["1-k te"]]) -->
<!-- ``` -->


<!-- O modelo apresenta problemas semelhantes ao modelo mais plausível com a preditora d / L_plot e a mesma estrutura aleatória. O smoother de k descreve melhor o padrão: fase logistica + fase polinomial.  -->















<!-- ```{r comparação md_U para estruturas as 3 estruturas aleatórias propostas por Pedersen et al. 2017,echo=FALSE,include=FALSE,eval=FALSE} -->
<!-- l_md <- vector("list",3) -->
<!-- names(l_md) <- c("(1|SiteCode)","d|SiteCode,lambda comum","d|SiteCode,lambda por SiteCode") -->
<!-- l_md[[1]] <- gam(U_med ~ s(d_Lplot.z,bs="cr",m=2) + s(p.z,bs="tp",m=2) + ti(d_Lplot.z,p.z,bs="cr",m=2) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=as.list(3)) -->
<!-- l_md[[2]] <- gam(U_med ~ s(d_Lplot.z,bs="cr",m=2) + s(p.z,bs="tp",m=2) + ti(d_Lplot.z,p.z,bs="cr",m=2) + -->
<!--                   log_Stotal.z + -->
<!--                   s(d_Lplot.z,SiteCode,bs="fs",m=2), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=as.list(3)) -->
<!-- l_md[[3]] <- gam(U_med ~ s(d_Lplot.z,bs="cr",m=2) + s(p.z,bs="tp",m=2) + ti(d_Lplot.z,p.z,bs="cr",m=2) + -->
<!--                   log_Stotal.z + -->
<!--                   s(d_Lplot.z,by=SiteCode,bs="cr",m=1) + s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=as.list(3)) -->
<!-- AICctab(l_md) -->
<!-- md_U <- l_md[[3]] -->
<!-- par(mfrow=c(2,2)) -->
<!-- # mtext("teste") -->
<!-- gam.check(md_U) -->
<!-- plot(md_U) -->
<!-- ``` -->


<!-- O modelo que apresenta um smoother e parâmetro de penalização por SiteCode é o mais plausível. Contudo ele apresenta uma piora quanto ao pressupoto de distribuição Gamma com função de ligação log. Olhando os efeitos estimados e seus intervalos de confiança para cada preditora, observamos funções próximas a retas e o intervalo de confiança ao redor das estimavas apresentam padrão em "X": para d_Lplot.z -> 0 (para a média da distribuição), há diminuição da variação ao redor da estimativa e para d_Lplot.z -> 5 há gradual aumento no intervalo ao redor da estimativa. Isso pode indicar que há grande 'concurvity', o smoother global e por SiteCode apresentam 'colinearideda não linear'. Além disso, não observei melhora na descrição do padrão observado, uma vez que a maior parte dos smoothers assemelha-se à uma reta e o pressuposto de distribuição Gamma com função de ligação log não parece adequado.     -->
<!-- Alternativamente vou repetir os passos utilizando a variável k, que apresentam igual espaçamente entre os pontos de limitação de dispersão para todos os sítios. Com isso perco a informação da dispersão média em função da extensão da comunidade local, porém simplifica o padrão.    -->


<!-- ## Descrição Estatística: ~ k -->

<!-- O Modelo com distribuição Gamma e função de ligação log com a preditora k foi o segundo modelo mais plausível, apesar de ser mais de 300 vezes menos plausível, que pode em parte ser explicado por apresentar mais 4 parâmetros (tabela 1).  -->


<!-- ```{r descrição preliminar de U_med em funcao de k,echo=FALSE,include=FALSE,eval=FALSE} -->
<!-- l_p <- vector("list",3) -->
<!-- l_p[[1]] <- ggplot(df_resultados,aes(x=k,y=U_med)) + -->
<!--   geom_point() + -->
<!--   geom_line(aes(group=SiteCode)) + -->
<!--   geom_boxplot(aes(group=k)) -->
<!-- l_p[[2]] <- ggplot(df_resultados,aes(x=k.z,y=U_med)) + -->
<!--   geom_point() + -->
<!--   geom_line(aes(group=SiteCode)) + -->
<!--   geom_boxplot(aes(group=k)) -->
<!-- l_p[[3]] <- ggplot(df_resultados,aes(x=k_1.z,y=U_med)) + -->
<!--   geom_point() + -->
<!--   geom_line(aes(group=SiteCode)) + -->
<!--   geom_boxplot(aes(group=k)) -->
<!-- do.call("grid.arrange",c(l_p,ncol=3)) -->
<!-- ``` -->

<!-- ```{r auditoria md mais plausivel U 001,echo=FALSE,include=FALSE,eval=FALSE} -->
<!-- # Dados -->
<!-- md_U <- gam(U_med ~ s(k_1.z) + s(p.z) + ti(k_1.z,p.z) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--             data = df_resultados, method = "REML",control=as.list(3)) # "d log gamma" -->

<!-- summary(md_U) -->
<!-- par(mfrow=c(2,2)) -->
<!-- gam.check(md_U) -->
<!-- plot(md_U) -->
<!-- ``` -->

<!-- O modelo apresenta problemas semelhantes ao modelo mais plausível com a preditora d / L_plot e a mesma estrutura aleatória. O smoother de k descreve melhor o padrão: fase logistica + fase polinomial.  -->

<!-- ```{r comparação md_U para estruturas as 3 estruturas aleatórias propostas por Pedersen et al. 2017 00,echo=FALSE,include=FALSE,eval=FALSE} -->
<!-- l_md <- vector("list",3) -->
<!-- names(l_md) <- c("(1|SiteCode)","k|SiteCode,lambda comum","k|SiteCode,lambda por SiteCode") -->
<!-- l_md[[1]] <- gam(U_med ~ s(k_1.z,bs="cr",m=2) + s(p.z,bs="tp",m=2) + ti(k_1.z,p.z,bs="cr",m=2) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=as.list(3)) -->
<!-- l_md[[2]] <- gam(U_med ~ s(k_1.z,bs="cr",m=2) + s(p.z,bs="tp",m=2) + ti(k_1.z,p.z,bs="cr",m=2) + -->
<!--                   log_Stotal.z + -->
<!--                   s(k_1.z,SiteCode,bs="fs",m=2), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=as.list(3)) -->
<!-- l_md[[3]] <- gam(U_med ~ s(k_1.z,bs="cr",m=2) + s(p.z,bs="tp",m=2) + ti(k_1.z,p.z,bs="cr",m=2) + -->
<!--                   log_Stotal.z + -->
<!--                   s(k_1.z,by=SiteCode,bs="cr",m=1) + s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=as.list(3)) -->
<!-- AICctab(l_md) -->
<!-- md_U <- l_md[[2]] -->
<!-- par(mfrow=c(2,2)) -->
<!-- gam.check(md_U) -->
<!-- plot(md_U) -->


<!-- df_md.U <- evaluate_smooth(md_U) -->

<!-- ``` -->



<!-- ### Exploração alternativamente dos smoothers -->

<!-- ```{r selecao de modelo cheio GAMM(U) 0,echo=FALSE,include=FALSE,eval=FALSE} -->
<!-- ctrl <- list(nthreads=3) #número de cores para paralelizar -->
<!-- l_md <- vector("list",length = 10) -->
<!-- names(l_md) <- c("d id normal","d log normal", "d inverse normal", "d log gamma", "d inverse gamma", -->
<!--                  "k id normal","k log normal", "k inverse normal", "k log gamma", "k inverse gamma") -->
<!-- l_md[[1]] <- gam(U_med ~ te(d_Lplot.z,p.z,bs=c("cr","tp")) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family="gaussian", -->
<!--                 data = df_resultados, method = "REML",control=ctrl) -->
<!-- l_md[[2]] <- gam(U_med ~ te(d_Lplot.z,p.z,bs=c("cr","tp")) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=gaussian(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=ctrl) -->
<!-- l_md[[3]] <- gam(U_med ~ te(d_Lplot.z,p.z,bs=c("cr","tp")) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=gaussian(link = "inverse"), -->
<!--                 data = df_resultados, method = "REML",control=ctrl) -->
<!-- l_md[[4]] <- gam(U_med ~ te(d_Lplot.z,p.z,bs=c("cr","tp")) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=ctrl) -->
<!-- l_md[[5]] <- gam(U_med ~ te(d_Lplot.z,p.z,bs=c("cr","tp")) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "inverse"), -->
<!--                 data = df_resultados, method = "REML",control=ctrl) -->
<!-- # k_1.z -->
<!-- l_md[[6]] <- gam(U_med ~ te(k_1.z,p.z,bs=c("cr","tp")) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family="gaussian", -->
<!--                 data = df_resultados, method = "REML",control=ctrl) -->
<!-- l_md[[7]] <- gam(U_med ~ te(k_1.z,p.z,bs=c("cr","tp")) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=gaussian(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=ctrl) -->
<!-- l_md[[8]] <- gam(U_med ~ te(k_1.z,p.z,bs=c("cr","tp")) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=gaussian(link = "inverse"), -->
<!--                 data = df_resultados, method = "REML",control=ctrl) -->
<!-- l_md[[9]] <- gam(U_med ~ te(k_1.z,p.z,bs=c("cr","tp")) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=ctrl) -->
<!-- l_md[[10]] <- gam(U_med ~ te(k_1.z,p.z,bs=c("cr","tp")) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "inverse"), -->
<!--                 data = df_resultados, method = "REML",control=ctrl) -->
<!-- AICctab(l_md,weights = TRUE) -->
<!-- ``` -->

<!-- Mesmo resultado -->

<!-- ```{r em construcao,echo=FALSE,include=FALSE,eval=FALSE} -->
<!-- par(mfrow=c(2,2)) -->
<!-- gam.check(l_md[[9]]) -->
<!-- gratia::draw(l_md[[4]]) -->

<!-- l_md <- vector("list",6) -->
<!-- l_md[[1]] <- gam(U_med ~ t2(d_Lplot.z,p.z,bs=c("cr","tp")) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=ctrl) -->
<!-- l_md[[2]] <- gam(U_med ~ te(d_Lplot.z,p.z,bs=c("cr","tp")) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=ctrl) -->
<!-- l_md[[3]] <- gam(U_med ~ s(d_Lplot.z,bs="cr") + s(p.z,bs="tp") + ti(d_Lplot.z,p.z,bs="cr") + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=ctrl) -->
<!-- l_md[[4]] <- gam(U_med ~ te(k_1.z,p.z,bs=c("cr","tp")) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=ctrl) -->
<!-- l_md[[5]] <- gam(U_med ~ te(k_1.z,p.z,bs=c("cr","tp")) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=ctrl) -->
<!-- l_md[[6]] <- gam(U_med ~ te(k_1.z,p.z,bs=c("cr","tp")) + -->
<!--                   log_Stotal.z + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados, method = "REML",control=ctrl) -->

<!-- ``` -->


<!-- <!-- __1) Parâmetros Lineares (parametric coefficients)__    --> -->
<!-- <!-- intercepto geral e a inclinação de log_Stotal.z     --> -->

<!-- <!-- __2) Approximate significance of smooth terms__ --> -->
<!-- <!-- a) edf (effective degrees of freedom): número de parâmetros a serem estimados por smoothers menos uma constante; descreve o grau de complexidade do smoother. --> -->
<!-- <!-- b) Ref.df e F: columns from a ANOVA for the overall significance of the smoother (a linear parametric test) --> -->




<!-- <!-- código antigo  --> -->

<!-- <!-- ## Número de SADs refutadas --> -->

<!-- <!-- ### Visualização --> -->

<!-- <!-- ```{r n_ref preditoras categoricas} --> -->
<!-- <!-- # graficos --> -->
<!-- <!-- l_p <- vector("list",4) --> -->
<!-- <!-- l_p[[1]] <- ggplot(df_resultados,aes(x=MN,y=n_Ref)) + --> -->
<!-- <!--   geom_jitter() + --> -->
<!-- <!--   geom_boxplot() --> -->
<!-- <!-- l_p[[2]] <- ggplot(df_resultados,aes(x=k,y=n_Ref,group=k)) + --> -->
<!-- <!--   geom_jitter() + --> -->
<!-- <!--   geom_boxplot() --> -->
<!-- <!-- l_p[[3]] <- ggplot(filter(df_resultados, --> -->
<!-- <!--                           k %in% levels(df_resultados$k)[1:10]), --> -->
<!-- <!--                    aes(x=p,y=n_Ref)) + --> -->
<!-- <!--   geom_point() +  --> -->
<!-- <!--   geom_smooth() +  --> -->
<!-- <!--   facet_grid(k~MN) --> -->
<!-- <!-- l_p[[4]] <- ggplot(filter(df_resultados, --> -->
<!-- <!--                           k %in% levels(df_resultados$k)[11:20]), --> -->
<!-- <!--                    aes(x=p,y=n_Ref)) + --> -->
<!-- <!--   geom_point() +  --> -->
<!-- <!--   geom_smooth() +  --> -->
<!-- <!--   facet_grid(k~MN) --> -->
<!-- <!-- grid.arrange(l_p[[1]],l_p[[2]],l_p[[3]],l_p[[4]], --> -->
<!-- <!--              layout_matrix = rbind(c(1,2,2,2), --> -->
<!-- <!--                                    c(3,3,4,4), --> -->
<!-- <!--                                    c(3,3,4,4), --> -->
<!-- <!--                                    c(3,3,4,4)) --> -->
<!-- <!--              ) --> -->

<!-- <!-- ``` --> -->

<!-- <!-- __Figura 1__ Número de SADs refutadas (n_Ref) ~ MN, k, p --> -->

<!-- <!-- Vamos aproximar a variável por um processo binomial. Utilizamos o seguinte protocolo de ajuste dos dados   --> -->
<!-- <!-- 1) comparar diferentes agrupamentos dos dados por sítios de amostragem, para um mesmo modelo cheio;   --> -->
<!-- <!-- 2) os modelo cheio vão conter as variáveis p e MN e duas versões de k (continua e categorica); --> -->
<!-- <!-- 3) e as 3 funções de ligação canônicas   --> -->
<!-- <!-- 4) o modelo cheio mais plausível sera utilizado na seleção de variáveis --> -->
<!-- <!-- 5) a seleção de variáveis contará com todas as combinações das preditoras do modelo cheio --> -->
<!-- <!-- 6) avaliamos os resíduos quantílicos do modelo mais plausível --> -->


<!-- <!-- ```{r n_ref comparacao modelos cheios} --> -->
<!-- <!-- l_md <- vector("list",15) --> -->
<!-- <!-- names(l_md) <- c("l k0 1|Site","l k0 MN|Site","l k0 k0*MN|Site", --> -->
<!-- <!--                  "l kf 1|Site","l kf MN|Site", --> -->
<!-- <!--                  "p k0 1|Site","p k0 MN|Site","p k0 k0*MN|Site", --> -->
<!-- <!--                  "p kf 1|Site","p kf MN|Site", --> -->
<!-- <!--                  "c k0 1|Site","c k0 MN|Site","c k0 k0*MN|Site", --> -->
<!-- <!--                  "c kf 1|Site","c kf MN|Site") --> -->
<!-- <!-- ## logito ## --> -->
<!-- <!-- l_md[[1]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (1|Site),  --> -->
<!-- <!--                    family = "binomial",data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[2]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (MN|Site),  --> -->
<!-- <!--                    family = "binomial",data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[3]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (MN*k.z|Site), --> -->
<!-- <!--                    family = "binomial",data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[4]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k * MN + (1|Site), --> -->
<!-- <!--                    family = "binomial",data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[5]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k * MN + (MN|Site), --> -->
<!-- <!--                    family = "binomial",data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- ## probit ## --> -->
<!-- <!-- l_md[[6]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (1|Site),  --> -->
<!-- <!--                    family = "binomial"(link = probit),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[7]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (MN|Site),  --> -->
<!-- <!--                    family = "binomial"(link = probit),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[8]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (MN*k.z|Site), --> -->
<!-- <!--                    family = "binomial"(link = probit),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[9]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k * MN + (1|Site), --> -->
<!-- <!--                    family = "binomial"(link = probit),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[10]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k * MN + (MN|Site), --> -->
<!-- <!--                    family = "binomial"(link = probit),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- ## cloglog --> -->
<!-- <!-- l_md[[11]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (1|Site),  --> -->
<!-- <!--                    family = "binomial"(link = cloglog),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[12]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (MN|Site),  --> -->
<!-- <!--                    family = "binomial"(link = cloglog),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[13]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (MN*k.z|Site), --> -->
<!-- <!--                    family = "binomial"(link = cloglog),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e7))) --> -->
<!-- <!-- par_md <- getME(l_md[[13]],c("theta","fixef")) --> -->
<!-- <!-- l_md[[13]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (MN*k.z|Site), --> -->
<!-- <!--                    family = "binomial"(link = cloglog),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e7)), --> -->
<!-- <!--                    start = par_md) --> -->
<!-- <!-- l_md[[14]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k * MN + (1|Site), --> -->
<!-- <!--                    family = "binomial"(link = cloglog),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[15]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k * MN + (MN|Site), --> -->
<!-- <!--                    family = "binomial"(link = cloglog),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- AICctab(l_md,weights=T) --> -->
<!-- <!-- ``` --> -->

<!-- <!-- Pergunta: existe algum problema em comparar modelos que utilizaram diferentes otimizadores? --> -->
<!-- <!-- Resposta: os otimizadores diferem no algoritmo que vare o campo de parâmetros; uma vez escolhidos os parâmetros os modelos são comparados da mesma forma --> -->

<!-- <!-- Falhas de convergência: --> -->

<!-- <!-- ```{r n_ref modelo cheio com convergencia} --> -->
<!-- <!-- # rotina de avaliação --> -->
<!-- <!-- #  --> -->
<!-- <!-- par_md <- getME(l_md[[13]],c("theta","fixef")) --> -->
<!-- <!-- l_md[[13]] <- glmer(cbind(n_ref,100-n_ref) ~ p.z * k.z * MN + (MN*k.z|Site), --> -->
<!-- <!--                    family = "binomial"(link = cloglog),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e7)), --> -->
<!-- <!--                    start = par_md) --> -->
<!-- <!-- AICctab(l_md,weights=T) --> -->
<!-- <!-- ``` --> -->

<!-- <!-- Resolvido --> -->

<!-- <!-- ### Para n_SAD.Nref --> -->

<!-- <!-- ```{r gof comparacao modelos cheios} --> -->
<!-- <!-- l_md <- vector("list",15) --> -->
<!-- <!-- names(l_md) <- c("l k0 1|Site","l k0 MN|Site","l k0 k0*MN|Site", --> -->
<!-- <!--                  "l kf 1|Site","l kf MN|Site", --> -->
<!-- <!--                  "p k0 1|Site","p k0 MN|Site","p k0 k0*MN|Site", --> -->
<!-- <!--                  "p kf 1|Site","p kf MN|Site", --> -->
<!-- <!--                  "c k0 1|Site","c k0 MN|Site","c k0 k0*MN|Site", --> -->
<!-- <!--                  "c kf 1|Site","c kf MN|Site") --> -->
<!-- <!-- ## logito ## --> -->
<!-- <!-- l_md[[1]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (1|Site),  --> -->
<!-- <!--                    family = "binomial",data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[2]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (MN|Site),  --> -->
<!-- <!--                    family = "binomial",data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[3]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (MN*k.z|Site), --> -->
<!-- <!--                    family = "binomial",data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[4]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k * MN + (1|Site), --> -->
<!-- <!--                    family = "binomial",data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[5]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k * MN + (MN|Site), --> -->
<!-- <!--                    family = "binomial",data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- ## probit ## --> -->
<!-- <!-- l_md[[6]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (1|Site),  --> -->
<!-- <!--                    family = "binomial"(link = probit),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[7]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (MN|Site),  --> -->
<!-- <!--                    family = "binomial"(link = probit),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[8]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (MN*k.z|Site), --> -->
<!-- <!--                    family = "binomial"(link = probit),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- par_md <- getME(l_md[[8]],c("theta","fixef")) --> -->
<!-- <!-- l_md[[8]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (MN*k.z|Site), --> -->
<!-- <!--                    family = "binomial"(link = probit),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)), --> -->
<!-- <!--                    start = par_md) --> -->
<!-- <!-- l_md[[9]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k * MN + (1|Site), --> -->
<!-- <!--                    family = "binomial"(link = probit),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[10]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k * MN + (MN|Site), --> -->
<!-- <!--                    family = "binomial"(link = probit),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- ## cloglog --> -->
<!-- <!-- l_md[[11]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (1|Site),  --> -->
<!-- <!--                    family = "binomial"(link = cloglog),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[12]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (MN|Site),  --> -->
<!-- <!--                    family = "binomial"(link = cloglog),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[13]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (MN*k.z|Site), --> -->
<!-- <!--                    family = "binomial"(link = cloglog),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e7))) --> -->
<!-- <!-- par_md <- getME(l_md[[13]],c("theta","fixef")) --> -->
<!-- <!-- l_md[[13]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k.z * MN + (MN*k.z|Site), --> -->
<!-- <!--                    family = "binomial"(link = cloglog),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e7)), --> -->
<!-- <!--                    start = par_md) --> -->
<!-- <!-- l_md[[14]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k * MN + (1|Site), --> -->
<!-- <!--                    family = "binomial"(link = cloglog),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[15]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k * MN + (MN|Site), --> -->
<!-- <!--                    family = "binomial"(link = cloglog),data=df_resultados, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- AICctab(l_md,weights=T) --> -->
<!-- <!-- ``` --> -->


<!-- <!-- O modelo cheio VR ~ p.z * k.z * MN + (MN * k.z|Site) é o modelo cheio mais plausível. --> -->

<!-- <!-- Se VR = n_ref, então a função de ligação cloglog é a mais plausível --> -->
<!-- <!-- Se VR = GOF, então a logito --> -->



<!-- <!-- __Seleção de Variáveis__ --> -->

<!-- <!-- ```{r GOF selecao de modelos} --> -->
<!-- <!-- # f_md <- function( --> -->
<!-- <!-- df_=df_resultados --> -->
<!-- <!-- l_md <- vector("list",19) --> -->
<!-- <!-- names(l_md) <- c("p*k*MN",# modelo cheio --> -->
<!-- <!--                  "p*k*MN-p:k:MN", #MC - 3a ordem --> -->
<!-- <!--                  "p*(k+MN)","k*(p+MN)","MN*(p+k)", #2 interações --> -->
<!-- <!--                  "p*k+MN","p*MN+k","k*MN+p", #1 interação + preditor --> -->
<!-- <!--                  "p*k","p*MN","k*MN", #1 interação --> -->
<!-- <!--                  "p+k+MN",#aditivo 3 --> -->
<!-- <!--                  "p+k","p+MN","k+MN", #aditivo 2  --> -->
<!-- <!--                  "p","k","MN", #preditor isolado --> -->
<!-- <!--                  "1") #nulo --> -->
<!-- <!-- #modelo cheio --> -->
<!-- <!-- l_md[[1]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k * MN + (MN|Site),  --> -->
<!-- <!--                    family = "binomial", data=df_, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- #modelo cheio - interação 3a ordem --> -->
<!-- <!-- l_md[[2]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k * MN - p.z:k:MN + (MN|Site),  --> -->
<!-- <!--                    family = "binomial", data=df_, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- #2 interações --> -->
<!-- <!-- l_md[[3]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * (k + MN) + (MN|Site),  --> -->
<!-- <!--                    family = "binomial", data=df_, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[4]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ k * (p.z + MN) + (MN|Site),  --> -->
<!-- <!--                    family = "binomial", data=df_, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[5]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ MN * (p.z + k) + (MN|Site),  --> -->
<!-- <!--                    family = "binomial",data=df_, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- #1 interação + preditor --> -->
<!-- <!-- l_md[[6]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k + MN + (MN|Site),  --> -->
<!-- <!--                    family = "binomial", data=df_, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[7]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * MN + k + (MN|Site),  --> -->
<!-- <!--                    family = "binomial", data=df_, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[8]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ k * MN + p.z + (MN|Site),  --> -->
<!-- <!--                    family = "binomial", data=df_, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- #1 interação --> -->
<!-- <!-- l_md[[9]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * k + (1|Site), --> -->
<!-- <!--                    family = "binomial", data=df_, --> -->
<!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[10]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z * MN + (MN|Site), --> -->
<!-- <!--                     family = "binomial", data=df_, --> -->
<!-- <!--                     control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[11]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ k * MN + (MN|Site), --> -->
<!-- <!--                     family = "binomial", data=df_, --> -->
<!-- <!--                     control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- #aditivo 3 --> -->
<!-- <!-- l_md[[12]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z + k + MN + (MN|Site), --> -->
<!-- <!--                     family = "binomial", data=df_, --> -->
<!-- <!--                     control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- #aditivo 2 --> -->
<!-- <!-- l_md[[13]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z + k + (1|Site), --> -->
<!-- <!--                     family = "binomial", data=df_, --> -->
<!-- <!--                     control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[14]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z + MN + (MN|Site), --> -->
<!-- <!--                     family = "binomial", data=df_, --> -->
<!-- <!--                     control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[15]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ k + MN + (MN|Site), --> -->
<!-- <!--                     family = "binomial", data=df_, --> -->
<!-- <!--                     control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- #aditivo 1 --> -->
<!-- <!-- l_md[[16]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ p.z + (1|Site), --> -->
<!-- <!--                     family = "binomial", data=df_, --> -->
<!-- <!--                     control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[17]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ k + (1|Site), --> -->
<!-- <!--                     family = "binomial", data=df_, --> -->
<!-- <!--                     control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- l_md[[18]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ MN + (MN|Site), --> -->
<!-- <!--                     family = "binomial", data=df_, --> -->
<!-- <!--                     control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- # nulo --> -->
<!-- <!-- l_md[[19]] <- glmer(cbind(n_SAD.N.ref,100-n_SAD.N.ref) ~ 1 + (1|Site), --> -->
<!-- <!--                     family = "binomial", data=df_, --> -->
<!-- <!--                     control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> -->
<!-- <!-- # } --> -->
<!-- <!-- # registerDoMC(3) --> -->
<!-- <!-- # l_md.GOF <- dlply() --> -->

<!-- <!-- AICctab(l_md,weights=T) --> -->
<!-- <!-- ``` --> -->

