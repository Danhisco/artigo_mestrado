---
title: "Estatistica"
author: "Mori, Danilo"
date: "31/10/2019"
output: 
  html_document:
    toc: true
    toc_depth: 5
---

<style>
body {
text-align: justify}
</style>

<!--  -->

```{r setup, include=TRUE,echo=FALSE}
knitr::opts_chunk$set(echo = FALSE, tidy = FALSE, include = TRUE, warning = FALSE,cache = TRUE,message=FALSE,eval=TRUE)
# setwd("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/")
knitr::opts_knit$set(root.dir = "~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/")
```

```{r pacotes,eval=TRUE,echo=F}
library(gtools)
library(GGally)
library(doMC)
library(DHARMa)
library(MuMIn)
library(mgcv)
library(gratia)
library(GUILDS)
library(broom)
library(bbmle)
library(gamm4)
library(lme4)
library(merTools)
library(magrittr)
library(gridExtra)
library(plotly)
library(sjPlot)
library(sjlabelled)
library(sjmisc)
library(ggplot2)
library(stringr)
library(tidyr)
library(plyr)
library(purrr)
library(dplyr)
```

```{r dados,message=FALSE}
### dados ###
# leitura
df_resultados <- read.table(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/resultados/df_resultados.csv",header = TRUE,sep = ";",dec = ".",as.is=FALSE)
df_resultados$k.0_1 <- 1 - df_resultados$k.0
# padronização
level_k <- unique(as.character(df_resultados$k))
df_resultados$k <- factor(as.character(df_resultados$k),levels = level_k)
levels(df_resultados$k)[19] <- "0.1"
df_resultados %<>% mutate(L_plot = 100*sqrt(Ntotal/DA),
                          d_Lplot = d / L_plot,
                          log_Stotal=log(Stotal))
# z score
f_z <- function(x){
  m <- base::mean(x,na.rm=TRUE)
  sd <- sd(x,na.rm=TRUE)
  output <- (x-m)/sd
  return(output)
} 
# names(df_resultados)
df_resultados.z <- as.data.frame(apply(df_resultados[c("p","Ntotal","log_Stotal","k.0","k.0_1","d_Lplot","d")],2,f_z))
names(df_resultados.z) <- sapply(names(df_resultados.z), function(x) paste(gsub(".0","",x),".z",sep=""))
df_resultados %<>% cbind(.,df_resultados.z)
names(df_resultados)[c(5:6,26,33)] <- c("n_nRef","n_Ref","d_Lplot","d_Lplot.z")
df_resultados.U <- df_resultados %>% filter(MN=="EE") %>% distinct() 
# summary(df_resultados)
df_resultados %<>% mutate(diff_S0 = (S.MN_mean-Stotal)/Stotal,
                          diff_S = diff_S0 + min(diff_S0)*(-1) + 0.01)
summary(df_resultados[,c("diff_S0","diff_S")])
lm(df_resultados$diff_S~df_resultados$diff_S0)
```

# 1 - Número de SADs preditas não refutadas


```{r n_nRef padroes gerais fig11}
l_p <- vector("list",2)
l_p[[1]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[1:10]),
                   aes(x=p,y=n_nRef)) + 
  geom_point() + 
  geom_smooth(method="loess") +
  facet_grid(k~MN)
l_p[[2]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[11:20]),
                   aes(x=p,y=n_nRef)) + 
  geom_point() + 
  geom_smooth(method="loess") +
  facet_grid(k~MN) 
do.call("grid.arrange",c(l_p,ncol=2))
```

__Figura 1.1__ logito(número de SADs não refutadas) ~ p *  k * MN. A linha azul é uma estimativa baseada em 'loess'. 

A figura 1.1 mostra que o padrão geral dos dados não é linear na escala da função de ligação, assim utilizamos GAM. Possibilitamos até 1 intercepto por modelo neutro por sítio de amostragem (MN|SiteCode); para modelos com variáveis de dispersão continua não foi possível um smoother por Sítio de Amostragem e Modelo Neutro



## 1.1 GLMM binomial

### 1.1.1 Modelo Cheio e Auditoria

```{r glmm n_nRef comparacao modelos cheios,echo=TRUE,eval=FALSE,cache=TRUE}
l_md <- vector("list",11)
names(l_md) <- c("k0 1|Site","k0 MN|Site","k0 k0*MN|Site",
                 "kf 1|Site","kf MN|Site",
                 "d 1|Site","d MN|Site","d d*MN|Site",
                 "d/L_plot 1|Site","d/L_plot MN|Site","d/L_plot d/L_plot*MN|Site")
l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + I(p.z^2) * k_1.z * MN + (1|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + I(p.z^2) * k_1.z * MN + (MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + I(p.z^2) * k_1.z * MN + (k_1.z*MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[4]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k * MN + I(p.z^2) * k * MN + (1|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[5]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k * MN + I(p.z^2) * k * MN + (MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[6]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d.z * MN + I(p.z^2) * d.z * MN + (1|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[7]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d.z * MN + I(p.z^2) * d.z * MN + (MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[8]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d.z * MN + I(p.z^2) * d.z * MN + (d.z*MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[9]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + I(p.z^2) * d_Lplot.z * MN + (1|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[10]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + I(p.z^2) * d_Lplot.z * MN + (MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[11]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + I(p.z^2) * d_Lplot.z * MN + (d_Lplot.z*MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
```


```{r l_md_nRef.GLMM, eval=FALSE}
l_md_nRef.GLMM <- l_md
save(l_md_nRef.GLMM,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_GLMM.Rdata")
```



__Tabela 1.1 __ AICctab 

```{r AICctab n_nRef p^2 n_nRef,eval=TRUE,cache=FALSE}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_GLMM.Rdata")
bbmle::AICctab(l_md_nRef.GLMM,weights=T)
```


O único modelo plausível é aquele com função de ligação logito, a variável d e a estrutura aleatória MN * d |SiteCode.


```{r auditoria mais plausivel md_n.ref1, message=FALSE}
# library(DHARMa)
md_nRef <- l_md_nRef.GLMM[["d d*MN|Site"]]
# p_plot <- simulateResiduals(md_nRef,n=1000)
# plot(p_plot)
```

__Figura 1.2__ Resíduos Quantílicos do modelo cheio para n_nRef ~ p*d*MN + p^2*d*MN + (d*MN|SiteCode)

NOTA: não entendo o motivo de não rodar os resíduos quantílicos quando compilo o Rmarkdown: 

mensagem de erro:

Error in if (family$family %in% c("binomial","poisson","quasibinomial", : argumento tem comprimento zero Calls: <Anonymous> ... withCallingHandlers -> withVisible -> eval -> eval -> simulateResiduals Além disso: warining message: In checkModel(fittedModel) : DHARMa: fittedModel not in class of supported models. Absolutely no guarantee that this will work


```{r graf diag 2 glmm p^2 n_nRef fig 13, include=FALSE,eval=FALSE}
# teste <- augment(lm(log(Stotal) ~ p,df_resultados)) %>% as.data.frame()
# df_plot <- augment(md_nRef) %>% as.data.frame() # demorando muito
# # df_plot %>% names
# l_p <- vector("list",3)
# l_p[[1]] <- ggplot(df_plot,aes(x=p.z,y=.fitted)) + geom_point(alpha=0.3) + geom_line(aes(group=SiteCode)) + facet_wrap(~MN,ncol=2)
# l_p[[2]] <- ggplot(df_plot,aes(x=I.p.z.2.,y=.fitted)) + geom_point(alpha=0.3) + geom_line(aes(group=SiteCode)) + facet_wrap(~MN,ncol=2)
# l_p[[3]] <- ggplot(df_plot,aes(x=d_Lplot.z,y=.fitted)) + geom_point(alpha=0.3) + geom_line(aes(group=SiteCode)) + facet_wrap(~MN,ncol=2)
# do.call("grid.arrange",c(l_p,ncol=1))
```

<!-- __Figura 1.3__ Valores ajustados contra as preditoras lineares  - ESTA DEMORANDO MUITO PARA RODAR AUGMENT PARA O MODELO MAIS PLAUSIVEL -->
  
### 1.1.2 Modelo cheio: predições

```{r avaliacao por site fig 14,fig.width=8, fig.height=30,message=FALSE,eval=FALSE}
# Dados
df_plot <- df_resultados
# df_plot <- cbind(df_plot,
#   predictInterval(merMod = md_nRef,
#                          level = 0.95, n.sims=200,
#                          stat="median",type = "probability",
#                          include.resid.var = TRUE)*100
#                  )
df_plot$Pr_nRef <- predict(md_nRef,type="response")*100
# Graficos
df_plot %<>% mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
ggplot(df_plot,aes(x=d.z,y=n_nRef,group=MN)) +
  geom_point(aes(color=MN)) +
  geom_line(aes(y=Pr_nRef,color=MN)) +
  scale_color_manual(values=c("#FF0000", "#000000")) +
  theme_light() + theme(legend.position="top") + facet_wrap(~title,ncol=5)
```

__Figura 1.3__ Predito e observado por SiteCode  
  

Observamos que é necessário considerar também um termo quadrático para d. Então sigo com a adição de um termo quadrático para d

__Tabela 1.2 __ R2 condicional e marginal do modelo cheio com termo quadrático para p e d 

```{r md_nRef2 e r2cm,echo=TRUE,cache=TRUE}
md_nRef2 <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                     (p.z + I(p.z^2)) * (d.z + I(d.z^2)) * MN + ((d.z + I(d.z^2)) * MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
r.squaredGLMM(md_nRef2)
```


```{r md_nRef2 quant res}
p_plot <- simulateResiduals(md_nRef2,n = 1000)
plot(p_plot)
```

__Figura 1.4__ Resíduos quantílicos para o modelo cheio com termos quadráticos para p e d.  


```{r avaliacao por site fig 15 glmm p2 d2,fig.width=8, fig.height=30,message=FALSE}
# Dados
df_plot <- df_resultados
df_plot <- cbind(df_plot,
  predictInterval(merMod = md_nRef2,
                         level = 0.95, n.sims=200,
                         stat="median",type = "probability",
                         include.resid.var = TRUE)*100
                 )
# df_plot$Pr_nRef <- predict(md_nRef,type="response")*100
# Graficos
df_plot %<>% mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
ggplot(df_plot,aes(x=d.z,y=n_nRef,group=MN)) +
  geom_point(aes(color=MN)) +
  geom_line(aes(y=fit,color=MN)) +
  scale_color_manual(values=c("#FF0000", "#000000")) +
  theme_classic() + theme(legend.position="top") + facet_wrap(~title,ncol=5)
```
  
__Figura 1.5__ Predito pelo modelo com termo quadrático para p e d

O modelo cheio com termo quadrático para p e d não foi foi suficiente para descrever o padrão observado nos dados. Hipotetizamos que a razão é a divergência no grau de variação entre os modelos neutros. Assim iremos ajustar modelos para cada conjunto de dados. Para possibilitar a comparação irei manter a estrutura comum das preditoras porem comparando a estrutura aleatória e função de ligação para cada modelo neutro.
   


## 1.2 GLMM binomail subset:MN==EE

### Modelo cheio

```{r glmm quadratico n_nRef MNEE modelo cheio,echo=TRUE,eval=FALSE}
l_md <- vector("list",3)
names(l_md) <- c("1|Site","d|Site","d + d^2|Site")
l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (1|SiteCode),
                   family = "binomial",data=filter(df_resultados,MN=="EE"),
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (d.z|SiteCode),
                   family = "binomial",data=filter(df_resultados,MN=="EE"),
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (d.z + I(d.z^2)|SiteCode),
                   family = "binomial",data=filter(df_resultados,MN=="EE"),
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
```

```{r l_md_nRef.GLMM_EE,echo=FALSE,eval=FALSE}
l_md_nRef.GLMM_EE <- l_md
save(l_md_nRef.GLMM_EE,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef.GLMM_EE.Rdata")
```

__Tabela 1.2.1__ AICctab para n_nRef MNEE 

```{r glmm quadratico n_nRef MNEE modelo cheio AICctab}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef.GLMM_EE.Rdata")
AICctab(l_md_nRef.GLMM_EE,weights=TRUE)
```

  
O modelo mais plausível considera um termo linear e quadrático para d na estrutura aletória. 


```{r fig 119 res quant glmm cheio MNEE}
p_plot <- DHARMa::simulateResiduals(l_md_nRef.GLMM_EE[["d + d^2|Site"]],n=1000)
plot(p_plot)  
```
  
__Figura 1.6__ Resíduos Quantílicos do glmm cheio para MNEE    


__Tabela 1.2.2__ R2 condicional e marginal modelo cheio nRef 

```{r tabela md cheio para MNEE nRef,message=FALSE,warning=FALSE}
r.squaredGLMM(l_md_nRef.GLMM_EE[["d + d^2|Site"]])
```


   
```{r avaliacao por site fig 17 glmm EE p2 d2,fig.width=8, fig.height=30,message=FALSE,eval=FALSE}
# Dados
df_plot <- df_resultados %>% filter(MN=="EE")
# df_plot <- cbind(df_plot,
#   predictInterval(merMod = l_md_nRef.GLMM_EE[["d + d^2|Site"]],
#                          level = 0.95, n.sims=200,
#                          stat="median",type = "probability",
#                          include.resid.var = TRUE)*100
#                  )
df_plot$Pr_nRef <- predict(l_md_nRef.GLMM_EE[["d + d^2|Site"]],type="response")*100
# Graficos
df_plot %<>% mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
ggplot(df_plot,aes(x=d.z,y=n_nRef)) +
  geom_point() +
  geom_line(aes(y=Pr_nRef),color="red") +
  theme_light() + theme(legend.position="top") + facet_wrap(~title,ncol=5)
```
  
<!-- __Figura 1.7__ Predito pelo modelo cheio com termo quadrático para p e d para MN=EE -->

  
### Seleção de Variáveis
  


```{r modelo global e R2m/c MNEE, echo=TRUE,cache=TRUE}
# dados
df_md <- filter(df_resultados,MN=="EE")
# modelo global
global_md <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (d.z + I(d.z^2)|SiteCode),
                   family = "binomial",data=df_md,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)),na.action = "na.fail")
```
  
  
__Tabela 1.2.3__ R2 condicional e marginal do modelo global

```{r modelo global dredge e AICctab delta 7 n_nRefEE}
dredge_glmmEE <- dredge(global_md,trace = FALSE,evaluate=TRUE)
subset(dredge_glmmEE,delta<7)
```






```{r model averaging EE MuMIn e AICcmodavg,message=FALSE,eval=FALSE}
library(AICcmodavg)
# todas as combinações de modelo do modelo cheio
l_md.dredge_nRefEE <- lapply(dredge(global_md,trace = FALSE,evaluate=FALSE), eval)
# Model Averaging for SiteCode predictions
mdAvg_nRefEE__MuMIn <- model.avg(l_md.dredge_nRefEE) #,subset<2
save(mdAvg_nRefEE__MuMIn,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__MuMIn.Rdata")
# Model Averaging for new data predictions
df_pred <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1],
                       d.z=seq(min(df_resultados$d.z),max(df_resultados$d.z),length=40),
                       p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=200))
mdAvg_nRefEE__AICcmodavg <- modavgPred(l_md.dredge_nRefEE,newdata = df_pred) %>%
  cbind(df_pred)
save(mdAvg_nRefEE__AICcmodavg,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__AICcmodavg.Rdata")
```

#### Predito para cada Sítio

Para avaliar o ajuste do modelo ao conjunto de dados utilizo funções do pacote MuMIn (REF) que permite calcular a predição do modelo médio para o conjunto original de dados.  
  

```{r glmm quadratico n_nRef MNEE selecao de variaveis, comment=FALSE, message=FALSE,warning=FALSE,results="hide",fig.width=8, fig.height=30}
# Modelo Global
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__MuMIn.Rdata")
# Predição
df_md <- df_resultados %>% filter(MN=="EE")
df_md$Pr_nRef <- predict(mdAvg_nRefEE__MuMIn,type="response")*100
# Gráfico
df_md %<>% mutate(title = paste0(SiteCode," p=",round(p,3))) %>% arrange(p)
df_md$title <- factor(df_md$title,levels = unique(df_md$title))
ggplot(df_md,aes(x=d,y=n_nRef)) + 
  geom_point() + geom_line(aes(y=Pr_nRef),color="red") + 
  labs(x="Dispersão Média",
       y="Número de SADs não Refutadas",
       title="Prob. Não Refutar uma SAD neutra MN=EE") +
  facet_wrap(~title,ncol=5) + theme_light()
```

__Figura 1.7__ Predições por sítio de amostragem do modelo médio calculado a partir do modelo global 
; pontos: número de SADs neutras refutadas para uma bateria de simulações com um determinada distância média de dispersão; eixo x = distância média de dispersão / largura da área de amostragem; a linha é a probabilidade de não refutar uma SAD neutra segundo a predição média do conjunto de sub-modelos dentro do intervalo de plausibilidade de 7 (Burnham et al 2011)
  
  
#### Predito para novo conjunto de dados  
  
Para avaliar o predito e intervalo de confiança de 95% pelo modelo médio utilizo funções do pacote AICcmodavg (REF).  

```{r fig 18 predito para novo conjunto de dados glmm nRefEE AICcmodavg}
# dados
## modelo médio
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__AICcmodavg.Rdata")
df_plot <- mdAvg_nRefEE__AICcmodavg
# df_plot %>% names
df_plot %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),d = d.z*sd(df_resultados$d) + mean(df_resultados$d))


l_p.nRefEE_AICcmodavg <- list()
l_p.nRefEE_AICcmodavg[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Prob de não Refutar",
       fill="Probability") + theme_classic()
l_p.nRefEE_AICcmodavg[[2]] <- ggplot(df_plot,aes(x=p,y=d,fill=lower.CL)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Lower IC (5%)",
       fill="Probability") + theme_classic()
l_p.nRefEE_AICcmodavg[[3]] <- ggplot(df_plot,aes(x=p,y=d,fill=upper.CL)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Upper IC (95%)",
       fill="Probability") + theme_classic()
grid.arrange(l_p.nRefEE_AICcmodavg[[1]],l_p.nRefEE_AICcmodavg[[2]],l_p.nRefEE_AICcmodavg[[3]],
             layout_matrix=rbind(rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 c(2,2,3,3),
                                 c(2,2,3,3))
             )
```
  
__Figura 1.8__ Efeito predito de d e p na Probabilidade de não refutar segundo o modelo médio para MN==EE.  No painel superior a predição média, nos paineis inferiores o intervalo de confiança.  
  

## 1.3 n_nRef subset:MN==EI  
  
  
```{r glmm quadratico n_nRef MNEI modelo cheio,include=FALSE,eval=FALSE,echo=TRUE}
l_md <- vector("list",3)
names(l_md) <- c("1|Site","d|Site","d + d^2|Site")
l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (1|SiteCode),
                   family = "binomial",data=filter(df_resultados,MN=="EI"),
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (d.z|SiteCode),
                   family = "binomial",data=filter(df_resultados,MN=="EI"),
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (d.z + I(d.z^2)|SiteCode),
                   family = "binomial",data=filter(df_resultados,MN=="EI"),
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
```

```{r l_md_nRef.GLMM_EI,eval=FALSE}
l_md_nRef.GLMM_EI <- l_md
save(l_md_nRef.GLMM_EI,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef.GLMM_EI.Rdata")
```



__Tabela 1.3.1__ AICctab n_nRef MNEI  

```{r glmm quadratico n_nRef MNEI modelo cheio AICctab}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef.GLMM_EI.Rdata")
AICctab(l_md_nRef.GLMM_EI,weights=TRUE)
```

A função AICcmodavg::modavgPred aceita apenas a função de ligação canonica logito, então não irei comparar outras funções de ligação
O modelo mais plausível considera um termo linear e quadrático para d na estrutura aletória. Segue seleção de variáveis.

__Tabela 1.3.2__ R2 marginal e condicional n_nRef MNEI  
  

```{r r2mc nRefEI}
r.squaredGLMM(l_md_nRef.GLMM_EI[["d + d^2|Site"]])
```


```{r fig 19 res quant glmm cheio MNEI}
p_plot <- DHARMa::simulateResiduals(l_md_nRef.GLMM_EI[["d + d^2|Site"]],n=1000)
plot(p_plot)  
```
  
__Figura 1.9__ Resíduos Quantílicos do glmm cheio mais plausível para MNEI   
     

```{r modelo global n_nRef e R2m/c MNEI, include=TRUE,echo=TRUE,cache=TRUE}
# dados
df_md <- filter(df_resultados,MN=="EI")
# modelo global
global_md <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (d.z + I(d.z^2)|SiteCode),
                   family = "binomial",data=df_md,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)),na.action = "na.fail")
```

__Tabela 1.3.3__ AICctab n_nRef MNEI delta<7  
  
   

```{r modelo dredge AICctab nRefEI}
dredge_glmmEI <- dredge(global_md,trace = FALSE,evaluate=TRUE)
subset(dredge_glmmEI,delta<7)
```



```{r model averaging EI MuMIn e AICcmodavg,message=FALSE,eval=FALSE}
# todas as combinações de modelo do modelo cheio
l_md.dredge_nRefEI <- lapply(dredge(global_md,trace = FALSE,evaluate=FALSE), eval)
# Model Averaging for SiteCode predictions
mdAvg_nRefEI__MuMIn <- model.avg(l_md.dredge_nRefEI) #,subset<2
save(mdAvg_nRefEI__MuMIn,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__MuMIn.Rdata")
# Model Averaging for new data predictions
df_pred <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1],
                       d.z=seq(min(df_resultados$d.z),max(df_resultados$d.z),length=40),
                       p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=200))
mdAvg_nRefEI__AICcmodavg <- AICcmodavg::modavgPred(l_md.dredge_nRefEI,newdata = df_pred) %>%
  cbind(df_pred)
save(mdAvg_nRefEI__AICcmodavg,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__AICcmodavg.Rdata")
```

##### Predito para cada Sítio

Para avaliar o ajuste do modelo ao conjunto de dados utilizo funções do pacote MuMIn (REF) que permite calcular a predição do modelo médio para o conjunto original de dados.  
  

```{r glmm quadratico n_nRef MNEI selecao de variaveis, comment=FALSE, message=FALSE,warning=FALSE,results="hide",fig.width=8, fig.height=30}
# Modelo Global
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__MuMIn.Rdata")
# Predição
df_md <- df_resultados %>% filter(MN=="EI")
df_md$Pr_nRef <- predict(mdAvg_nRefEI__MuMIn,type="response")*100
# Gráfico
df_md %<>% mutate(title = paste0(SiteCode," p=",round(p,3))) %>% arrange(p)
df_md$title <- factor(df_md$title,levels = unique(df_md$title))
ggplot(df_md,aes(x=d_Lplot,y=n_nRef)) + 
  geom_point() + geom_line(aes(y=Pr_nRef),color="red") + 
  labs(x="Dispersão Média per capita / Lado da Área Amostrada",
       y="Número de SADs não Refutadas",
       title="Prob. Não Refutar uma SAD neutra MN=EI") +
  facet_wrap(~title,ncol=5) + theme_classic()
```  

__Figura 1.10__ Predito por SiteCode a partir do modelo médio para MNEI.  
  
  
      
  
```{r fig 111 predito para novo conjunto de dados glmm nRefEI AICcmodavg}
# dados
## modelo médio
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__AICcmodavg.Rdata")
df_plot <- mdAvg_nRefEI__AICcmodavg
# df_plot %>% names
df_plot %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),d = d.z*sd(df_resultados$d) + mean(df_resultados$d))


l_p.nRefEI_AICcmodavg <- list()
l_p.nRefEI_AICcmodavg[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Prob de não Refutar",
       fill="Probability") + theme_classic()
l_p.nRefEI_AICcmodavg[[2]] <- ggplot(df_plot,aes(x=p,y=d,fill=lower.CL)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Lower IC (5%)",
       fill="Probability") + theme_classic()
l_p.nRefEI_AICcmodavg[[3]] <- ggplot(df_plot,aes(x=p,y=d,fill=upper.CL)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Upper IC (95%)",
       fill="Probability") + theme_classic()
grid.arrange(l_p.nRefEI_AICcmodavg[[1]],l_p.nRefEI_AICcmodavg[[2]],l_p.nRefEI_AICcmodavg[[3]],
             layout_matrix=rbind(rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 c(2,2,3,3),
                                 c(2,2,3,3))
             )
```
  
__Figura 1.11__ Efeito predito de d e p na Probabilidade de não refutar segundo o modelo médio para MN==EE.  No painel superior a predição média, nos paineis inferiores o intervalo de confiança.  



## 1.4 Figura Final





```{r figura final n_nRef }
#############
# dados
## MNEE
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__AICcmodavg.Rdata")
mdAvg_nRefEE__AICcmodavg$MN <- "EE"
## MNEI
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__AICcmodavg.Rdata")
mdAvg_nRefEI__AICcmodavg$MN <- "EI"
## df comum
df_plot <- rbind(mdAvg_nRefEE__AICcmodavg,mdAvg_nRefEI__AICcmodavg)
df_plot %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
                    d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
## Gráficos
l_p.nRefEE_AICcmodavg <- list()
labels_IC <- c(lower.CL="IC 5%", upper.CL="IC 95%")
## predição média para ambos modelos
l_p.nRefEE_AICcmodavg[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(
    # title="Probabilidade de Não Refutar",
       fill="Probability") +
  theme_classic() + facet_wrap(~MN,ncol=2) + theme(legend.position="top")
## IC para MNEE
df_plotEE <- df_plot %>% filter(MN=="EE") %>%
  gather(key = IC_class ,value = IC_pred,lower.CL:upper.CL)
l_p.nRefEE_AICcmodavg[[2]] <- ggplot(df_plotEE,aes(x=p,y=d,fill=IC_pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  theme_classic() + facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) + theme(legend.position='none')
## IC para MNEI
df_plotEI <- df_plot %>% filter(MN=="EI") %>%
  gather(key = IC_class ,value = IC_pred,lower.CL:upper.CL)
l_p.nRefEE_AICcmodavg[[3]] <- ggplot(df_plotEI,aes(x=p,y=d,fill=IC_pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  theme_classic() + facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) + theme(legend.position='none')
## Arranjo dos gráficos
grid.arrange(l_p.nRefEE_AICcmodavg[[1]],l_p.nRefEE_AICcmodavg[[2]],l_p.nRefEE_AICcmodavg[[3]],
             layout_matrix=rbind(rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 c(2,2,3,3),
                                 c(2,2,3,3))
             )


```


__Figura 1.12__ Probabilidade de não refutar uma SAD neutra em função do modelo neutro (EE e EI), proporção de cobertura vegetal (p) e distância média de dispersão (d)


# 2 diff_S = (S_obs - S_MN)/S_obs

__Padrão Geral__

```{r preparacao dos dados 1,message=FALSE,eval=TRUE}
# gráfico
df_resultados %>% ggplot(aes(x=p,y=diff_S0,group=MN)) + 
  geom_abline(intercept = 0,slope = 0,col="blue") +
  geom_point(aes(color=MN),alpha=0.3) +
  scale_color_manual(values=c("#FF0000", "#000000")) +
  labs(title="diff_S = (S_MN - S_obs)/S_obs",x="p",y="diff_S") +
  facet_wrap(~k,ncol=5,scales="free") + theme_light()
# # graficos 
# filter(df_resultados,MN=="EE") %>% select(diff_S0, p, d, Stotal, Ntotal) %>% ggpairs() + labs(title="MNEE")
# do.call("grid.arrange",c(l_p,ncol=1))
```

__Figura 2.1__ diff_S (y-axis), p (x-axis).




## 2.1 MNEE



```{r diff_S MNEE modelo cheio,echo=TRUE}
l_md <- vector("list",9)
names(l_md) <- c("1-k 1|Site","1-k I(1-k)|Site",
                 "k 1|Site",
                 "d 1|Site","d d|Site",
                 "d/L 1|Site","d/L I(d/L)|Site",
                 "1 1|Site",
                 "1")
df_md <- df_resultados %>% filter(MN=="EE")
l_md[[1]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * k_1.z + (1|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[2]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * k_1.z + (k_1.z|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[3]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * k + (1|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[4]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * d.z + (1|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[5]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * d.z + (d.z|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[6]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * d_Lplot.z + (1|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[7]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * d_Lplot.z + (d_Lplot.z|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[8]] <- lmer(diff_S0 ~ 1 + (1|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[9]] <- lm(diff_S0 ~ 1,
                  data=df_md,na.action = "na.fail")
AICctab(l_md,weights=T)
```

Alguns modelos utilizados para estimar diff_S apresentaram "singularidade" (estimativas não diferem de zero), dentre eles o único modelo plausível. Isso indica que modelo com a estrutura aleatória mais simples devem ser ajustados aos dados, assim vou descartar aqueles com inclinação para a variável de dispersão por Sítio.

```{r diff_S modelo cheio 2,echo=TRUE}
l_md <- vector("list",6)
names(l_md) <- c("1-k 1|Site",
                 "k 1|Site",
                 "d 1|Site",
                 "d/L 1|Site",
                 "1 1|Site",
                 "1")
df_md <- df_resultados %>% filter(MN=="EE")
l_md[[1]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * k_1.z + (1|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[2]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * k + (1|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[3]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * d.z + (1|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[4]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * d_Lplot.z + (1|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[5]] <- lmer(diff_S0 ~ 1 + (1|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[6]] <- lm(diff_S0 ~ 1,
                   data=df_md,na.action = "na.fail")
AICctab(l_md,weights=T)
```
  
Nenhum destes modelos apresentou singularidade, o modelo nulo sem estrutura aleatória foi o único plausível. Segue gráfico diagnóstico:  


```{r graf diag modelo cheio mais plausivel diff_S MNEE,message=FALSE,warning=FALSE}
p_plot <- simulateResiduals(l_md[["1"]],n = 1000)
plot(p_plot)
```

__Figura 2.2__ Resíduos Quantílicos do modelo mais plausível para diff_S subset=MNEE (diff_S ~ 1)

__Tabela 2.3__ Sumário do modelo mais plausível para diff_S MNEE  

```{r}
summary(l_md[["1"]])
```
  
## MNEI  

```{r padroes gerais diff S MNEI, warning=FALSE,message=FALSE}
df_plot <- df_resultados %>% filter(MN=="EI")
ggplot(df_plot,aes(x=p,y=diff_S)) + 
  geom_smooth() + 
  geom_point(alpha=0.3) + 
  facet_wrap(~k,ncol=5,scales="free")
```

__Figura 2.3__ diffS_EI ~p*k  

Vou iniciar apenas com as preditoras de interesse (p e variáveis de dispersão). Devido a clara ausência de simetria de diff_S desloquei a distribuição apenas para valores positivos (figura 2.3 primeiro quadro) e utilizarei distribuição Gamma para ajustar os modelos com função de ligação 'log'.

```{r diff_S MNEI por sitio,fig.width=8, fig.height=30}
df_plot <- df_resultados %>% filter(MN=="EI")
df_plot %<>% mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
## por sítio de amostragem
ggplot(df_plot,aes(x=d,y=diff_S0)) +
  geom_point() +
  geom_smooth(method="loess",col="blue") + geom_smooth(method="lm",col="red") +
  theme_light() + theme(legend.position="top") + 
  labs(title=" red = lm; blue = 'loess' ") +
  facet_wrap(~title,ncol=5) #,scales="free" 
```

__Figura 2.4__ diff_S por sítio de amostragem e d

### Seleção do Modelo cheio: GLMM

```{r modelo cheio diff_S MNEI, echo=TRUE,warning=TRUE,message=TRUE,eval=FALSE}
df_md <- df_resultados %>% filter(MN=="EI")
# df_md$diff_S %>% summary
l_md <- vector("list",6)
names(l_md) <- c("1|Site","d|Site",
                 "p2*k log",
                 "p2*d2 id 1|Site",
                 "p2*d2 id d|Site",
                 "p2*d2 id d2|Site")
# modelos mínimos
l_md[[1]] <- glmer(diff_S ~ p.z*d.z + (1|SiteCode),
                   data=df_md,family="Gamma"(link="log"))
l_md[[2]] <- glmer(diff_S ~ p.z*d.z  + (d.z|SiteCode),
                   data=df_md,family="Gamma"(link="log"))
# com p2
## erro
l_md[[3]] <- glmer(diff_S ~ (p+I(p.z^2))*k + (1|SiteCode),
                   data=df_md,family="Gamma"(link="log"))
v_vars <- getME(l_md[[3]],c("theta","fixef"))
l_md[[3]] <- update(l_md[[3]],start=v_vars,control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
l_md[[3]] <- glmer(diff_S ~ I(p.z^2)*k + (1|SiteCode),
                   data=df_md,family="Gamma"(link="log"))
# com p2 e d2
#######################
# Model failed to converge with max|grad| = 0.00556207 (tol = 0.002, component 1)Model is nearly unidentifiable: very large eigenvalue
#  - Rescale variables?
l_md[[4]] <- glmer(diff_S ~ (p.z + I(p.z^2))*(d.z + I(d.z^2)) + (1|SiteCode),
                   data=df_md,family="Gamma"(link="log"))
v_vars <- getME(l_md[[4]],c("theta","fixef"))
l_md[[4]] <- update(l_md[[4]],start=v_vars,control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
#######################
#######################
# Model failed to converge with max|grad| = 0.0608783 (tol = 0.002, component 1)Model is nearly unidentifiable: very large eigenvalue
#  - Rescale variables?
l_md[[5]] <- glmer(diff_S ~ (p.z + I(p.z^2))*(d.z + I(d.z^2)) + (d.z|SiteCode),
                   data=df_md,family="Gamma"(link="log"))
v_vars <- getME(l_md[[5]],c("theta","fixef"))
l_md[[5]] <- update(l_md[[5]],start=v_vars,control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
#######################
# Model failed to converge with max|grad| = 0.336616 (tol = 0.002, component 1)Model is nearly unidentifiable: very large eigenvalue
#  - Rescale variables?
l_md[[6]] <- glmer(diff_S ~ (p.z + I(p.z^2))*(d.z + I(d.z^2)) + (d.z + I(d.z^2)|SiteCode),
                   data=df_md,family="Gamma"(link="log"))
v_vars <- getME(l_md[[6]],c("theta","fixef"))
l_md[[6]] <- update(l_md[[6]],start=v_vars,control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
#######################
```

```{r l_md.diffS_EI_glmm,eval=FALSE}
l_md.diffS_EI_glmm <- l_md
save(l_md.diffS_EI_glmm,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diffS_EI_glmm.Rdata")
```

```{r AICctab l_md.diffS_EI_glmm}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diffS_EI_glmm.Rdata")
AICctab(l_md.diffS_EI_glmm,weights=TRUE)
```

  
Não foi possível ajustar os modelos com estrutura fixa mais complexa. Vou avaliar se GAMM oferecem melhor ajuste aos dados

### GAMM cheio

```{r diff_S MNEI GAMM cheio,eval=FALSE,echo=TRUE}
l_md <- vector("list",4)
names(l_md) <- c("tp by=k","cr by=k",
                 "tp ti","cr ti")
l_md[[1]] <- gam(diff_S ~ s(p.z,by=k,bs="tp") + 
                   s(SiteCode,bs="re"),
                 data=df_md,family = "Gamma"(link="log"))
l_md[[2]] <- gam(diff_S ~ s(p.z,by=k,bs="cr") + 
                   s(SiteCode,bs="re"),
                 data=df_md,family = "Gamma"(link="log"))
l_md[[3]] <- gam(diff_S ~ s(p.z,bs="tp") + s(d.z,bs="tp") + ti(p.z,d.z,bs=c("tp","tp")) +
                   s(SiteCode,bs="re"),
                 data=df_md,family = "Gamma"(link="log"))
l_md[[4]] <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                   s(SiteCode,bs="re"),
                 data=df_md,family = "Gamma"(link="log"))
```


```{r l_md.diff_S.EI__GAMM,eval=FALSE}
l_md.diff_S.EI__GAMM <- l_md
save(l_md.diff_S.EI__GAMM,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM.Rdata")
```

  
```{r AICctab modelos cheios diff_S EI GAMM}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM.Rdata")
AICctab(l_md.diff_S.EI__GAMM,weights=TRUE)
```


O único modelo cheio plausível considera as variáveis p e d (um smoother para cada mais um tensor para ambas) e 1 intercepto por Sítio de Amostragem.


```{r gamm cheio selecionado diff_S MNEI, warning=FALSE,message=FALSE}
appraise(l_md.diff_S.EI__GAMM[["cr ti"]])
```

__Figura 2.5__ Gráficos Diagnostico do gamm cheio mais plausível para diff_S MN==EI

De maneira geral o modelo esta fazendo um bom ajuste, contudo alguns sítios distoam do padrão geral dos dados. Há duas alternativas: i) possibilitar um smoother por sítio de amostragem com um parâmetro de penalização comum; ou ii) remover sítios outliers.

```{r update gamm cheio mais plausivel diff_S MNEI,eval=FALSE,echo=TRUE}
l_md <- vector("list",2)
names(l_md) <- c("1|Site","d|Site")
l_md[[1]] <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                   s(SiteCode,bs="re"),
                 data=df_md,family = "Gamma"(link="log"))
l_md[[2]] <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                   s(d.z,SiteCode,bs="fs",xt="cr"),
                 data=df_md,family = "Gamma"(link="log"))
```

  
```{r l_md.diff_S.EI__GAMM2,eval=FALSE}
l_md.diff_S.EI__GAMM2 <- l_md
save(l_md.diff_S.EI__GAMM2,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM2.Rdata")
```



```{r AICctab gamm cheio diff_S MNEI 2}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM2.Rdata")
AICctab(l_md.diff_S.EI__GAMM2)
```

```{r graf diag gamm2 diff_S MNEI}
gratia::appraise(l_md.diff_S.EI__GAMM2[["d|Site"]])
```

__Figura 2.6__ Gráfico Diagnóstico gamm cheio com segunda estrutra aleatória diff_S MM==EI

```{r diff_S MNEI modelo cheio avaliacao,message=FALSE,warning=FALSE,results="hide"}
gratia::draw(l_md.diff_S.EI__GAMM2[["d|Site"]])
```
  
__Figura 2.7__ gratia::draw() gamm mais plausível com estrutura similar a (d|Site)  
  
Este modelo apresenta problema de concurvidade. Assim vou refazer a comparação com configuração adequada:  

```{r updata gamm cheio mais plausível d Site,eval=FALSE,echo=TRUE}
df_md <- filter(df_resultados,MN=="EI")
md_gam.diff_S.EI__update <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                   s(d.z,SiteCode,bs="fs",xt=list(bs="cp"), m=1),
                 data=df_md,family = "Gamma"(link="log"))
```

```{r md_gam.diff_S.EI__update,eval=FALSE}
save(md_gam.diff_S.EI__update,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/md_diff_S_EI__GAMM_update.Rdata")
```


```{r draw update gamm cheio mais plausivel d Site}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/md_diff_S_EI__GAMM_update.Rdata")
l_md.diff_S.EI__GAMM2[[2]] <- md_gam.diff_S.EI__update
gratia::draw(md_gam.diff_S.EI__update)
```

__Figura 2.8__ Update do modelo da figura 2.7 com o smoother da estrutura aleatória penalizada pela 1a derivada para diminuir a concurvidade (Perdersen et al. 2019)  

O modelo diminuiu a concurvidade da estimativa.
  
```{r  diff_S MNEI gamm cheio segundo plausivel,message=FALSE,warning=FALSE,results="hide",eval=FALSE}
gratia::appraise(md_gam.diff_S.EI__update)
```
  
![](/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/appraise_gamm_diffS_EI_updata.png){ width=100% }  

__Figura 2.9__ Appraise do gamm cheio atualizado (smoother de estrutura aleatória: m=1).  
  
### Remoção de Outliers

Remoção sítios com observações fora do intervalo [-1.5;1.5] dos resíduos deviance.  
  
```{r outliers diffS_MNEI gamm,eval=FALSE,echo=TRUE}
# dados completos
df_md <- df_resultados %>% filter(MN=="EI")
df_md$resDev <- residuals.gam(md_gam.diff_S.EI__update)
# sítios considerados outliers
v_SiteOut <- df_md %>% filter(resDev < -0.15 | resDev > 0.15) %>% .$SiteCode %>% unique
# update da comparação
l_md <- vector("list",2)
names(l_md) <- c("1|Site","d|Site")
l_md[[1]] <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                   s(SiteCode,bs="re"),
                 data=filter(df_md,!(SiteCode %in% v_SiteOut)),
                 family = "Gamma"(link="log"))
l_md[[2]] <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                   s(d.z,SiteCode,bs="fs",xt=list(bs="cp"),m=1),
                 data=filter(df_md,!(SiteCode %in% v_SiteOut)),
                 family = "Gamma"(link="log"))
```

```{r l_md.diff_S.EI__GAMM_sOut,eval=FALSE}
l_md.diff_S.EI__GAMM_sOut <- l_md
save(l_md.diff_S.EI__GAMM_sOut,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM_sOut.Rdata")
```


```{r AICctab gamm cheio sem outliers,eval=TRUE}
load("/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM_sOut.Rdata")
AICctab(l_md.diff_S.EI__GAMM_sOut,weights=TRUE)
```

```{r appraise gamm diffS_EI sOut,eval=TRUE}
gratia::appraise(l_md.diff_S.EI__GAMM_sOut[["d|Site"]])
```

__Figura 2.10__ Gráficos diagnóstico do gamm cheio mais plausível sem outliers

A remoção de outliers não melhorou o ajuste do modelo.

```{r graw gamm cheio diffS_EI sOut,eval=FALSE}
gratia::draw(l_md.diff_S.EI__GAMM_sOut[["d|Site"]])
```

![](/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/draw_gamm_diffS_EIsOut_fig211.png){ width=100% }

__Figura 2.11__ Efeitos estimados para o gamm cheio diffS_EI sOut

### Seleção de Variáveis

```{r gamm diffS_EI selecao de variaveis, eval=FALSE}
# dados completos
df_md <- df_resultados %>% filter(MN=="EI")
df_md$resDev <- residuals.gam(md_gam.diff_S.EI__update)
# sítios considerados outliers
v_SiteOut <- df_md %>% filter(resDev < -0.15 | resDev > 0.15) %>% .$SiteCode %>% unique
# update da comparação
l_md <- vector("list",4)
names(l_md) <- c("p + d + ti(p,d)","p + d","p","d")
l_md[[1]] <- l_md.diff_S.EI__GAMM_sOut[["d|Site"]]
l_md[[2]] <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") +
                   s(d.z,SiteCode,bs="fs",xt=list(bs="cp"),m=1),
                 data=filter(df_md,!(SiteCode %in% v_SiteOut)),
                 family = "Gamma"(link="log"))
l_md[[3]] <- gam(diff_S ~ s(p.z,bs="cr") +
                   s(d.z,SiteCode,bs="fs",xt=list(bs="cp"),m=1),
                 data=filter(df_md,!(SiteCode %in% v_SiteOut)),
                 family = "Gamma"(link="log"))
l_md[[4]] <- gam(diff_S ~ s(d.z,bs="cr") +
                   s(d.z,SiteCode,bs="fs",xt=list(bs="cp"),m=1),
                 data=filter(df_md,!(SiteCode %in% v_SiteOut)),
                 family = "Gamma"(link="log"))
```

```{r l_md.diffS_EI_GAMM_selVars, eval=FALSE}
l_md.diffS_EI_GAMM_selVars <- l_md
save(l_md.diffS_EI_GAMM_selVars,file="/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM_sOut.Rdata")
```

```{r l_md.diffS_EI_GAMM_selVars AICctab,eval=FALSE}
load("/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM_sOut.Rdata")
AICctab(l_md.diffS_EI_GAMM_selVars,weights=TRUE)
```


## Figura Final

```{r gamm diff_S predicao novo conjunto de dados,eval=FALSE}
l_p <- list()
# dados
## MNEE
df_md <- df_resultados %>% filter(MN=="EE")
md_diffS_EE <- lm(diff_S0 ~ 1,data=df_md)
coef_diffS_EE <- summary(md_diffS_EE)$coef
coef_diffS_EE[2]
l_p[[1]] <- ggplot(df_md,aes(y=diff_S0,x="")) + geom_jitter() + stat_summary(fun.data = "mean_cl_boot", colour = "red")
  
## MNEI
df_pred <- df_pred <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1],
                       d.z=seq(min(df_resultados$d.z),max(df_resultados$d.z),length=20),
                       p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=103))
df_pred <- cbind(df_pred,
                 predict(l_md.diff_S.EI__GAMM_sOut[["d|Site"]],df_pred,type="response",se.fit=TRUE)) %>% 
  mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
         d = d.z * sd(df_resultados$d) + mean(df_resultados$d),
         fit_diff_S0 = fit - min(df_resultados$diff_S0) - 0.01,
         se.fit_diff_S0 = se.fit - min(df_resultados$diff_S0) - 0.01,)
df_pred$fit_diff_S0 %>% summary
l_p[[2]] <- ggplot(df_pred,aes(x=p,y=d,fill=fit)) + geom_tile()
```



# Comparação n_nRef e diff_S

```{r comparacao n_nRef e diff_S,fig.height=65,fig.width=11}
# dados
## MN=="EI"
### gamm diffS
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/md_diff_S_EI__GAMM_update.Rdata")
df_EI <- cbind(filter(df_resultados,MN=="EI"),
                 predict.gam(md_gam.diff_S.EI__update,type="response",se.fit=TRUE)) %>% 
  mutate(fit_diffS0 = fit + min(df_resultados$diff_S0) - 0.01)
### glmm nRef
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__MuMIn.Rdata")
df_EI$Pr_nRef <- predict(mdAvg_nRefEI__MuMIn,type="response")*100
## MN=="EI"
### gamm diffS
md_diffS_EE <- lm(diff_S0 ~ 1,data=filter(df_resultados,MN=="EE"))
df_EE <- filter(df_resultados,MN=="EE") %>% 
  mutate(fit_diffS0 = coef(md_diffS_EE))
### glmm nRef
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__MuMIn.Rdata")
df_EE$Pr_nRef <- predict(mdAvg_nRefEE__MuMIn,type="response")*100
## conjunto completo
df_plot <- rbind.fill(df_EE,df_EI) %>%
  mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
df_plot <- rbind.fill(
  select(df_plot,title,d,MN,n_nRef,Pr_nRef) %>% 
    mutate(response_class = "nRef") %>% 
    rename(response_obs=n_nRef,fit_value=Pr_nRef),
  select(df_plot,title,d,MN,diff_S0,fit_diffS0) %>% 
    mutate(response_class = "diff_S") %>% 
    rename(response_obs=diff_S0,fit_value=fit_diffS0)
)
# gráficos
df_plot %>% #filter(title %in% unique(df_plot$title)[1:10]) %>% 
  ggplot(aes(x=d,y=response_obs,group=MN)) +
  geom_point(aes(color=MN),alpha=0.3) +
  geom_line(aes(y=fit_value,color=MN),alpha=0.3) +
  scale_color_manual(values=c("#FF0000", "#000000")) +
  facet_wrap(~title+response_class,ncol=6,scales="free") + labs(y="") +
  theme_light() + theme(legend.position="top")
```

