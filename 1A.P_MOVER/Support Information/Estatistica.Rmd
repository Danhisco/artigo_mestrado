---
title: "Estatistica"
author: "Mori, Danilo"
date: "31/10/2019"
output: 
  html_document:
    toc: true
    toc_depth: 5
---

<style>
body {
text-align: justify}
</style>

<!--  -->

```{r setup, include=TRUE,echo=FALSE}
knitr::opts_chunk$set(echo = FALSE, tidy = FALSE, include = TRUE, warning = FALSE,cache = TRUE,message=FALSE,eval=TRUE)
# setwd("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/")
knitr::opts_knit$set(root.dir = "~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/")
```

```{r pacotes,eval=TRUE,echo=F}
library(gtools)
library(doMC)
library(DHARMa)
library(MuMIn)
library(mgcv)
library(gratia)
library(GUILDS)
library(broom)
library(bbmle)
library(gamm4)
library(lme4)
library(merTools)
library(magrittr)
library(gridExtra)
library(plotly)
library(sjPlot)
library(sjlabelled)
library(sjmisc)
library(ggplot2)
library(stringr)
library(tidyr)
library(plyr)
library(purrr)
library(dplyr)
```

```{r dados,message=FALSE}
### dados ###
# leitura
df_resultados <- read.table(file="./resultados/df_resultados.csv",header = TRUE,sep = ";",dec = ".",as.is=FALSE)
df_resultados$k.0_1 <- 1 - df_resultados$k.0
# padronização
level_k <- unique(as.character(df_resultados$k))
df_resultados$k <- factor(as.character(df_resultados$k),levels = level_k)
levels(df_resultados$k)[19] <- "0.1"
df_resultados %<>% mutate(L_plot = 100*sqrt(Ntotal/DA),
                          d_Lplot = d / L_plot,
                          log_Stotal=log(Stotal))
# z score
f_z <- function(x){
  m <- base::mean(x,na.rm=TRUE)
  sd <- sd(x,na.rm=TRUE)
  output <- (x-m)/sd
  return(output)
} 
# names(df_resultados)
df_resultados.z <- as.data.frame(apply(df_resultados[c("p","Ntotal","log_Stotal","k.0","k.0_1","d_Lplot","d")],2,f_z))
names(df_resultados.z) <- sapply(names(df_resultados.z), function(x) paste(gsub(".0","",x),".z",sep=""))
df_resultados %<>% cbind(.,df_resultados.z)
names(df_resultados)[c(5:6,26,33)] <- c("n_nRef","n_Ref","d_Lplot","d_Lplot.z")
df_resultados.U <- df_resultados %>% filter(MN=="EE") %>% distinct() 
# summary(df_resultados)
df_resultados %<>% mutate(logit_nRef = car::logit(n_nRef/100))
```

# 1 - Número de SADs preditas não refutadas


```{r n_nRef padroes gerais fig11}
l_p <- vector("list",2)
l_p[[1]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[1:10]),
                   aes(x=p,y=n_nRef)) + 
  geom_point() + 
  geom_smooth(method="loess") +
  facet_grid(k~MN)
l_p[[2]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[11:20]),
                   aes(x=p,y=n_nRef)) + 
  geom_point() + 
  geom_smooth(method="loess") +
  facet_grid(k~MN) 
do.call("grid.arrange",c(l_p,ncol=2))
```

__Figura 1.1__ logito(número de SADs não refutadas) ~ p *  k * MN. A linha azul é uma estimativa baseada em 'loess'. 

A figura 1.1 mostra que o padrão geral dos dados não é linear na escala da função de ligação, assim utilizamos GAM. Possibilitamos até 1 intercepto por modelo neutro por sítio de amostragem (MN|SiteCode); para modelos com variáveis de dispersão continua não foi possível um smoother por Sítio de Amostragem e Modelo Neutro



## 1.1 GLMM binomial

### 1.1.1 Modelo Cheio e Auditoria

```{r glmm n_nRef comparacao modelos cheios,include=FALSE,echo=FALSE,eval=FALSE}
l_md <- vector("list",11)
names(l_md) <- c("k0 1|Site","k0 MN|Site","k0 k0*MN|Site",
                 "kf 1|Site","kf MN|Site",
                 "d 1|Site","d MN|Site","d d*MN|Site",
                 "d/L_plot 1|Site","d/L_plot MN|Site","d/L_plot d/L_plot*MN|Site")
l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + I(p.z^2) * k_1.z * MN + (1|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + I(p.z^2) * k_1.z * MN + (MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + I(p.z^2) * k_1.z * MN + (k_1.z*MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[4]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k * MN + I(p.z^2) * k * MN + (1|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[5]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k * MN + I(p.z^2) * k * MN + (MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[6]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d.z * MN + I(p.z^2) * d.z * MN + (1|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[7]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d.z * MN + I(p.z^2) * d.z * MN + (MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[8]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d.z * MN + I(p.z^2) * d.z * MN + (d.z*MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[9]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + I(p.z^2) * d_Lplot.z * MN + (1|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[10]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + I(p.z^2) * d_Lplot.z * MN + (MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[11]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + I(p.z^2) * d_Lplot.z * MN + (d_Lplot.z*MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md_nRef.GLMM <- l_md
save(l_md_nRef.GLMM,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_GLMM.Rdata")
```

__Tabela 1.1 __ AICctab 

```{r AICctab n_nRef p^2 n_nRef,eval=TRUE,cache=FALSE}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_GLMM.Rdata")
bbmle::AICctab(l_md_nRef.GLMM,weights=T)
```


O único modelo plausível é aquele com função de ligação logito, a variável d e a estrutura aleatória MN * d |SiteCode.


```{r auditoria mais plausivel md_n.ref1, message=FALSE}
# library(DHARMa)
md_nRef <- l_md_nRef.GLMM[["d d*MN|Site"]]
# p_plot <- simulateResiduals(md_nRef,n=1000)
# plot(p_plot)
```

__Figura 1.2__ Resíduos Quantílicos do modelo cheio para n_nRef ~ p*d*MN + p^2*d*MN + (d*MN|SiteCode)

NOTA: não entendo o motivo de não rodar os resíduos quantílicos quando compilo o Rmarkdown: 

mensagem de erro:

Error in if (family$family %in% c("binomial","poisson","quasibinomial", : argumento tem comprimento zero Calls: <Anonymous> ... withCallingHandlers -> withVisible -> eval -> eval -> simulateResiduals Além disso: warining message: In checkModel(fittedModel) : DHARMa: fittedModel not in class of supported models. Absolutely no guarantee that this will work


```{r graf diag 2 glmm p^2 n_nRef fig 13, include=FALSE,eval=FALSE}
# teste <- augment(lm(log(Stotal) ~ p,df_resultados)) %>% as.data.frame()
# df_plot <- augment(md_nRef) %>% as.data.frame() # demorando muito
# # df_plot %>% names
# l_p <- vector("list",3)
# l_p[[1]] <- ggplot(df_plot,aes(x=p.z,y=.fitted)) + geom_point(alpha=0.3) + geom_line(aes(group=SiteCode)) + facet_wrap(~MN,ncol=2)
# l_p[[2]] <- ggplot(df_plot,aes(x=I.p.z.2.,y=.fitted)) + geom_point(alpha=0.3) + geom_line(aes(group=SiteCode)) + facet_wrap(~MN,ncol=2)
# l_p[[3]] <- ggplot(df_plot,aes(x=d_Lplot.z,y=.fitted)) + geom_point(alpha=0.3) + geom_line(aes(group=SiteCode)) + facet_wrap(~MN,ncol=2)
# do.call("grid.arrange",c(l_p,ncol=1))
```

<!-- __Figura 1.3__ Valores ajustados contra as preditoras lineares  - ESTA DEMORANDO MUITO PARA RODAR AUGMENT PARA O MODELO MAIS PLAUSIVEL -->
  
### 1.1.2 Modelo cheio: predições

```{r avaliacao por site fig 14,fig.width=8, fig.height=30,message=FALSE}
# Dados
df_plot <- df_resultados
df_plot <- cbind(df_plot,
  predictInterval(merMod = md_nRef,
                         level = 0.95, n.sims=200,
                         stat="median",type = "probability",
                         include.resid.var = TRUE)*100
                 )
df_plot$Pr_nRef <- predict(md_nRef,type="response")*100
# Graficos
df_plot %<>% mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
ggplot(df_plot,aes(x=d.z,y=n_nRef,group=MN)) +
  geom_point(aes(color=MN)) +
  geom_line(aes(y=Pr_nRef,color=MN)) +
  scale_color_manual(values=c("#FF0000", "#000000")) +
  theme_classic() + theme(legend.position="top") + facet_wrap(~title,ncol=5)
```

__Figura 1.3__ Predito e observado por SiteCode  
  

Observamos que é necessário considerar também um termo quadrático para d. Então sigo com a adição de um termo quadrático para d

__Tabela 1.2 __ R2 condicional e marginal do modelo cheio com termo quadrático para p e d 

```{r md_nRef2 e r2cm}
md_nRef2 <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                     (p.z + I(p.z^2)) * (d.z + I(d.z^2)) * MN + ((d.z + I(d.z^2)) * MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
r.squaredGLMM(md_nRef2)
```


```{r md_nRef2 quant res}
p_plot <- simulateResiduals(md_nRef2,n = 1000)
plot(p_plot)
```

__Figura 1.4__ Resíduos quantílicos para o modelo cheio com termos quadráticos para p e d.  


```{r avaliacao por site fig 15 glmm p2 d2,fig.width=8, fig.height=30,message=FALSE}
# Dados
df_plot <- df_resultados
df_plot <- cbind(df_plot,
  predictInterval(merMod = md_nRef2,
                         level = 0.95, n.sims=200,
                         stat="median",type = "probability",
                         include.resid.var = TRUE)*100
                 )
df_plot$Pr_nRef <- predict(md_nRef,type="response")*100
# Graficos
df_plot %<>% mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
ggplot(df_plot,aes(x=d.z,y=n_nRef,group=MN)) +
  geom_point(aes(color=MN)) +
  geom_line(aes(y=Pr_nRef,color=MN)) +
  scale_color_manual(values=c("#FF0000", "#000000")) +
  theme_classic() + theme(legend.position="top") + facet_wrap(~title,ncol=5)
```
  
__Figura 1.5__ Predito pelo modelo com termo quadrático para p e d

O modelo cheio com termo quadrático para p e d não foi foi suficiente para descrever o padrão observado nos dados. Hipotetizamos que a razão é a divergência no grau de variação entre os modelos neutros. Assim iremos ajustar modelos para cada conjunto de dados. Para possibilitar a comparação irei manter a estrutura comum das preditoras porem comparando a estrutura aleatória e função de ligação para cada modelo neutro.
   


## 1.2 GLMM binomail subset:MN==EE

### Modelo cheio

```{r glmm quadratico n_nRef MNEE modelo cheio,include=FALSE,eval=FALSE}
# l_md <- vector("list",3)
# names(l_md) <- c("1|Site","d|Site","d + d^2|Site")
# l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
#                      ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
#                      (1|SiteCode),
#                    family = "binomial",data=filter(df_resultados,MN=="EE"),
#                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
# l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
#                      ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
#                      (d.z|SiteCode),
#                    family = "binomial",data=filter(df_resultados,MN=="EE"),
#                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
# l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
#                      ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
#                      (d.z + I(d.z^2)|SiteCode),
#                    family = "binomial",data=filter(df_resultados,MN=="EE"),
#                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
# l_md_nRef.GLMM_EE <- l_md
# save(l_md_nRef.GLMM_EE,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef.GLMM_EE.Rdata")
```

__Tabela 1.2.1__ AICctab para n_nRef MNEE 

```{r glmm quadratico n_nRef MNEE modelo cheio AICctab}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef.GLMM_EE.Rdata")
AICctab(l_md_nRef.GLMM_EE,weights=TRUE)
```

  
O modelo mais plausível considera um termo linear e quadrático para d na estrutura aletória. 


```{r fig 119 res quant glmm cheio MNEE}
p_plot <- DHARMa::simulateResiduals(l_md_nRef.GLMM_EE[["d + d^2|Site"]],n=1000)
plot(p_plot)  
```
  
__Figura 1.6__ Resíduos Quantílicos do glmm cheio para MNEE    


__Tabela 1.2.2__ R2 condicional e marginal modelo cheio nRef 

```{r tabela md cheio para MNEE nRef}
r.squaredGLMM(l_md_nRef.GLMM_EE[["d + d^2|Site"]])
```

   
```{r avaliacao por site fig 17 glmm EE p2 d2,fig.width=8, fig.height=30,message=FALSE,eval=FALSE,include=FALSE}
# Dados
df_plot <- df_resultados %>% filter(MN=="EE")
df_plot <- cbind(df_plot,
  predictInterval(merMod = l_md_nRef.GLMM_EE[["d + d^2|Site"]],
                         level = 0.95, n.sims=200,
                         stat="median",type = "probability",
                         include.resid.var = TRUE)*100
                 )
# df_plot$Pr_nRef <- predict(md_nRef,type="response")*100
# Graficos
df_plot %<>% mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
ggplot(df_plot,aes(x=d.z,y=n_nRef)) +
  geom_point() +
  geom_line(aes(y=fit),color="red") +
  theme_classic() + theme(legend.position="top") + facet_wrap(~title,ncol=5)
```
  
<!-- __Figura 1.7__ Predito pelo modelo cheio com termo quadrático para p e d para MN=EE -->

  
### Seleção de Variáveis
  


```{r modelo global e R2m/c MNEE, include=TRUE,cache=TRUE}
# dados
df_md <- filter(df_resultados,MN=="EE")
# modelo global
global_md <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (d.z + I(d.z^2)|SiteCode),
                   family = "binomial",data=df_md,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)),na.action = "na.fail")
# r.squaredGLMM(global_md)
```
  
  
__Tabela 1.2.3__ R2 condicional e marginal do modelo global

```{r modelo global dredge e AICctab delta 7 n_nRefEE}
dredge_glmmEE <- dredge(global_md,trace = FALSE,evaluate=TRUE)
subset(dredge_glmmEE,delta<7)
```






```{r model averaging EE MuMIn e AICcmodavg,message=FALSE,include=FALSE,eval=FALSE}
library(AICcmodavg)
# todas as combinações de modelo do modelo cheio
l_md.dredge_nRefEE <- lapply(dredge(global_md,trace = FALSE,evaluate=FALSE), eval)
# Model Averaging for SiteCode predictions
mdAvg_nRefEE__MuMIn <- model.avg(l_md.dredge_nRefEE) #,subset<2
save(mdAvg_nRefEE__MuMIn,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__MuMIn.Rdata")
# Model Averaging for new data predictions
df_pred <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1],
                       d.z=seq(min(df_resultados$d.z),max(df_resultados$d.z),length=20),
                       p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=103))
mdAvg_nRefEE__AICcmodavg <- modavgPred(l_md.dredge_nRefEE,newdata = df_pred) %>%
  cbind(df_pred)
save(mdAvg_nRefEE__AICcmodavg,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__AICcmodavg.Rdata")
```

#### Predito para cada Sítio

Para avaliar o ajuste do modelo ao conjunto de dados utilizo funções do pacote MuMIn (REF) que permite calcular a predição do modelo médio para o conjunto original de dados.  
  

```{r glmm quadratico n_nRef MNEE selecao de variaveis, comment=FALSE, message=FALSE,warning=FALSE,results="hide",fig.width=8, fig.height=30}
# Modelo Global
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__MuMIn.Rdata")
# Predição
df_md$Pr_nRef <- predict(mdAvg_nRefEE__MuMIn,type="response")*100
# Gráfico
df_md %<>% mutate(title = paste0(SiteCode," p=",round(p,3))) %>% arrange(p)
df_md$title <- factor(df_md$title,levels = unique(df_md$title))
ggplot(df_md,aes(x=d_Lplot,y=n_nRef)) + 
  geom_point() + geom_line(aes(y=Pr_nRef),color="red") + 
  labs(x="Dispersão Média per capita / Lado da Área Amostrada",
       y="Número de SADs não Refutadas",
       title="Prob. Não Refutar uma SAD neutra MN=EE") +
  facet_wrap(~title,ncol=5) + theme_classic()
```

__Figura 1.7__ Predições por sítio de amostragem do modelo médio calculado a partir do modelo global 
; pontos: número de SADs neutras refutadas para uma bateria de simulações com um determinada distância média de dispersão; eixo x = distância média de dispersão / largura da área de amostragem; a linha é a probabilidade de não refutar uma SAD neutra segundo a predição média do conjunto de sub-modelos dentro do intervalo de plausibilidade de 7 (Burnham et al 2011)
  
  
#### Predito para novo conjunto de dados  
  
Para avaliar o predito e intervalo de confiança de 95% pelo modelo médio utilizo funções do pacote AICcmodavg (REF).  

```{r fig 18 predito para novo conjunto de dados glmm nRefEE AICcmodavg}
# dados
## modelo médio
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__AICcmodavg.Rdata")
df_plot <- mdAvg_nRefEE__AICcmodavg
# df_plot %>% names
df_plot %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),d = d.z*sd(df_resultados$d) + mean(df_resultados$d))


l_p.nRefEE_AICcmodavg <- list()
l_p.nRefEE_AICcmodavg[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Prob de não Refutar",
       fill="Probability") + theme_classic()
l_p.nRefEE_AICcmodavg[[2]] <- ggplot(df_plot,aes(x=p,y=d,fill=lower.CL)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Lower IC (5%)",
       fill="Probability") + theme_classic()
l_p.nRefEE_AICcmodavg[[3]] <- ggplot(df_plot,aes(x=p,y=d,fill=upper.CL)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Upper IC (95%)",
       fill="Probability") + theme_classic()
grid.arrange(l_p.nRefEE_AICcmodavg[[1]],l_p.nRefEE_AICcmodavg[[2]],l_p.nRefEE_AICcmodavg[[3]],
             layout_matrix=rbind(rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 c(2,2,3,3),
                                 c(2,2,3,3))
             )
```
  
__Figura 1.8__ Efeito predito de d e p na Probabilidade de não refutar segundo o modelo médio para MN==EE.  No painel superior a predição média, nos paineis inferiores o intervalo de confiança.  
  
COISAS PARA FAZER FIG 18:
i) melhorar a figura
ii) comparar com o mesmo gráfico para o predito e IC bootsrap para o modelo cheio [SUGESTÃO POR EMAIL PI]

  
  
```{r codigo para IC bootstrap apenas para modelos nao medios,include=FALSE}
## novo conjunto de dados
# df_pred <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1],
#                        # MN=levels(df_resultados$MN),
#                        d_Lplot.z=seq(min(df_resultados$d_Lplot.z),max(df_resultados$d_Lplot.z),length=20),
#                        p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=103))
# # funções para predição condicional e marginal
# f1 <- function(.) predict(., newdata=df_pred) # marginal
# f2 <- function(.) predict(., newdata=df_pred, re.form=~0) # condicional
# # bootstrap
# b3 <- bootMer(global_md, FUN = f1, nsim=1000, parallel="multicore", ncpus=2)
# b4 <- bootMer(global_md, FUN = f2, nsim=1000, parallel="multicore", ncpus=2)
# l_bstrap.nRefEE <- list(marginal = b3, condicional = b4)
# save(l_bstrap.nRefEE,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_bstrap.nRefEE.Rdata")
```


```{r grafico de IC bootstrap nRefEE, include=FALSE,eval=FALSE}
# load(l_bstrap.nRefEE,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_bstrap.nRefEE.Rdata")
# # métricas de interesse
# df_pred %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
#                     d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
# df_pred$mean <- apply(l_bstrap.nRefEE$marginal,2,mean)
# df_pred$IC.low <- apply(l_bstrap.nRefEE$marginal,2,quantile, 0.025)
# df_pred$IC.upp <- apply(l_bstrap.nRefEE$marginal,2,quantile, 0.975)
# df_pred %<>% mutate(IQR_95IC_marginal = IC.upp - IC.low)
# df_pred$mean.fixed <- apply(b4$t,2,mean)
# df_pred$IC.low.fixed <- apply(b4$t,2,quantile, 0.025)
# df_pred$IC.upp.fixed <- apply(b4$t,2,quantile, 0.975)
```


## 1.3 n_nRef subset:MN==EI  
  
  
```{r glmm quadratico n_nRef MNEI modelo cheio,include=FALSE,eval=FALSE}
l_md <- vector("list",3)
names(l_md) <- c("1|Site","d|Site","d + d^2|Site")
l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (1|SiteCode),
                   family = "binomial",data=filter(df_resultados,MN=="EI"),
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (d.z|SiteCode),
                   family = "binomial",data=filter(df_resultados,MN=="EI"),
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (d.z + I(d.z^2)|SiteCode),
                   family = "binomial",data=filter(df_resultados,MN=="EI"),
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md_nRef.GLMM_EI <- l_md
save(l_md_nRef.GLMM_EI,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef.GLMM_EI.Rdata")
```


__Tabela 1.3.1__ AICctab n_nRef MNEI  

```{r glmm quadratico n_nRef MNEI modelo cheio AICctab}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef.GLMM_EI.Rdata")
AICctab(l_md_nRef.GLMM_EI,weights=TRUE)
```

A função AICcmodavg::modavgPred aceita apenas a função de ligação canonica logito, então não irei comparar outras funções de ligação
O modelo mais plausível considera um termo linear e quadrático para d na estrutura aletória. Segue seleção de variáveis.

__Tabela 1.3.2__ R2 marginal e condicional n_nRef MNEI  
  

```{r r2mc nRefEI}
r.squaredGLMM(l_md_nRef.GLMM_EI[["d + d^2|Site"]])
```


```{r fig 19 res quant glmm cheio MNEI}
p_plot <- DHARMa::simulateResiduals(l_md_nRef.GLMM_EI[["d + d^2|Site"]],n=1000)
plot(p_plot)  
```
  
__Figura 1.9__ Resíduos Quantílicos do glmm cheio mais plausível para MNEI   
     

```{r modelo global n_nRef e R2m/c MNEI, include=TRUE,echo=TRUE,cache=TRUE}
# dados
df_md <- filter(df_resultados,MN=="EI")
# modelo global
global_md <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (d.z + I(d.z^2)|SiteCode),
                   family = "binomial",data=df_md,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)),na.action = "na.fail")
```

__Tabela 1.3.3__ AICctab n_nRef MNEI delta<7  
  
   

```{r modelo dredge AICctab nRefEI}
dredge_glmmEI <- dredge(global_md,trace = FALSE,evaluate=TRUE)
subset(dredge_glmmEI,delta<7)
```



```{r model averaging EI MuMIn e AICcmodavg,message=FALSE,include=FALSE,eval=FALSE}
# todas as combinações de modelo do modelo cheio
l_md.dredge_nRefEI <- lapply(dredge(global_md,trace = FALSE,evaluate=FALSE), eval)
# Model Averaging for SiteCode predictions
mdAvg_nRefEI__MuMIn <- model.avg(l_md.dredge_nRefEI) #,subset<2
save(mdAvg_nRefEI__MuMIn,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__MuMIn.Rdata")
# Model Averaging for new data predictions
df_pred <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1],
                       d.z=seq(min(df_resultados$d.z),max(df_resultados$d.z),length=20),
                       p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=103))
mdAvg_nRefEI__AICcmodavg <- AICcmodavg::modavgPred(l_md.dredge_nRefEI,newdata = df_pred) %>%
  cbind(df_pred)
save(mdAvg_nRefEI__AICcmodavg,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__AICcmodavg.Rdata")
```

##### Predito para cada Sítio

Para avaliar o ajuste do modelo ao conjunto de dados utilizo funções do pacote MuMIn (REF) que permite calcular a predição do modelo médio para o conjunto original de dados.  
  

```{r glmm quadratico n_nRef MNEI selecao de variaveis, comment=FALSE, message=FALSE,warning=FALSE,results="hide",fig.width=8, fig.height=30}
# Modelo Global
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__MuMIn.Rdata")
# Predição
df_md$Pr_nRef <- predict(mdAvg_nRefEI__MuMIn,type="response")*100
# Gráfico
df_md %<>% mutate(title = paste0(SiteCode," p=",round(p,3))) %>% arrange(p)
df_md$title <- factor(df_md$title,levels = unique(df_md$title))
ggplot(df_md,aes(x=d_Lplot,y=n_nRef)) + 
  geom_point() + geom_line(aes(y=Pr_nRef),color="red") + 
  labs(x="Dispersão Média per capita / Lado da Área Amostrada",
       y="Número de SADs não Refutadas",
       title="Prob. Não Refutar uma SAD neutra MN=EI") +
  facet_wrap(~title,ncol=5) + theme_classic()
```  

__Figura 1.10__ Predito por SiteCode a partir do modelo médio para MNEI.  
  
  
      
  
```{r fig 111 predito para novo conjunto de dados glmm nRefEI AICcmodavg}
# dados
## modelo médio
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__AICcmodavg.Rdata")
df_plot <- mdAvg_nRefEI__AICcmodavg
# df_plot %>% names
df_plot %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),d = d.z*sd(df_resultados$d) + mean(df_resultados$d))


l_p.nRefEI_AICcmodavg <- list()
l_p.nRefEI_AICcmodavg[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Prob de não Refutar",
       fill="Probability") + theme_classic()
l_p.nRefEI_AICcmodavg[[2]] <- ggplot(df_plot,aes(x=p,y=d,fill=lower.CL)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Lower IC (5%)",
       fill="Probability") + theme_classic()
l_p.nRefEI_AICcmodavg[[3]] <- ggplot(df_plot,aes(x=p,y=d,fill=upper.CL)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Upper IC (95%)",
       fill="Probability") + theme_classic()
grid.arrange(l_p.nRefEI_AICcmodavg[[1]],l_p.nRefEI_AICcmodavg[[2]],l_p.nRefEI_AICcmodavg[[3]],
             layout_matrix=rbind(rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 c(2,2,3,3),
                                 c(2,2,3,3))
             )
```
  
__Figura 1.11__ Efeito predito de d e p na Probabilidade de não refutar segundo o modelo médio para MN==EE.  No painel superior a predição média, nos paineis inferiores o intervalo de confiança.  



## 1.4 Figura Final





```{r figura final n_nRef }
#############
# dados
## MNEE
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__AICcmodavg.Rdata")
mdAvg_nRefEE__AICcmodavg$MN <- "EE"
## MNEI
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__AICcmodavg.Rdata")
mdAvg_nRefEI__AICcmodavg$MN <- "EI"
## df comum
df_plot <- rbind(mdAvg_nRefEE__AICcmodavg,mdAvg_nRefEI__AICcmodavg)
df_plot %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
                    d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
## Gráficos
l_p.nRefEE_AICcmodavg <- list()
labels_IC <- c(lower.CL="IC 5%", upper.CL="IC 95%")
## predição média para ambos modelos
l_p.nRefEE_AICcmodavg[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(
    # title="Probabilidade de Não Refutar",
       fill="Probability") +
  theme_classic() + facet_wrap(~MN,ncol=2) + theme(legend.position="top")
## IC para MNEE
df_plotEE <- df_plot %>% filter(MN=="EE") %>%
  gather(key = IC_class ,value = IC_pred,lower.CL:upper.CL)
l_p.nRefEE_AICcmodavg[[2]] <- ggplot(df_plotEE,aes(x=p,y=d,fill=IC_pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  theme_classic() + facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) + theme(legend.position='none')
## IC para MNEI
df_plotEI <- df_plot %>% filter(MN=="EI") %>%
  gather(key = IC_class ,value = IC_pred,lower.CL:upper.CL)
l_p.nRefEE_AICcmodavg[[3]] <- ggplot(df_plotEI,aes(x=p,y=d,fill=IC_pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  theme_classic() + facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) + theme(legend.position='none')
## Arranjo dos gráficos
grid.arrange(l_p.nRefEE_AICcmodavg[[1]],l_p.nRefEE_AICcmodavg[[2]],l_p.nRefEE_AICcmodavg[[3]],
             layout_matrix=rbind(rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 c(2,2,3,3),
                                 c(2,2,3,3))
             )


```


__Figura 1.12__ Probabilidade de não refutar uma SAD neutra em função do modelo neutro (EE e EI), proporção de cobertura vegetal (p) e distância média de dispersão (d)


<!-- # diff_S = (S_obs - S_MN)/S_obs -->

<!-- ## Padrão Geral -->

<!-- ```{r preparacao dos dados 1} -->
<!-- df_resultados %<>% mutate(diff_S0 = (Stotal-S.MN_mean)/Stotal) -->
<!-- df_resultados$diff_S <- df_resultados$diff_S0 + min(df_resultados$diff_S)*(-1) + 0.01 -->
<!-- # hist(df_resultados$diff_S0,breaks=60) -->
<!-- # boxplot(I(df_resultados$diff_S0)) -->
<!-- ggplot(df_resultados,aes(x=log(Stotal),y=diff_S,group=MN)) + -->
<!--   geom_point() + -->
<!--   geom_smooth(method="loess") +  -->
<!--   ylab("(Sobs-S_MN)/Sobs") + -->
<!--   facet_wrap(~k,ncol=5,scales="free") -->
<!-- ``` -->

<!-- __Figura 2.1__ diff_S = (S_obs - S_MN)/S_obs + (-1) * min(diff_S) + 0.01, inclinação_MNEE ~ 0 para todo k. -->

<!-- Parece que existem alguns outliers. De maneira geral MNEE apresenta boa congruência com os dados enquanto o comportamento de MNEI depende da dispersão: para k->100% o desvio aumento para ps extremos (bimodal/quadratica), apresentando boa congruência para proporção intermediárias de habitat, mas sempre subestimando S_obs. Com o aumento da capacidade de dispersão as estimavas de S se tornam mais próximas ao observado para p>0.5, superestimando o observado para valores elevados de p e k>0.5 o que leva a reduzir a porção de p em que MNEI faz uma boa aproximação. -->


<!-- # U - taxa de especiação necessária para obter a riqueza observada no equilíbrio -->

<!-- ## Padrões Gerais -->

<!-- ```{r padroes gerais U,echo=FALSE,fig.width=6,fig.height=4} -->
<!-- # graficos -->
<!-- l_p <- vector("list",4) -->
<!-- l_p[[1]] <- ggplot(df_resultados,aes(x=k,y=U_med)) + -->
<!--   geom_point() + -->
<!--   geom_line(aes(group=SiteCode)) + -->
<!--   geom_boxplot(aes(group=k)) -->
<!-- l_p[[2]] <- ggplot(df_resultados,aes(x=p,y=U_med)) + -->
<!--   geom_point() + -->
<!--   geom_smooth(method = "auto") + -->
<!--   labs(y="") -->
<!-- l_p[[3]] <- ggplot(df_resultados,aes(x=log(Stotal),y=U_med)) + -->
<!--   geom_point() + -->
<!--   geom_smooth(method = "auto") -->
<!-- l_p[[4]] <- ggplot(df_resultados,aes(x=p,y=log(Stotal))) + -->
<!--   geom_point() + -->
<!--   geom_smooth(method="auto") -->
<!-- do.call("grid.arrange",c(l_p,ncol=2)) -->
<!-- ``` -->

<!-- __Figura 3.1__ Padrões gerais de U_med: ~ k (% de propágulos até a vizinhança imediata da planta progenitora); ~ Stotal (riqueza observada na área amostral). E o padrão empírico encontrado nos dados Stotal ~ p -->


<!-- ```{r padroes gerais U por SiteCode,echo=FALSE,fig.height=50,fig.width=12,include=FALSE} -->
<!-- # dados -->
<!-- df_plot <- df_resultados %>% select(SiteCode,p,U_med,k,d_Lplot) %>% -->
<!--   mutate(label_facet.wrap = paste0(SiteCode,";p=",round(p,4))) %>% -->
<!--   distinct() %>% arrange(p) -->
<!-- levels_label <- unique(df_plot$label_facet.wrap) -->
<!-- df_plot$label_facet.wrap <- factor(df_plot$label_facet.wrap,levels = levels_label) -->
<!-- # graficos -->
<!-- l_p <- vector("list",2) -->
<!-- l_p[[1]] <- ggplot(df_plot,aes(x=k,U_med)) + -->
<!--   geom_point() + -->
<!--   geom_line(aes(group=SiteCode)) + -->
<!--   facet_wrap(~label_facet.wrap,ncol=5,scales="free") + -->
<!--   ggtitle(label="eixo x = k") -->
<!-- l_p[[2]] <- ggplot(df_plot,aes(x=d_Lplot,U_med)) + -->
<!--   geom_point() + -->
<!--   geom_line(aes(group=SiteCode)) + -->
<!--   facet_wrap(~label_facet.wrap,ncol=5,scales="free") + -->
<!--   ggtitle(label="eixo x = d / L_plot") -->
<!-- do.call("grid.arrange",c(l_p,ncol=1)) -->
<!-- ``` -->

<!-- <!-- __Figura 3.2__ Padrões gerais de U_med por SiteCode: ~ k (% de propágulos até a vizinhança imediata da planta progenitora); ~ d / L_plot (distância média de dispersão / Lado do área amostral) --> -->


<!-- ## GAMM -->

<!-- Como os modelos com estrutura aleatória mais complexa levam muito tempo para estimar, irei começar com a estrutura aleatória mais simples para avaliar qual a melhor variável de dispersão e se for necessário refazer a seleção da estrutura aleatória. -->

<!-- <!-- Para descrever o padrão de U em função da proporção de habitat disponível e da diminuição da limitação de dispersão vamos utilizar GAMM (generalized additive mixed models, Wood 2017). Há pelo menos 3 formas de descrevermos o padrão global (Pedersen et al. 2019): a) um intercepto por SiteCode (1|SiteCode); b) um smoother por SiteCode (dispersão | SiteCode), porém com penalização para aqueles smoothers muito distintos do padrão global; e c) um smoother por SiteCode (dispersão | SiteCode) com seu próprio parâmetro de 'flexibilidade' (smoothing parameter).    --> -->

<!-- <!-- GAMM oferecem grande flexibilidade ao custo de aumento do número de parâmetros estimados e do custo computacional, além da perda de interpretabilidade. Então irei começar por um modelo cuja estrutura aleatória é a mais simples possível (1 intercepto por SiteCode) para poder oferecer mais flexibilidade para o tensor(variável_dispersão,p).    --> -->

<!-- <!-- ### Seleção de Modelo cheio   --> -->

<!-- <!-- - 2 famílias: gaussian e gamma   --> -->
<!-- <!-- - 3 funções de ligação: identity (apenas para gaussian), log, inverse   --> -->
<!-- <!-- - 2 variáveis concorrentes para descrever a dispersão: (1 - k) e (d/L_plot)   --> -->
<!-- <!-- - log_Stotal.z como preditora linear   --> -->
<!-- <!-- - (1|SiteCode) como estrutura aleatória   --> -->

<!-- <!-- __exemplo de código:__   --> -->
<!-- <!-- gam(U_med ~ s(d_Lplot.z) + s(p.z) + ti(d_Lplot.z,p.z) +   --> -->
<!-- <!--                       log_Stotal.z +   --> -->
<!-- <!--                       s(SiteCode,bs="re"),   --> -->
<!-- <!--                     family="gaussian",   --> -->
<!-- <!--                     data = df_resultados, method = "REML",control=ctrl)   --> -->

<!-- __Tabela de Seleção do Modelo Mais plausível:__   -->

<!-- ```{r selecao de modelo cheio GAMM(U)} -->
<!-- ctrl <- list(nthreads=3) #número de cores para paralelizar -->
<!-- l_md.U <- vector("list",length = 15) -->
<!-- names(l_md.U) <- c("d id normal","d log normal", "d inverse normal", "d log gamma", "d inverse gamma", -->
<!--                  "1-k id normal","1-k log normal", "1-k inverse normal", "1-k log gamma", "1-k inverse gamma", -->
<!--                  "k.f id normal","k.f log normal", "k.f inverse normal", "k.f log gamma", "k.f inverse gamma") -->
<!-- l_md.U[[1]] <- gam(U_med ~ s(d_Lplot) + s(p) + ti(d_Lplot,p) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family="gaussian", -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[2]] <- gam(U_med ~ s(d_Lplot) + s(p) + ti(d_Lplot,p) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=gaussian(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[3]] <- gam(U_med ~ s(d_Lplot) + s(p) + ti(d_Lplot,p) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=gaussian(link = "inverse"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[4]] <- gam(U_med ~ s(d_Lplot) + s(p) + ti(d_Lplot,p) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[5]] <- gam(U_med ~ s(d_Lplot) + s(p) + ti(d_Lplot,p) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "inverse"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- # k_1 -->
<!-- l_md.U[[6]] <- gam(U_med ~ s(k.0_1) + s(p) + ti(k.0_1,p) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family="gaussian", -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[7]] <- gam(U_med ~ s(k.0_1) + s(p) + ti(k.0_1,p) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=gaussian(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[8]] <- gam(U_med ~ s(k.0_1) + s(p) + ti(k.0_1,p) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=gaussian(link = "inverse"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[9]] <- gam(U_med ~ s(k.0_1) + s(p) + ti(k.0_1,p) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[10]] <- gam(U_med ~ s(k.0_1) + s(p) + ti(k.0_1,p) + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "inverse"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- # k.f -->
<!-- l_md.U[[11]] <- gam(U_med ~ s(p,k,bs="fs") + k + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family="gaussian", -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[12]] <- gam(U_med ~ s(p,k,bs="fs") + k + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=gaussian(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[13]] <- gam(U_med ~ s(p,k,bs="fs") + k + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=gaussian(link = "inverse"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[14]] <- gam(U_med ~ s(p,k,bs="fs") + k + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "log"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- l_md.U[[15]] <- gam(U_med ~ s(p,k,bs="fs") + k + -->
<!--                   s(log_Stotal) + -->
<!--                   s(SiteCode,bs="re"), -->
<!--                 family=Gamma(link = "inverse"), -->
<!--                 data = df_resultados.U, method = "REML",control=ctrl) -->
<!-- AICctab(l_md.U,weights=TRUE) -->
<!-- # save(l_md.U,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_U.Rdata") -->
<!-- ``` -->

<!-- Segue gráficos diagnosticos do modelo mais plausível -->


<!-- ```{r diag gamm(U) modelo cheio} -->
<!-- appraise(l_md.U[["d log gamma"]]) -->
<!-- ``` -->

<!-- __Figura 3.2__ Gráficos Diagnóstico do modelo mais plausível -->

<!-- O modelo apresenta boa congruência com os dados, porém parece existir outliers  no entando. -->

<!-- ```{r avaliacao outliers gammU} -->
<!-- # install.packages("mgcViz") -->
<!-- # library(mgcViz) -->
<!-- df_mdU <- augment(l_md.U[["d log gamma"]]) -->
<!-- # df_mdU %>% str -->
<!-- l_p <- vector("list",length = 2) -->
<!-- l_p[[1]] <- ggplot(df_mdU,aes(x=.fitted,y=.hat)) + -->
<!--   geom_point() -->
<!-- l_p[[2]] <- ggplot(df_mdU,aes(x=.fitted,y=.cooksd)) + -->
<!--   geom_point() -->
<!-- l_p[[3]] <- ggplot(df_mdU,aes(x=.fitted,y=.resid)) + -->
<!--   geom_point() -->
<!-- do.call("grid.arrange",c(l_p,ncol=3)) -->
<!-- ``` -->

<!-- __Figura 3.3__ Métricas de influência dos dados (broom::augment()) -->

<!-- Exclui os dois sítios com valores de grande influência do conjunto de dados: -->

<!-- ```{r modelo mais plausivel sem outliers U_med} -->
<!-- Site_outliers <- df_mdU %>% filter(.fitted < -7.5 & .resid < -0.5 | .cooksd > 0.01) %>% .$SiteCode %>% unique -->
<!-- md_U.sOut <- update(l_md.U[["d log gamma"]],data=filter(df_resultados.U,!(SiteCode %in% Site_outliers))) -->
<!-- appraise(md_U.sOut) -->
<!-- ``` -->

<!-- __Figura 3.4__ Grafico diagnostico do modelo mais plausivel sem os outliers. -->

<!-- ```{r draw md_U} -->
<!-- gratia::draw(md_U.sOut) -->
<!-- ``` -->

<!-- __Figura 4.5__ Efeitos Parciais do modelo mais plausível   -->



<!-- # Parâmetros dos Modelos Neutros -->

<!-- ## d / L_plot -->

<!-- ### padrões gerais   -->

<!-- ```{r d_Lplot padroes gerais} -->
<!-- ggplot(df_resultados,aes(x=k,y=d_Lplot)) + geom_jitter() + geom_boxplot() -->
<!-- ``` -->

<!-- __Figura 5.1.1__ d/Lplot ~ k -->

<!-- ### Descrição Estatística -->

<!-- ```{r md d_Lplot} -->
<!-- md_d_plot <- gam(d ~ k + s(DA,by=k) + s(SiteCode,bs="re"), -->
<!--                  data=filter(df_resultados,MN=="EE"), -->
<!--                  family = Gamma(link="log"),method = "REML") -->
<!-- # md_d_plot.Normal <- gam(d ~ k + s(DA,by=k) + s(SiteCode,bs="re"),data=filter(df_resultados,MN=="EE")) # , family = Gamma(link = "inverse")  -->
<!-- gratia::appraise(md_d_plot) -->
<!-- show("exp(coef):") -->
<!-- exp(coef(md_d_plot)[1:20]) -->
<!-- # df_plot <- cbind(filter(df_resultados,MN=="EE"), -->
<!-- #                  predict(md_d_plot,type="response",se=TRUE)) -->
<!-- # ggplot(df_plot,aes(x=k,y=d)) + geom_jitter() + geom_boxplot(aes(y=fit)) -->
<!-- ``` -->

<!-- __Figura 5.1.2__ Gráficos Diagnósticos do modelo gam(d ~ k + s(DA,by=k), family=Gamma(link="log")). Exponenciação dos coeficientes parametricos estimados pelo modelo.  -->

<!-- ## m' -->

<!-- ### padrões gerais -->

<!-- ```{r padroes gerais m} -->
<!-- # df_resultados %>% names -->
<!-- # df_resultados %>% ggplot(aes(x=p,y=m_)) + geom_point() + geom_smooth() + facet_wrap(~k,ncol=4,scales="free") -->
<!-- df_resultados %>% ggplot(aes(x=k,y=m_)) + geom_jitter() + geom_boxplot() -->
<!-- hist(I(df_resultados$m_),breaks=60) -->
<!-- ``` -->

<!-- __Figura 5.2.1__ m' ~ p (~k). A variável m' é uma função de p, d e I(1/J) -->

<!-- ### Descrição Estatística -->

<!-- ```{r md_m_ e diagnostico} -->
<!-- l_md_m <- vector("list",length = 2) -->
<!-- l_md_m[[1]] <- gam(m_ ~ s(p) + s(d) + ti(p,d) + s(I(1/Ntotal)) + s(SiteCode,bs="re"),  -->
<!--                    family = Gamma(link = "log"),filter(df_resultados,MN=="EI"),method="REML") -->
<!-- l_md_m[[2]] <- gam(m_ ~ k + s(p,by=k) + s(I(1/Ntotal)) + s(SiteCode,bs="re"),  -->
<!--                    family = Gamma(link = "log"),filter(df_resultados,MN=="EI"),method="REML") -->
<!-- l_md_m[[3]] <- glmer(m_ ~ k * p + I(1/Ntotal) + (1|SiteCode),  -->
<!--                    family = Gamma(link = "log"),filter(df_resultados,MN=="EI")) -->

<!-- AICctab(l_md_m,weights=TRUE) -->
<!-- appraise(l_md_m[[2]]) -->
<!-- # gratia::draw(l_md_m[[2]]) -->
<!-- ``` -->

<!-- __Figura 5.2.2__ Diagnostico do modelo mais plausivel -->

<!-- ## theta -->

<!-- ### padrões gerais -->

<!-- ```{r padroes gerais theta} -->
<!-- df_resultados %>% ggplot(aes(x=p,y=log(theta))) + geom_point() + facet_wrap(~k,ncol=4,scales="free") -->
<!-- # hist(df_resultados$theta,breaks=60) -->
<!-- ``` -->

<!-- __Figura 5.3.1__ Padrão Geral de theta considerando escala log -->

<!-- ### Descrição Estatística -->

<!-- ```{r md theta} -->
<!-- md_theta <- glmer(theta ~ I(p*U_med)*k + (1|SiteCode), family=gaussian(link = "log"),data=filter(df_resultados,MN=="EI")) -->
<!-- df_theta <- augment(md_theta) -->
<!-- p_plot <- DHARMa::simulateResiduals(md_theta,n=1000) -->
<!-- plot(p_plot) -->
<!-- ``` -->


<!-- # Apendice: código extra -->

<!-- ## n_nRef: GAMM -->

<!-- ### Comparação de Modelos Cheios -->


<!-- ```{r gam binomial n_nRef selecao de variaveis, echo=TRUE} -->
<!-- l_md <- vector("list",6) -->
<!-- names(l_md) <- c("k 1|SiteCode", "k MN|SiteCode", -->
<!--                  "k_1 1|SiteCode","k_1 MN|SiteCode", -->
<!--                  "d/L 1|SiteCode","d/L MN|SiteCode") -->
<!-- # muitos parametros para poucos dados "k_1 k_1 * MN|SiteCode","d_Lplot d_Lplot * MN|SiteCode") -->
<!-- # k -->
<!-- l_md[[1]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs") + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "REML") -->
<!-- l_md[[2]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs") + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "REML") -->
<!-- # k_1 -->
<!-- l_md[[3]] <- gam(cbind(n_nRef,100-n_nRef) ~ MN + s(p.z,by=MN,bs="tp") + s(k_1.z,by=MN,bs="tp") + ti(p.z,k_1.z,by=MN,bs=c("tp","tp")) + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "REML") -->
<!-- l_md[[4]] <- gam(cbind(n_nRef,100-n_nRef) ~ MN +  s(p.z,by=MN,bs="tp") + s(k_1.z,by=MN,bs="tp") + ti(p.z,k_1.z,by=MN,bs=c("tp","tp")) + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "REML") -->
<!-- # d/L -->
<!-- l_md[[5]] <- gam(cbind(n_nRef,100-n_nRef) ~ MN + s(p.z,by=MN,bs="tp") + s(d_Lplot.z,by=MN,bs="tp") + ti(p.z,d_Lplot.z,by=MN,bs=c("tp","tp")) + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "REML") -->
<!-- l_md[[6]] <- gam(cbind(n_nRef,100-n_nRef) ~ MN +  s(p.z,by=MN,bs="tp") + s(d_Lplot.z,by=MN,bs="tp") + ti(p.z,d_Lplot.z,by=MN,bs=c("tp","tp")) + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "REML") -->
<!-- AICctab(l_md,weights=TRUE) -->
<!-- # save(l_md,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/md_nRef.Rdata") -->
<!-- # load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/md_nRef.Rdata") -->
<!-- ``` -->

<!-- O único modelo plausível considera a variável k (fator) e estrutura aleatória MN|SiteCode.  -->

<!-- ```{r comparacao setting up do modelo mais plausivel n_nRef} -->
<!-- l_md.nRef1 <- vector("list",length = 2) -->
<!-- names(l_md.nRef1) <- c("by=k","by=MN") -->
<!-- l_md.nRef1[[2]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs") + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "REML") -->
<!-- l_md.nRef1[[1]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,MN,by=k,bs="fs") + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "REML") -->
<!-- AICctab(l_md.nRef1,weights=TRUE) -->
<!-- ``` -->


<!-- ### Diagnostico do Modelo Cheio    -->

<!-- ```{r appraise l_md[[k MN|SiteCode]] 1,message=FALSE} -->
<!-- appraise(l_md[["k MN|SiteCode"]]) -->
<!-- ``` -->

<!-- __Figura 1.2__ appraise(gam( cbind(n_nRef,100-n_nRef) ~ k*MN + s(p.z,MN,by=k), binomial(logit) )   -->

<!-- O modelo mais plausível não apresenta boa congruência com os dados: a distribuição binomial não parece se adequar bem aos dados e o predito e observado podem ser muito divergentes. -->

<!-- ```{r sumario md_nRef mais plausivel,include=FALSE} -->
<!-- # summary(l_md[["k MN|SiteCode"]]) -->
<!-- ``` -->


<!-- ```{r predicao n_nRef} -->
<!-- ## modelo mais plausível -->
<!-- df_pred.k <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1], -->
<!--                           MN=levels(df_resultados$MN), -->
<!--                           k=levels(df_resultados$k), -->
<!--                           p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=103)) %>%  -->
<!--   mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p)) -->
<!-- df_pred.k <- cbind(df_pred.k, -->
<!--                    predict.gam(l_md[["k MN|SiteCode"]], -->
<!--                            df_pred.k,type="response",se.fit=TRUE)) -->
<!-- df_pred.k[,c("fit","se.fit")] <- df_pred.k[,c("fit","se.fit")]*100 -->
<!-- # df_pred.k1 <- cbind(df_resultados, -->
<!-- #                     predict.gam(l_md[["k MN|SiteCode"]],type="response",se.fit=TRUE))  -->
<!-- # df_pred.k1[,c("fit","se.fit")] <- df_pred.k1[,c("fit","se.fit")]*100 -->

<!-- # plot(df_pred.k1$n_nRef ~ df_pred.k1$fit) -->

<!-- #### -->
<!-- ggplot(df_pred.k,aes(x=p,y=fit,color=MN)) + -->
<!-- geom_line() +  -->
<!-- facet_wrap(~k,ncol=4) + -->
<!-- labs(title = "MN*k + s(p,k,by=MN,bs=fs)") + ylab("logito(não refutar)") + -->
<!-- scale_color_manual(values=c("#FF0000", "#000000")) -->
<!-- ``` -->

<!-- __Figura 1.3__ Probabilidade de não refutar uma SAD neutra para cada modelo estatístico (título dos paineis); na esquerda o modelo mais plausível, na esquerda o segundo modelo plausível (>1000 deltaAIC). Os valores médios de cada modelo neutro apresentam semelhante entre os dois gráficos, contudo o modelo mais plausível apresenta maior flexibilidade na descrição dos modelos. -->


<!-- ```{r predito e observado n_nRef graficos fig 1.3,message=FALSE} -->
<!-- # código adaptado de Pedersen et al. 2017 Support Information -->
<!-- # gráficos -->
<!-- df_plot <- df_resultados -->
<!-- df_plot$logit_nRef <- car::logit(df_resultados$n_nRef/100) -->
<!-- l_p <- vector("list",2) -->
<!-- l_p[[1]] <- ggplot(filter(df_plot,k %in% levels(df_resultados$k)[1:10]),aes(x=p,y=n_nRef)) +  -->
<!--   geom_point(alpha=0.3) + facet_grid(k~MN) + -->
<!--   # k -->
<!--   geom_ribbon(aes(ymin=I(fit - 2*se.fit), ymax=I(fit + 2*se.fit), x=p), -->
<!--               data=filter(df_pred.k,k %in% levels(df_resultados$k)[1:10]), -->
<!--               alpha=0.3, -->
<!--               inherit.aes=FALSE, -->
<!--               color="red") + -->
<!--   geom_line(aes(y=fit),color="white", data=filter(df_pred.k,k %in% levels(df_resultados$k)[1:10])) + -->
<!--   ylab("logit(not ref. SAD)") + xlab("Proportion of Tree Cover") + theme_classic() -->
<!--   # theme(panel.background = element_rect(fill = "gray"), -->
<!--   #       panel.grid.major = element_blank(), -->
<!--   #       panel.grid.minor = element_blank()) -->
<!-- l_p[[2]] <- ggplot(filter(df_plot,k %in% levels(df_resultados$k)[11:20]),aes(x=p,y=n_nRef)) +  -->
<!--   geom_point(alpha=0.3) + facet_grid(k~MN) + -->
<!--   # k -->
<!--   geom_ribbon(aes(ymin=I(fit - 2*se.fit), ymax=I(fit + 2*se.fit), x=p), -->
<!--               data=filter(df_pred.k,k %in% levels(df_resultados$k)[11:20]),  -->
<!--               alpha=0.3,  -->
<!--               inherit.aes=FALSE, -->
<!--               color="red") + -->
<!--   geom_line(aes(y=fit),color="white", data=filter(df_pred.k,k %in% levels(df_resultados$k)[11:20])) + -->
<!--   ylab("") + xlab("Proportion of Tree Cover")  + theme_classic() -->
<!--   # theme(panel.background = element_rect(fill = "gray"), -->
<!--   #       panel.grid.major = element_blank(), -->
<!--   #       panel.grid.minor = element_blank()) -->
<!-- do.call("grid.arrange",c(l_p,ncol=2)) -->
<!-- ``` -->

<!-- __Figura 1.4__ Observado e predito pelo modelo mais plausível. Eixo x = prop. de cobertura vegetal na paisagem; Eixo y: número de SADs não refutadas. Em branco o padrão geral estimado e em vermelho o erro padrão.  -->

<!-- o modelo não apresenta bom ajuste aos dados:    -->
<!-- i) MNEE: de maneira geral a tendência global parece estar de acordo com o observado. Contudo, para k<0.5, a estimativa parece ser muito influenciada por pontos extremos.   -->
<!-- ii) MNEI: para todo k, a tendência global não parece apresentar boa congruência com o observado principalmente quanto aos valores médios observados, e.g., para k>0.50 a tendência global parece subestimar o observado. Para k<0.5 há um ponto  que parece ser de grande influência (k=0.25 p->0.5).     -->


<!-- ```{r fig 1.4 residuos pelas preditoras} -->
<!-- df_plot <- df_resultados -->
<!-- df_plot$devRes <- residuals.gam(l_md[["k MN|SiteCode"]],type = "deviance") -->

<!-- df_aug_nRef <- augment(l_md[["k MN|SiteCode"]]) %>% as.data.frame() -->
<!-- # df_aug_nRef %>% names -->


<!-- l_p <- vector("list",2) -->
<!-- l_p[[1]] <- ggplot(filter(df_plot,k %in% levels(df_resultados$k)[1:10]),aes(x=p.z,y=devRes)) +  -->
<!--   geom_point() + geom_smooth() + facet_grid(k~MN,scales="free") + -->
<!--   ylab("Deviance Residuals") + xlab("Proportion of Tree Cover") -->
<!-- l_p[[2]] <- ggplot(filter(df_plot,k %in% levels(df_resultados$k)[11:20]),aes(x=p.z,y=devRes)) +  -->
<!--   geom_point() + geom_smooth() + facet_grid(k~MN,scales="free") + -->
<!--   ylab("Deviance Residuals") + xlab("Proportion of Tree Cover") -->
<!-- do.call("grid.arrange",c(l_p,ncol=2)) -->
<!-- ggplot(df_aug_nRef,aes(x=MN,y=.cooksd)) + geom_jitter() + geom_boxplot() + facet_wrap(~k,ncol=4,scales="free") -->
<!-- ``` -->

<!-- __Figura 1.5__ residuals.gam(l_md[["k MN|SiteCode"]]) ~ p (~k*MN). -->

<!-- Os resíduos do tipo 'deviance' não indicam erro na estimativa quanto à tendência global; o quê para mim está errado principalmente para MNEI.   -->

<!-- ### Melhoria do modelo mais plausível: CONSTRUÇÃO -->

<!-- __Opções__ -->

<!-- #### Comparação metodo para estimar sp e classe de bs -->

<!-- ```{r n_nRef smoothing parameter methods,include=FALSE} -->
<!-- ##### method smoothing parameter -->
<!-- l_md.SP <- vector("list",length = 4) -->
<!-- names(l_md.SP) <- c("REML","ML","GACV.Cp","GCV.Cp") -->
<!-- l_md.SP[[1]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs") + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "REML") -->
<!-- l_md.SP[[2]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs") + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "ML") -->
<!-- l_md.SP[[3]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs") + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "GACV.Cp") -->
<!-- l_md.SP[[4]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs") + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "GCV.Cp") -->
<!-- AICctab(l_md.SP,weights="TRUE") -->
<!-- ``` -->

<!-- __smoother type__ -->

<!-- ```{r n_nRef e bs type} -->
<!-- ############# bs class -->
<!-- l_md.BS <- vector("list",length = 5) -->
<!-- names(l_md.BS) <- c("tp", -->
<!--                     # "ts", -->
<!--                     "cr", -->
<!--                     #"cs", -->
<!--                     "cc","ps","cp" #, -->
<!--                     #"ad" -->
<!--                     ) -->
<!-- l_md.BS[[1]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs",xt="tp") + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "REML") -->
<!-- # l_md.BS[[2]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs",xt="ts") + -->
<!-- #                    s(SiteCode,by=MN,bs="re"), -->
<!-- #                    family = "binomial", -->
<!-- #                    data = df_resultados, method = "REML") -->
<!-- l_md.BS[[2]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs",xt="cr") + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "REML") -->
<!-- # l_md.BS[[3]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs",xt="cs") + -->
<!-- #                    s(SiteCode,by=MN,bs="re"), -->
<!-- #                    family = "binomial", -->
<!-- #                    data = df_resultados, method = "REML") -->
<!-- l_md.BS[[3]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs",xt="cc") + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "REML") -->
<!-- l_md.BS[[4]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs",xt="ps") + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "REML") -->
<!-- l_md.BS[[5]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs",xt="cp") + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "REML") -->
<!-- # l_md.BS[[6]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs",xt="ad") + -->
<!-- #                    s(SiteCode,by=MN,bs="re"), -->
<!-- #                    family = "binomial", -->
<!-- #                    data = df_resultados, method = "REML") -->
<!-- AICctab(l_md.BS,weights="TRUE") -->
<!-- # appraise(l_md.BS[["cr"]]) -->
<!-- ``` -->


<!-- ```{r n_nRef bs mais plausivel e metodo de estimativa} -->

<!-- #### comparação método com o bs mais plausível -->
<!-- l_md.SP_cr <- vector("list",length = 4) -->
<!-- names(l_md.SP_cr) <- c("REML","ML","GACV.Cp","GCV.Cp") -->
<!-- l_md.SP_cr[[1]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs",xt="cr") + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "REML") -->
<!-- l_md.SP_cr[[2]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs",xt="cr") + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "ML") -->
<!-- l_md.SP_cr[[3]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs",xt="cr") + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "GACV.Cp",gamma = 1.5) -->
<!-- l_md.SP_cr[[4]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs",xt="cr") + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "GCV.Cp",gamma = 1.5) -->
<!-- AICctab(l_md.SP_cr,weights="TRUE") -->
<!-- appraise(l_md.SP_cr[[3]]) -->
<!-- ``` -->



<!-- ```{r comparacao bs n_nRef fig16} -->
<!-- ## predição e observação -->
<!-- ### dados -->
<!-- df_pred.k <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1], -->
<!--                           MN=levels(df_resultados$MN), -->
<!--                           k=levels(df_resultados$k), -->
<!--                           p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=103)) %>%  -->
<!--   mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p)) -->
<!-- df_pred.k <- cbind(df_pred.k, -->
<!--                    predict.gam(l_md.SP_cr[[3]], -->
<!--                            df_pred.k,type="response",se.fit=TRUE)) -->
<!-- df_pred.k[,c("fit","se.fit")] <- df_pred.k[,c("fit","se.fit")]*100 -->

<!-- ### graficos -->
<!-- l_p <- vector("list",2) -->
<!-- l_p[[1]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[1:10]),aes(x=p,y=n_nRef)) +  -->
<!--   geom_point(alpha=0.3) + facet_grid(k~MN) + -->
<!--   # k -->
<!--   # geom_ribbon(aes(ymin=I(fit - 2*se.fit), ymax=I(fit + 2*se.fit), x=p), -->
<!--   #             data=filter(df_pred.k,k %in% levels(df_resultados$k)[1:10]), -->
<!--   #             alpha=0.3, -->
<!--   #             inherit.aes=FALSE, -->
<!--   #             color="red") + -->
<!--   geom_line(aes(y=fit),color="red", data=filter(df_pred.k,k %in% levels(df_resultados$k)[1:10])) + -->
<!--   ylab("n_nRef") + xlab("Proportion of Tree Cover") #+ -->
<!-- l_p[[2]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[11:20]),aes(x=p,y=n_nRef)) +  -->
<!--   geom_point(alpha=0.3) + facet_grid(k~MN) + -->
<!--   # k -->
<!--   # geom_ribbon(aes(ymin=I(fit - 2*se.fit), ymax=I(fit + 2*se.fit), x=p), -->
<!--   #             data=filter(df_pred.k,k %in% levels(df_resultados$k)[11:20]),  -->
<!--   #             alpha=0.3,  -->
<!--   #             inherit.aes=FALSE, -->
<!--   #             color="red") + -->
<!--   geom_line(aes(y=fit),color="red", data=filter(df_pred.k,k %in% levels(df_resultados$k)[11:20])) + -->
<!--   ylab("") + xlab("Proportion of Tree Cover") # + -->
<!-- do.call("grid.arrange",c(l_p,ncol=2)) -->
<!-- ``` -->

<!-- __Figura 1.6__ Predito pelo gam com method=GACV.Cp e bs=cr. O intervalo de confiança foi removido por apresentar valores negativos.   -->

<!-- Apesar das mudanças na configuração o modelo continua estimando MNEI errado.   -->

<!-- Resumo dos achados da comparação:   -->

<!-- i) GCV.Cp e GACV.Cp são os métodos mais plausíveis para o smoothing type padrão ("tp") e para o mais plausível ("cr"). -->
<!-- ii) Porém estes métodos de estimativa do parâmetro de smoothing apresentam ajustes estranhos aos padrões observados. -->
<!-- iii) O smoother type "mais plausível"cr" ainda apresenta o mesmo problema do anterior: MNEI não está fazendo bom ajuste.   -->

<!-- a) Como não consegui configurar os métodos GCV.Cp e GACV.Cp para um padrão mais adequado sigo com o terceiro mais plausível ("REML", o padrão). -->
<!-- b) Vou explorar ajustar modelos separados para cada conjunto de dados -->


<!-- #### funções de ligação para distribuição binomial -->

<!-- ```{r comparacao funcao de ligacao e graficos diag n_nRef} -->
<!-- l_md <- vector("list",length = 3) -->
<!-- names(l_md) <- c("logit","probit","cloglog") -->
<!-- l_md[[1]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs",xt="cr") + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = df_resultados, method = "REML") -->
<!-- l_md[[2]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs",xt="cr") + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial"(link="probit"), -->
<!--                    data = df_resultados, method = "REML") -->
<!-- l_md[[3]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs",xt="cr") + -->
<!--                    s(SiteCode,by=MN,bs="re"), -->
<!--                    family = "binomial"(link="cloglog"), -->
<!--                    data = df_resultados, method = "REML") -->
<!-- AICctab(l_md,weights=TRUE) -->
<!-- appraise(l_md[[3]]) -->
<!-- ``` -->

<!-- __Figura 1.7__ Gráficos Diagnósticos do modelo mais plausível binomial(link=cloglog)   -->


<!-- A qualidade do modelo não melhorou. -->


<!-- ```{r predicao cloglog fig18} -->
<!-- ## predição e observação -->
<!-- ### dados -->
<!-- df_pred.k <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1], -->
<!--                           MN=levels(df_resultados$MN), -->
<!--                           k=levels(df_resultados$k), -->
<!--                           p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=103)) %>%  -->
<!--   mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p)) -->
<!-- df_pred.k <- cbind(df_pred.k, -->
<!--                    predict.gam(l_md[[3]], -->
<!--                            df_pred.k,type="response",se.fit=TRUE)) -->
<!-- df_pred.k[,c("fit","se.fit")] <- df_pred.k[,c("fit","se.fit")]*100 -->

<!-- ### graficos -->
<!-- l_p <- vector("list",2) -->
<!-- l_p[[1]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[1:10]),aes(x=p,y=n_nRef)) +  -->
<!--   geom_point(alpha=0.3) + facet_grid(k~MN) + -->
<!--   # k -->
<!--   geom_ribbon(aes(ymin=I(fit - 2*se.fit), ymax=I(fit + 2*se.fit), x=p), -->
<!--               data=filter(df_pred.k,k %in% levels(df_resultados$k)[1:10]), -->
<!--               alpha=0.3, -->
<!--               inherit.aes=FALSE, -->
<!--               color="red") + -->
<!--   geom_line(aes(y=fit),color="white", data=filter(df_pred.k,k %in% levels(df_resultados$k)[1:10])) + -->
<!--   ylab("n_nRef") + xlab("Proportion of Tree Cover") #+ -->
<!-- l_p[[2]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[11:20]),aes(x=p,y=n_nRef)) +  -->
<!--   geom_point(alpha=0.3) + facet_grid(k~MN) + -->
<!--   # k -->
<!--   geom_ribbon(aes(ymin=I(fit - 2*se.fit), ymax=I(fit + 2*se.fit), x=p), -->
<!--               data=filter(df_pred.k,k %in% levels(df_resultados$k)[11:20]), -->
<!--               alpha=0.3, -->
<!--               inherit.aes=FALSE, -->
<!--               color="red") + -->
<!--   geom_line(aes(y=fit),color="white", data=filter(df_pred.k,k %in% levels(df_resultados$k)[11:20])) + -->
<!--   ylab("") + xlab("Proportion of Tree Cover") # + -->
<!-- do.call("grid.arrange",c(l_p,ncol=2)) -->
<!-- ``` -->

<!-- __Figura 1.8__ Predição pelo modelo com função de ligação "cloglog"   -->

<!-- Para MNEI o problema persiste. Além disso para MNEE parece que o ajuste piorou.   -->


<!-- #### Avaliação do conjunto de dados separadamente -->

<!-- ##### MNEE -->

<!-- ```{r gam binomial n_nRef MNEE} -->
<!-- l_md.EE <- vector("list",9) -->
<!-- names(l_md.EE) <- c("k 1|SiteCode logit","k 1|SiteCode probit","k 1|SiteCode cloglog", -->
<!--                     "k_1|SiteCode logit","k_1|SiteCode probit","k_1|SiteCode cloglog", -->
<!--                     "d/L 1|SiteCode logit","d/L 1|SiteCode probit","d/L 1|SiteCode cloglog") -->
<!-- # muitos parametros para poucos dados "k_1 k_1 * MN|SiteCode","d_Lplot d_Lplot * MN|SiteCode") -->
<!-- # k -->
<!-- l_md.EE[[1]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="cr") + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = filter(df_resultados,MN=="EE"), method = "REML") -->
<!-- l_md.EE[[2]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="cr") + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial"(link="probit"), -->
<!--                    data = filter(df_resultados,MN=="EE"), method = "REML") -->
<!-- l_md.EE[[3]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="cr") + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial"(link="cloglog"), -->
<!--                    data = filter(df_resultados,MN=="EE"), method = "REML") -->
<!-- # k_1 -->
<!-- l_md.EE[[4]] <- gam(cbind(n_nRef,100-n_nRef) ~ s(p.z,bs="cr") + s(k_1.z,bs="cr") + ti(p.z,k_1.z,bs=c("cr","cr")) + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = filter(df_resultados,MN=="EE"), method = "REML") -->
<!-- l_md.EE[[5]] <- gam(cbind(n_nRef,100-n_nRef) ~ s(p.z,bs="cr") + s(k_1.z,bs="cr") + ti(p.z,k_1.z,bs=c("cr","cr")) + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial"(link="probit"), -->
<!--                    data = filter(df_resultados,MN=="EE"), method = "REML") -->
<!-- l_md.EE[[6]] <- gam(cbind(n_nRef,100-n_nRef) ~ s(p.z,bs="cr") + s(k_1.z,bs="cr") + ti(p.z,k_1.z,bs=c("cr","cr")) + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial"(link="cloglog"), -->
<!--                    data = filter(df_resultados,MN=="EE"), method = "REML") -->
<!-- # d/L -->
<!-- l_md.EE[[7]] <- gam(cbind(n_nRef,100-n_nRef) ~ s(p.z,bs="cr") + s(d_Lplot.z,bs="cr") + ti(p.z,d_Lplot.z,bs=c("cr","cr")) + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = filter(df_resultados,MN=="EE"), method = "REML") -->
<!-- l_md.EE[[8]] <- gam(cbind(n_nRef,100-n_nRef) ~ s(p.z,bs="cr") + s(d_Lplot.z,bs="cr") + ti(p.z,d_Lplot.z,bs=c("cr","cr")) + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = filter(df_resultados,MN=="EE"), method = "REML") -->
<!-- l_md.EE[[9]] <- gam(cbind(n_nRef,100-n_nRef) ~ s(p.z,bs="cr") + s(d_Lplot.z,bs="cr") + ti(p.z,d_Lplot.z,bs=c("cr","cr")) + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = filter(df_resultados,MN=="EE"), method = "REML") -->
<!-- AICctab(l_md.EE,weights=TRUE) -->
<!-- ``` -->

<!-- ```{r graf diag modelo mais plausivel n_nRef MNEE} -->
<!-- gratia::appraise(l_md.EE[["k 1|SiteCode logit"]]) -->
<!-- ``` -->

<!-- __Figura 1.9__ Gráficos Diagnósticos do modelo mais plausível para o conjunto de dados MN:EE     -->


<!-- ```{r predito para conjunto de dados MNEE} -->
<!-- ## modelo mais plausível -->
<!-- df_pred.k <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1], -->
<!--                           k=levels(df_resultados$k), -->
<!--                           p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=103)) %>%  -->
<!--   mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p)) -->
<!-- df_pred.k <- cbind(df_pred.k, -->
<!--                    predict(l_md.EE[["k 1|SiteCode logit"]], -->
<!--                            df_pred.k,type="response",se.fit=TRUE)) -->
<!-- df_pred.k[,c("fit","se.fit")] <- df_pred.k[,c("fit","se.fit")]*100 -->

<!-- ggplot(filter(df_resultados,MN=="EE"),aes(x=p,y=n_nRef)) +  -->
<!--   geom_point(alpha=0.5) + facet_wrap(~k,ncol=4) + -->
<!--   # k -->
<!--   geom_ribbon(aes(ymin=I(fit - 2*se.fit), ymax=I(fit + 2*se.fit), x=p), -->
<!--               data=df_pred.k, -->
<!--               alpha=0.3, -->
<!--               inherit.aes=FALSE, -->
<!--               color="red") + -->
<!--   geom_line(aes(y=fit),color="white", data=df_pred.k) + -->
<!--   ylab("Pr(not ref. SAD)") + xlab("Proportion of Tree Cover")  -->
<!-- #  -->
<!-- # l_md.EE[["k 1|SiteCode"]]$sp -->
<!-- # l_md.EE[["k 1|SiteCode"]]$sp %>% min -->
<!-- ``` -->

<!-- __Figura 1.10__ Predito para o conjunto de dados MNEE   -->

<!--   Parece que alguns pontos tem grande grande influência nos dados. Sigo comparação de diferentes tipos de smoothers -->

<!-- ```{r n_nRef MNEE comparacao smoothers type} -->
<!-- ############# bs class -->
<!-- l_mdEE_bs <- vector("list",length = 7) -->
<!-- # l_mdEE_bs <- l_mdEE_bs[1:7] -->
<!-- names(l_mdEE_bs) <- c("tp", -->
<!--                     "ts", -->
<!--                     "cr", -->
<!--                     "cs", -->
<!--                     "cc","ps","cp" #, -->
<!--           #          "ad" -->
<!--                     ) -->
<!-- l_mdEE_bs[[1]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="tp") + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = filter(df_resultados,MN=="EE"), method = "REML") -->
<!-- l_mdEE_bs[[2]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="ts") + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = filter(df_resultados,MN=="EE"), method = "REML") -->
<!-- l_mdEE_bs[[3]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="cr") + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = filter(df_resultados,MN=="EE"), method = "REML") -->
<!-- l_mdEE_bs[[4]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="cs") + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = filter(df_resultados,MN=="EE"), method = "REML") -->
<!-- l_mdEE_bs[[5]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="cc") + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = filter(df_resultados,MN=="EE"), method = "REML") -->
<!-- l_mdEE_bs[[6]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="ps") + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = filter(df_resultados,MN=="EE"), method = "REML") -->
<!-- l_mdEE_bs[[7]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="cp") + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = filter(df_resultados,MN=="EE"), method = "REML") -->
<!-- # não roda -->
<!-- # l_mdEE_bs[[8]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="ad") + -->
<!-- #                    s(SiteCode,bs="re"), -->
<!-- #                    family = "binomial", -->
<!-- #                    data = filter(df_resultados,MN=="EE"), method = "REML") -->
<!-- AICctab(l_mdEE_bs,weights="TRUE") -->
<!-- ``` -->

<!-- ```{r n_nRef MNEE appraise l_mdEEbs tp} -->
<!-- appraise(l_mdEE_bs[["tp"]]) -->
<!-- ``` -->

<!-- __Figura 1.11__ Graficos Diagnosticos para MNEE e bs=tp   -->

<!-- ```{r predicao para MNEE bs tp n_nref fig 114} -->
<!-- ## modelo mais plausível -->
<!-- df_pred.k <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1], -->
<!--                           k=levels(df_resultados$k), -->
<!--                           p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=103)) %>%  -->
<!--   mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p)) -->
<!-- df_pred.k <- cbind(df_pred.k, -->
<!--                    predict(l_mdEE_bs[["tp"]], -->
<!--                            df_pred.k,type="response",se.fit=TRUE)) -->
<!-- df_pred.k[,c("fit","se.fit")] <- df_pred.k[,c("fit","se.fit")]*100 -->

<!-- ggplot(filter(df_resultados,MN=="EE"),aes(x=p,y=n_nRef)) +  -->
<!--   geom_point(alpha=0.5) + facet_wrap(~k,ncol=4) + -->
<!--   # k -->
<!--   geom_ribbon(aes(ymin=I(fit - 2*se.fit), ymax=I(fit + 2*se.fit), x=p), -->
<!--               data=df_pred.k, -->
<!--               alpha=0.3, -->
<!--               inherit.aes=FALSE, -->
<!--               color="red") + -->
<!--   geom_line(aes(y=fit),color="white", data=df_pred.k) + -->
<!--   ylab("Pr(not ref. SAD)") + xlab("Proportion of Tree Cover")  -->
<!-- ``` -->

<!-- __Figura 1.12__ Predito para MNEE e bs="tp" -->

<!-- Ainda observo valores  de grande influência. -->

<!-- ##### MNEI -->

<!-- ```{r gam binomial n_nRef MNEI} -->
<!-- l_md.EI <- vector("list",9) -->
<!-- names(l_md.EI) <- c("k 1|SiteCode logit","k 1|SiteCode probit","k 1|SiteCode cloglog", -->
<!--                     "k_1|SiteCode logit","k_1|SiteCode probit","k_1|SiteCode cloglog", -->
<!--                     "d/L 1|SiteCode logit","d/L 1|SiteCode probit","d/L 1|SiteCode cloglog") -->
<!-- # muitos parametros para poucos dados "k_1 k_1 * MN|SiteCode","d_Lplot d_Lplot * MN|SiteCode") -->
<!-- # k -->
<!-- l_md.EI[[1]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="cr") + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = filter(df_resultados,MN=="EI"), method = "REML") -->
<!-- l_md.EI[[2]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="cr") + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial"(link="probit"), -->
<!--                    data = filter(df_resultados,MN=="EI"), method = "REML") -->
<!-- l_md.EI[[3]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="cr") + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial"(link="cloglog"), -->
<!--                    data = filter(df_resultados,MN=="EI"), method = "REML") -->
<!-- # k_1 -->
<!-- l_md.EI[[4]] <- gam(cbind(n_nRef,100-n_nRef) ~ s(p.z,bs="cr") + s(k_1.z,bs="cr") + ti(p.z,k_1.z,bs=c("cr","cr")) + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = filter(df_resultados,MN=="EI"), method = "REML") -->
<!-- l_md.EI[[5]] <- gam(cbind(n_nRef,100-n_nRef) ~ s(p.z,bs="cr") + s(k_1.z,bs="cr") + ti(p.z,k_1.z,bs=c("cr","cr")) + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial"(link="probit"), -->
<!--                    data = filter(df_resultados,MN=="EI"), method = "REML") -->
<!-- l_md.EI[[6]] <- gam(cbind(n_nRef,100-n_nRef) ~ s(p.z,bs="cr") + s(k_1.z,bs="cr") + ti(p.z,k_1.z,bs=c("cr","cr")) + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial"(link="cloglog"), -->
<!--                    data = filter(df_resultados,MN=="EI"), method = "REML") -->
<!-- # d/L -->
<!-- l_md.EI[[7]] <- gam(cbind(n_nRef,100-n_nRef) ~ s(p.z,bs="cr") + s(d_Lplot.z,bs="cr") + ti(p.z,d_Lplot.z,bs=c("cr","cr")) + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = filter(df_resultados,MN=="EI"), method = "REML") -->
<!-- l_md.EI[[8]] <- gam(cbind(n_nRef,100-n_nRef) ~ s(p.z,bs="cr") + s(d_Lplot.z,bs="cr") + ti(p.z,d_Lplot.z,bs=c("cr","cr")) + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = filter(df_resultados,MN=="EI"), method = "REML") -->
<!-- l_md.EI[[9]] <- gam(cbind(n_nRef,100-n_nRef) ~ s(p.z,bs="cr") + s(d_Lplot.z,bs="cr") + ti(p.z,d_Lplot.z,bs=c("cr","cr")) + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial", -->
<!--                    data = filter(df_resultados,MN=="EI"), method = "REML") -->
<!-- AICctab(l_md.EI,weights=TRUE) -->
<!-- ```   -->

<!-- ```{r graf diag modelo mais plausivel n_nRef MNEI} -->
<!-- gratia::appraise(l_md.EI[["k 1|SiteCode cloglog"]]) -->
<!-- ``` -->

<!-- __Figura 1.13__ Gráficos Diagnósticos do modelo mais plausível para o conjunto de dados MN:EI     -->


<!-- ```{r predito para conjunto de dados MNEI,echo=TRUE} -->
<!-- ## modelo mais plausível -->
<!-- df_pred.k <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1], -->
<!--                           k=levels(df_resultados$k), -->
<!--                           p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=103)) %>%  -->
<!--   mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p)) -->
<!-- df_pred.k <- cbind(df_pred.k, -->
<!--                    predict(l_md.EI[["k 1|SiteCode logit"]], -->
<!--                            df_pred.k,type="response",se.fit=TRUE)) -->
<!-- df_pred.k[,c("fit","se.fit")] <- df_pred.k[,c("fit","se.fit")]*100 -->

<!-- ggplot(filter(df_resultados,MN=="EI"),aes(x=p,y=n_nRef)) +  -->
<!--   geom_point(alpha=0.5) + facet_wrap(~k,ncol=4) + -->
<!--   # k -->
<!--   geom_ribbon(aes(ymin=I(fit - 2*se.fit), ymax=I(fit + 2*se.fit), x=p), -->
<!--               data=df_pred.k, -->
<!--               alpha=0.3, -->
<!--               inherit.aes=FALSE, -->
<!--               color="red") + -->
<!--   geom_line(aes(y=fit),color="white", data=df_pred.k) + -->
<!--   ylab("Pr(not ref. SAD)") + xlab("Proportion of Tree Cover")  -->
<!-- ``` -->

<!-- __Figura 1.14__ Predito para o conjunto de dados MNEI   -->

<!-- O problema de estimativa errada persiste. Vou avaliar outros tipos de smoothers. -->


<!-- ```{r n_nRef MNEI basis smoother} -->
<!-- l_mdEI_bs <- vector("list",length = 7) -->
<!-- names(l_mdEI_bs) <- c("tp", -->
<!--                     "ts", -->
<!--                     "cr", -->
<!--                     "cs", -->
<!--                     "cc","ps","cp" #, -->
<!--           #          "ad" -->
<!--                     ) -->
<!-- l_mdEI_bs[[1]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="tp") + -->
<!--                     s(SiteCode,bs="re"), -->
<!--                     family = "binomial"(link="cloglog"), -->
<!--                     data = filter(df_resultados,MN=="EI"), method = "REML") -->
<!-- l_mdEI_bs[[2]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="ts") + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial"(link="cloglog"), -->
<!--                    data = filter(df_resultados,MN=="EI"), method = "REML") -->
<!-- l_mdEI_bs[[3]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="cr") + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial"(link="cloglog"), -->
<!--                    data = filter(df_resultados,MN=="EI"), method = "REML") -->
<!-- l_mdEI_bs[[4]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="cs") + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial"(link="cloglog"), -->
<!--                    data = filter(df_resultados,MN=="EI"), method = "REML") -->
<!-- l_mdEI_bs[[5]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="cc") + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial"(link="cloglog"), -->
<!--                    data = filter(df_resultados,MN=="EI"), method = "REML") -->
<!-- l_mdEI_bs[[6]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="ps") + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial"(link="cloglog"), -->
<!--                    data = filter(df_resultados,MN=="EI"), method = "REML") -->
<!-- l_mdEI_bs[[7]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="cp") + -->
<!--                    s(SiteCode,bs="re"), -->
<!--                    family = "binomial"(link="cloglog"), -->
<!--                    data = filter(df_resultados,MN=="EI"), method = "REML") -->
<!-- # não roda -->
<!-- # l_mdEE_bs[[8]] <- gam(cbind(n_nRef,100-n_nRef) ~ k + s(p.z,by=k,bs="ad") + -->
<!-- #                    s(SiteCode,bs="re"), -->
<!-- #                    family = "binomial", -->
<!-- #                    data = filter(df_resultados,MN=="EE"), method = "REML") -->
<!-- AICctab(l_mdEI_bs,weights="TRUE") -->
<!-- ``` -->

<!-- O smoother type "cr", modelo utilizado até o momento, é o mais plausível. Vou avaliar se a remoção de alguns pontos de grande influência podem melhorar o ajuste. -->



<!-- <!-- ## diff_S: GAMM --> -->

<!-- <!-- Para modelar o padrão não linear dos dados vou utilizar GAMM: normal, Gamma(log) e Gamma(inverse) com duas estruturas aleatórias (1|SiteCode e MN|SiteCode).  --> -->

<!-- <!-- ### Modelo Cheio e Gráficos Diagnosticos --> -->

<!-- <!-- ```{r md cheio diff_S} --> -->
<!-- <!-- l_md.diff_S <- vector("list",length=6) --> -->
<!-- <!-- names(l_md.diff_S) <- c("normal id MN|SiteCode","normal id 1|SiteCode", --> -->
<!-- <!--                         "Gamma log MN|SiteCode","Gamma log 1|SiteCode", --> -->
<!-- <!--                         "Gamma inverse MN|SiteCode","Gamma inverse 1|SiteCode") --> -->
<!-- <!-- l_md.diff_S[[1]] <- gam(diff_S ~ k*MN + s(log_Stotal.z,bs="tp") + s(p.z,k,by=MN,bs="fs",xt=list(bs="tp")) + --> -->
<!-- <!--                           s(SiteCode,by=MN,bs="re"), --> -->
<!-- <!--                         data=df_resultados, --> -->
<!-- <!--                         family = "gaussian", --> -->
<!-- <!--                         method="REML") --> -->
<!-- <!-- l_md.diff_S[[2]] <- gam(diff_S ~ k*MN + s(log_Stotal.z,bs="tp") + s(p.z,k,by=MN,bs="fs",xt=list(bs="tp")) + --> -->
<!-- <!--                           s(SiteCode,bs="re"), --> -->
<!-- <!--                         data=df_resultados, --> -->
<!-- <!--                         family = "gaussian", --> -->
<!-- <!--                         method="REML") --> -->
<!-- <!-- l_md.diff_S[[3]] <- gam(diff_S ~ k*MN + s(log_Stotal.z,bs="tp") + s(p.z,k,by=MN,bs="fs",xt=list(bs="tp")) + --> -->
<!-- <!--                           s(SiteCode,by=MN,bs="re"), --> -->
<!-- <!--                         data=df_resultados, --> -->
<!-- <!--                         family = "Gamma", --> -->
<!-- <!--                         method="REML") --> -->
<!-- <!-- l_md.diff_S[[4]] <- gam(diff_S ~ k*MN + s(log_Stotal.z,bs="tp") + s(p.z,k,by=MN,bs="fs",xt=list(bs="tp")) + --> -->
<!-- <!--                           s(SiteCode,bs="re"), --> -->
<!-- <!--                         data=df_resultados, --> -->
<!-- <!--                         family = "Gamma", --> -->
<!-- <!--                         method="REML") --> -->
<!-- <!-- l_md.diff_S[[5]] <- gam(diff_S ~ k*MN + s(log_Stotal.z,bs="tp") + s(p.z,k,by=MN,bs="fs",xt=list(bs="tp")) + --> -->
<!-- <!--                           s(SiteCode,by=MN,bs="re"), --> -->
<!-- <!--                         data=df_resultados, --> -->
<!-- <!--                         family = "Gamma"(link="log"), --> -->
<!-- <!--                         method="REML") --> -->
<!-- <!-- l_md.diff_S[[6]] <- gam(diff_S ~ k*MN + s(log_Stotal.z,bs="tp") + s(p.z,k,by=MN,bs="fs",xt=list(bs="tp")) + --> -->
<!-- <!--                           s(SiteCode,bs="re"), --> -->
<!-- <!--                         data=df_resultados, --> -->
<!-- <!--                         family = "Gamma"(link="log"), --> -->
<!-- <!--                         method="REML") --> -->
<!-- <!-- AICctab(l_md.diff_S,weights=TRUE) --> -->
<!-- <!-- md_diffS <-  gam(diff_S0 ~ k*MN + s(log_Stotal.z,bs="tp") + s(p.z,k,by=MN,bs="fs",xt=list(bs="tp")) + --> -->
<!-- <!--                           s(SiteCode,by=MN,bs="re"), --> -->
<!-- <!--                         data=df_resultados, --> -->
<!-- <!--                         family = "gaussian", --> -->
<!-- <!--                         method="REML") --> -->
<!-- <!-- # l_md1 <- l_md.diff_S[1:2] --> -->
<!-- <!-- # l_md.diff_S[1:2] <- l_md1 --> -->
<!-- <!-- # save(l_md.diff_S,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diffS.Rdata") --> -->
<!-- <!-- # save(md_diffS,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/md_diffS.Rdata") --> -->
<!-- <!-- # load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/md_diffS.Rdata") --> -->
<!-- <!-- ``` --> -->


<!-- <!-- ```{r appraise diff_S[[k|SiteCode]]} --> -->
<!-- <!-- appraise(md_diffS) --> -->
<!-- <!-- ``` --> -->

<!-- <!-- __Figura 2.2__ Graficos diagnosticos do modelo mais plausível para diff_S.    --> -->

<!-- <!-- Parece que o pressuposto de distribuição normal não é adequado, assim como parece haver alguma tendência nos dados que não está sendo detectada. Especulo que existam outliers que estão inflenciando muito a estimativa dos dados.  --> -->

<!-- <!-- #### Observado e Predito   --> -->

<!-- <!-- ```{r observado e predito diff_S} --> -->
<!-- <!-- df_pred.k <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1], --> -->
<!-- <!--                           MN=levels(df_resultados$MN), --> -->
<!-- <!--                           k=levels(df_resultados$k), --> -->
<!-- <!--                           p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=103), --> -->
<!-- <!--                           log_Stotal.z=seq(min(df_resultados$log_Stotal.z),max(df_resultados$log_Stotal.z),length=103)) %>%  --> -->
<!-- <!--   mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p)) --> -->
<!-- <!-- df_pred.k <- cbind(df_pred.k, --> -->
<!-- <!--                    predict(md_diffS, --> -->
<!-- <!--                            df_pred.k,type="response",se.fit=TRUE)) --> -->
<!-- <!-- # grafico --> -->
<!-- <!-- l_p <- vector("list",2) --> -->
<!-- <!-- l_p[[1]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[1:10]),aes(x=p,y=diff_S0)) +  --> -->
<!-- <!--   geom_point() + facet_grid(k~MN,scales="free") + --> -->
<!-- <!--   geom_ribbon(aes(ymin=I(fit - 2*se.fit), ymax=I(fit + 2*se.fit), x=p), --> -->
<!-- <!--               data=filter(df_pred.k,k %in% levels(df_resultados$k)[1:10]), --> -->
<!-- <!--               alpha=0.3, --> -->
<!-- <!--               inherit.aes=FALSE, --> -->
<!-- <!--               color="red") + --> -->
<!-- <!--   geom_line(aes(y=fit),color="white", data=filter(df_pred.k,k %in% levels(df_resultados$k)[1:10])) + --> -->
<!-- <!--   ylab("(S_obs - S_modelo.neutro) * S_obs^(-1)") + xlab("Proportion of Tree Cover") + --> -->
<!-- <!--   theme(panel.background = element_rect(fill = "gray"), --> -->
<!-- <!--         panel.grid.major = element_blank(), --> -->
<!-- <!--         panel.grid.minor = element_blank()) --> -->
<!-- <!-- l_p[[2]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[11:20]),aes(x=p,y=diff_S0)) +  --> -->
<!-- <!--   geom_point() + facet_grid(k~MN,scales="free") + --> -->
<!-- <!--   geom_ribbon(aes(ymin=I(fit - 2*se.fit), ymax=I(fit + 2*se.fit), x=p), --> -->
<!-- <!--               data=filter(df_pred.k,k %in% levels(df_resultados$k)[11:20]),  --> -->
<!-- <!--               alpha=0.3,  --> -->
<!-- <!--               inherit.aes=FALSE, --> -->
<!-- <!--               color="red") + --> -->
<!-- <!--   geom_line(aes(y=fit),color="white", data=filter(df_pred.k,k %in% levels(df_resultados$k)[11:20])) + --> -->
<!-- <!--   ylab("") + xlab("Proportion of Tree Cover") + --> -->
<!-- <!--   theme(panel.background = element_rect(fill = "gray"), --> -->
<!-- <!--         panel.grid.major = element_blank(), --> -->
<!-- <!--         panel.grid.minor = element_blank()) --> -->
<!-- <!-- do.call("grid.arrange",c(l_p,ncol=2)) --> -->
<!-- <!-- ``` --> -->

<!-- <!-- __Figura 2.3__ Diferença na riqueza observada e estimada pela proporção de cobertura vegetal. --> -->

<!-- <!-- Os modelos ajustados para MNEI estão sistematicamente com problemas de errar a média (figura 1.1 e 1.4; figura 2.1 e 2.3). Especulo que talvez alguns pontos estão influenciando muito as estimativas centrais ou estou usando configuração errada nas funções. Além disso para MNEI percebo que a tendência geral não está descrevendo o padrão dos dados, em especial para k->1. --> -->



<!-- <!-- <!-- O modelos cheio mais plausível possui família Gamma e função de ligação 'log" e utiliza a preditora d / L_plot. --> --> -->

<!-- <!-- <!-- ### Auditoria do modelo cheio mais plausível --> --> -->

<!-- <!-- <!-- <!-- Protocolo de Wood (in Checking and Selecting GAMs): --> --> --> -->

<!-- <!-- <!-- <!-- 1) Residual Checking:   --> --> --> -->
<!-- <!-- <!-- <!-- a) fitted ~ residuals (1|SiteCode) --> --> --> -->
<!-- <!-- <!-- <!-- a) fitted ~ residuals (1|SiteCode) --> --> --> -->
<!-- <!-- <!-- <!-- b) residuals ~ preditoras   --> --> --> -->

<!-- <!-- <!-- ```{r auditoria md mais plausivel U 01}  --> --> -->
<!-- <!-- <!-- # Dados --> --> -->
<!-- <!-- <!-- md_U <- l_md[["d log gamma"]] --> --> -->
<!-- <!-- <!-- # summary(md_U) --> --> -->
<!-- <!-- <!-- ## gam.check --> --> -->
<!-- <!-- <!-- par(mfrow=c(2,2)) --> --> -->
<!-- <!-- <!-- gam.check(md_U) --> --> -->
<!-- <!-- <!-- ## intercepto por sitecode --> --> -->
<!-- <!-- <!-- df_ <- data.frame(term=names(coef(l_md[[1]])),coef=as.numeric(coef(l_md[[1]]))) --> --> -->
<!-- <!-- <!-- df_ %>% filter(grepl("SiteCode",term)) %>% ggplot(aes(x="",y=coef)) +  --> --> -->
<!-- <!-- <!--   geom_boxplot() + geom_jitter() --> --> -->
<!-- <!-- <!-- # df_ %>% filter(grepl("SiteCode",term)) %>% summary --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 3__ gam.check(modelo cheio mais plausível)   --> --> -->


<!-- <!-- <!-- ```{r auditoria md mais plausivel U 2,warning=FALSE,message=FALSE} --> --> -->
<!-- <!-- <!-- p_plot <- DHARMa::simulateResiduals(md_U,n=1000) --> --> -->
<!-- <!-- <!-- plot(p_plot) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 3.2__ DHARMa::simulateResiduals(modelo cheio mais plausível) --> --> -->


<!-- <!-- <!-- O Modelo mais plausível diverge do pressuposto de que a variável resposta pode ser aproximada por uma distribuição Gamma(link=log) para ambos diagnósticos. O gam.check indica que k=9 não é suficiente para modelar a variável d/L_plot.   --> --> -->

<!-- <!-- <!-- Segue avaliação dos efeitos:   --> --> -->


<!-- <!-- <!-- <!-- o que são os efeitos estimados? --> --> --> -->

<!-- <!-- <!-- ```{r auditoria md_U mais plausível U 3,fig.width=12} --> --> -->
<!-- <!-- <!-- gratia::draw(md_U) --> --> -->
<!-- <!-- <!-- par(mfrow=c(2,2)) --> --> -->
<!-- <!-- <!-- plot(md_U) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 4__ gratia::draw(md_U) --> --> -->

<!-- <!-- <!-- A função que plota o gráfico dos efeitos acusa um erro: Removed 951 rows containing non-finite values (stat_contour). Esse problema decorreria de U_med->0 que na escala log -> a infinito? O quê de fato esta sendo plotado?[ESTUDAR] draw.derivates()?   --> --> -->


<!-- <!-- <!-- __tabela __ Concurvidade dos smoothers --> --> -->

<!-- <!-- <!-- ```{r concurvidade md_U} --> --> -->
<!-- <!-- <!-- concurvity(md_U,full = TRUE) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- Os três indices variam entre 0 e 1, quando igual a 1 então o smoother apresenta concurvidade com algum outro smoother. O intercepto geral ('para'), o smoother de s(p) e o smoother s(log_Stotal) apresenta concurvidade  --> --> -->



<!-- <!-- <!-- ```{r auditoria md_U 4} --> --> -->
<!-- <!-- <!-- df_ <- augment(md_U) %>% mutate(.predict=exp(.fitted)) --> --> -->
<!-- <!-- <!-- # gráficos exploratórios --> --> -->
<!-- <!-- <!-- par(mfrow=c(1,2)) --> --> -->
<!-- <!-- <!-- hist(df_$.predict,breaks = 60) --> --> -->
<!-- <!-- <!-- hist(df_resultados.U$U_med,breaks = 60) --> --> -->
<!-- <!-- <!-- # --> --> -->
<!-- <!-- <!-- summary(df_) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 5.1__  --> --> -->

<!-- <!-- <!-- O summary da tabela de md_U mostra que tanto U_med como o predito (na escala de U_med) estão dentro do esperado: valores positivos entre 0 e 1. O aviso de erro pode ser resultado do uso da função stat_contour (OLHAR HELP). --> --> -->


<!-- <!-- <!-- ```{r auditoria predicao md_U mais plausivel,fig.height=30,fig.width=12} --> --> -->
<!-- <!-- <!-- # graficos por sitecode --> --> -->
<!-- <!-- <!-- ggplot(df_,aes(x=.predict,y=U_med)) + --> --> -->
<!-- <!-- <!--   geom_point() + --> --> -->
<!-- <!-- <!--   geom_abline(slope = 1,intercept=0,color="red") + --> --> -->
<!-- <!-- <!--   geom_smooth(method="auto") + --> --> -->
<!-- <!-- <!--   facet_wrap(~SiteCode,ncol=5,scales = "free") --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 5.2__ Observado X Predito U ~ s(%d.z) + s(p.z) + ti(%d.z,p.z) + log_Stotal.z + s(SiteCode,bs="re")   --> --> -->


<!-- <!-- <!-- Para alguns sítios observa-se que a nuvem dos pontos se aproxima à reta, contudo para outros sítios o smoother global não descreve o padrão não-linear  (figura 5.2). Uma possibilidade é ajustar um smoother por SiteCode: a) compartilhando um mesmo parâmetro de penalidade (menor flexibilidade); b) com uma réplica do smoother global para cada sítio (mais flexível, muito mais oneroso computacionalmente). --> --> -->

<!-- <!-- <!-- Em resumo, o modelo mais plausível i) não pode ser aproximado por uma distribuição Gamma com função de ligação log; e o smoother s(p) apresenta concurvidade com outros smoothers. Há formas alternativas de modelar a relação dispersão * p: te(dispersão,p) e t2(dispersão,p).  --> --> -->

<!-- <!-- <!-- ```{r md_U comparacao s+ti te e t2} --> --> -->
<!-- <!-- <!-- # Dados --> --> -->
<!-- <!-- <!-- l_md <- vector("list",5) --> --> -->
<!-- <!-- <!-- names(l_md) <- c("s+ti","s + s","s(d) + ti(d,p)","te","t2") --> --> -->
<!-- <!-- <!-- l_md[[1]] <- gam(U_med ~ s(d_Lplot.z) + s(p.z) + ti(d_Lplot.z,p.z) + --> --> -->
<!-- <!-- <!--                   log_Stotal.z + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family=Gamma(link = "log"), --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=as.list(3)) --> --> -->
<!-- <!-- <!-- l_md[[2]] <- gam(U_med ~ s(d_Lplot.z) + s(p.z) + --> --> -->
<!-- <!-- <!--                   log_Stotal.z + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family=Gamma(link = "log"), --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=as.list(3)) --> --> -->
<!-- <!-- <!-- l_md[[3]] <- gam(U_med ~ s(d_Lplot.z) + ti(d_Lplot.z,p.z) + --> --> -->
<!-- <!-- <!--                   log_Stotal.z + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family=Gamma(link = "log"), --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=as.list(3)) --> --> -->
<!-- <!-- <!-- l_md[[4]] <- gam(U_med ~ te(d_Lplot.z,p.z) + --> --> -->
<!-- <!-- <!--                   log_Stotal.z + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family=Gamma(link = "log"), --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=as.list(3)) --> --> -->
<!-- <!-- <!-- l_md[[5]] <- gam(U_med ~ t2(d_Lplot.z,p.z) + --> --> -->
<!-- <!-- <!--                   log_Stotal.z + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family=Gamma(link = "log"), --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=as.list(3)) --> --> -->
<!-- <!-- <!-- AICctab(l_md,weights=T) --> --> -->
<!-- <!-- <!-- ``` --> --> -->


<!-- <!-- <!-- O único modelo plausível, somando 0.82 do peso de evidência, pressupóem o smoother individual de d/L_plot e o tensor entre d/L_plot e de p; o segundo modelo mais plausível, com 0.18 de peso de evidência, considera adicionalmente o smoother individual para p. Os modelos com tensores te e t2 apresentam menos parâmetros porém não estão dentro do intervalo de plausibilidade; o modelo menos plausível considera os smoothers indivíduais de d/L_plot e p, mas desconsidera o tensor das preditoras. Os resultados corroboram o hipótese de que o smoother individual de p é concurvo ao tensor de d e p. Segue auditoria do modelo mais plausível: --> --> -->


<!-- <!-- <!-- ```{r auditoria 1 s(d)+ti(d,p)} --> --> -->
<!-- <!-- <!-- par(mfrow=c(2,2)) --> --> -->
<!-- <!-- <!-- gam.check(l_md[["s(d) + ti(d,p)"]]) --> --> -->
<!-- <!-- <!-- ``` --> --> -->


<!-- <!-- <!-- ```{r auditoria 2 s(d)+ti(d,p)} --> --> -->
<!-- <!-- <!-- p_plot <- DHARMa::simulateResiduals(l_md[["s(d) + ti(d,p)"]],n=1000) --> --> -->
<!-- <!-- <!-- plot(p_plot) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- Ambos diagnostico apontam que o pressuposto de distribuição gamma com função de ligação log não é uma boa aproximação, e pela comparação com o modelo anterior o ajuste do modelo com relação ao segundo mais plausível piorou. Segue avaliação dos efeitos:   --> --> -->


<!-- <!-- <!-- ```{r auditoria 3 s(d)+ti(d,p)} --> --> -->
<!-- <!-- <!-- gratia::draw(l_md[["s(d) + ti(d,p)"]]) --> --> -->
<!-- <!-- <!-- # gratia::draw(l_md[["s+ti"]]) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- O gráfico de efeitos do smoother de d/L_plot mostra que o desvio padrão da estimativa aumenta com o aumento do preditor. Idealmente deveria ser homogeneo ao longo do gradite do preditor (REF). Segue avaliaão da concurvidade entre os smoothers:   --> --> -->

<!-- <!-- <!-- ```{r auditoria 4 s(d)+ti(d,p)} --> --> -->
<!-- <!-- <!-- concurvity(l_md[["s(d) + ti(d,p)"]]) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- O diagnostico de concurvidade indica que não há problemas. Ainda há possibilidade de aumentar o número de funções bases para ajustar o padrão, pois gam.check indica que talvez seja necessário aumentar o número de funções base para o smoother de d/L_plot --> --> -->

<!-- <!-- <!-- ```{r auditoria 5 s(d) + ti(d,p)} --> --> -->
<!-- <!-- <!-- l_md[[3]] <- gam(U_med ~ s(d_Lplot.z,k=10) + ti(d_Lplot.z,p.z) + --> --> -->
<!-- <!-- <!--                   log_Stotal.z + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family=Gamma(link = "log"), --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=as.list(3)) --> --> -->
<!-- <!-- <!-- gam.check(l_md[[3]])  --> --> -->
<!-- <!-- <!-- gratia::draw(l_md[[3]]) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- Para k maiores (20,40) o diagnóstico da gam.check continua indicando que k não é suficiente, porem ao aumentar k promove o aumento de sobreajuste do modelo sem melhoras no pressuposto de distribuição gamma com função de ligação log.   --> --> -->


<!-- <!-- <!-- #### Exploração de outras estruturas aleatórias --> --> -->

<!-- <!-- <!-- ```{r estruturas aleatorias alternativas U_med d} --> --> -->
<!-- <!-- <!-- l_md <- vector("list",2) --> --> -->
<!-- <!-- <!-- names(l_md) <- c("(1|SiteCode)","d|SiteCode,lambda comum") #,"d|SiteCode,lambda por SiteCode") --> --> -->
<!-- <!-- <!-- l_md[[1]] <- gam(U_med ~ s(d_Lplot.z) + ti(d_Lplot.z,p.z) + --> --> -->
<!-- <!-- <!--                   log_Stotal.z + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family=Gamma(link = "log"), --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=as.list(3)) --> --> -->
<!-- <!-- <!-- l_md[[2]] <- gam(U_med ~ s(d_Lplot.z) + ti(d_Lplot.z,p.z) + --> --> -->
<!-- <!-- <!--                   log_Stotal.z + --> --> -->
<!-- <!-- <!--                   s(d_Lplot.z,SiteCode,bs="fs",m=2), --> --> -->
<!-- <!-- <!--                 family=Gamma(link = "log"), --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=as.list(3)) --> --> -->
<!-- <!-- <!-- # l_md[[3]] <- gam(U_med ~ s(d_Lplot.z) + ti(d_Lplot.z,p.z) + --> --> -->
<!-- <!-- <!-- #                   log_Stotal.z + --> --> -->
<!-- <!-- <!-- #                   s(d_Lplot.z,by=SiteCode,m=1) + s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!-- #                 family=Gamma(link = "log"), --> --> -->
<!-- <!-- <!-- #                 data = df_resultados.U, method = "REML",control=as.list(3)) --> --> -->
<!-- <!-- <!-- AICctab(l_md,weights=TRUE) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- O modelo que permite um smoother de dispersão por sitecode com lambda comum é o mais plausível. Segue auditoria do modelo: --> --> -->

<!-- <!-- <!-- ```{r auditoria 1 d|SiteCode lambda comum} --> --> -->
<!-- <!-- <!-- par(mfrow=c(2,2)) --> --> -->
<!-- <!-- <!-- gam.check(l_md[[2]]) --> --> -->
<!-- <!-- <!-- ``` --> --> -->


<!-- <!-- <!-- ```{r auditoria 2 d|SiteCode lambda comum} --> --> -->
<!-- <!-- <!-- p_plot <- DHARMa::simulateResiduals(l_md[[2]],n=1000) --> --> -->
<!-- <!-- <!-- plot(p_plot) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- Observa-se piora na adequação ao pressuposto de distribuição gamma(link=log) --> --> -->

<!-- <!-- <!-- ```{r auditoria 3 d|SiteCode lambda comum} --> --> -->
<!-- <!-- <!-- gratia::draw(l_md[[2]]) --> --> -->
<!-- <!-- <!-- ``` --> --> -->


<!-- <!-- <!-- #### Alternativas de configuração de gam   --> --> -->

<!-- <!-- <!-- i) mudança no tipo de funções base utilizada, o método padrão é o ts (thin plate regression spline).   --> --> -->
<!-- <!-- <!-- ii) modificar em qual grau da derivada a flexibilidade do smoother é penalizada.   --> --> -->

<!-- <!-- <!-- Como ii é feito por padrão, vou explorar i. O modelo que considera os smoothers indivíduais de d e p vai ser usado na exploração dos tipos de smoother.  --> --> -->

<!-- <!-- <!-- opções: --> --> -->

<!-- <!-- <!-- 1) tp; 2) ts; 3) ds; 4) cr; cc; cs; 5) sos; cp; 6) mrf; 7) gp; 8) so; sw; sf  --> --> -->

<!-- <!-- <!-- ```{r comparação entre tipos de smoothers,include=FALSE,echo=FALSE} --> --> -->
<!-- <!-- <!-- l_md <- vector("list",) --> --> -->
<!-- <!-- <!-- names(l_md) <- c() --> --> -->

<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- # Apendice --> --> -->

<!-- <!-- <!-- ## n_nRef GLMM binomial --> --> -->

<!-- <!-- <!-- ### Modelo Cheio --> --> -->


<!-- <!-- <!-- ```{r n_nRef comparacao modelos cheios} --> --> -->
<!-- <!-- <!-- l_md <- vector("list",8) --> --> -->
<!-- <!-- <!-- names(l_md) <- c("k0 1|Site","k0 MN|Site","k0 k0*MN|Site", --> --> -->
<!-- <!-- <!--                  "kf 1|Site","kf MN|Site", --> --> -->
<!-- <!-- <!--                  "d/L_plot 1|Site","d/L_plot MN|Site","d/L_plot d/L_plot*MN|Site") --> --> -->
<!-- <!-- <!-- l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + (1|SiteCode), --> --> -->
<!-- <!-- <!--                    family = "binomial",data=df_resultados, --> --> -->
<!-- <!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> -->
<!-- <!-- <!-- l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + (MN|SiteCode), --> --> -->
<!-- <!-- <!--                    family = "binomial",data=df_resultados, --> --> -->
<!-- <!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> -->
<!-- <!-- <!-- l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + (MN*k_1.z|SiteCode), --> --> -->
<!-- <!-- <!--                    family = "binomial",data=df_resultados, --> --> -->
<!-- <!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> -->
<!-- <!-- <!-- l_md[[4]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k * MN + (1|SiteCode), --> --> -->
<!-- <!-- <!--                    family = "binomial",data=df_resultados, --> --> -->
<!-- <!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> -->
<!-- <!-- <!-- l_md[[5]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k * MN + (MN|SiteCode), --> --> -->
<!-- <!-- <!--                    family = "binomial",data=df_resultados, --> --> -->
<!-- <!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> -->
<!-- <!-- <!-- l_md[[6]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + (1|SiteCode), --> --> -->
<!-- <!-- <!--                    family = "binomial",data=df_resultados, --> --> -->
<!-- <!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> -->
<!-- <!-- <!-- l_md[[7]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + (MN|SiteCode), --> --> -->
<!-- <!-- <!--                    family = "binomial",data=df_resultados, --> --> -->
<!-- <!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> -->
<!-- <!-- <!-- l_md[[8]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + (MN*d_Lplot.z|SiteCode), --> --> -->
<!-- <!-- <!--                    family = "binomial",data=df_resultados, --> --> -->
<!-- <!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> -->
<!-- <!-- <!-- AICctab(l_md,weights=T) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- O único modelo plausível é aquele com função de ligação logito, a variável d/L_plot e a estrutura aleatória MN * d/L_plot|SiteCode. Segue avaliação do pressuposto binomial(link=cloglog): --> --> -->

<!-- <!-- <!-- ```{r auditoria mais plausivel md_n.ref1} --> --> -->
<!-- <!-- <!-- md_nRef <- l_md[["d/L_plot d/L_plot*MN|Site"]] --> --> -->
<!-- <!-- <!-- p_plot <- DHARMa::simulateResiduals(md_nRef,n=1000) --> --> -->
<!-- <!-- <!-- plot(p_plot) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 1.2__ Resíduos Quantílicos do modelo cheio para n_nRef ~ p*d_Lplot*MN + (d_Lplot*MN|SiteCode) --> --> -->

<!-- <!-- <!-- Os resíduos quantílicos apontam que a distribuição dos resíduos não adere à distribuição uniforme, o que indica que a distribuição binomial(link=cloglog) não é um bom pressuposto para o conjunto dos dados. Segue resíduos pearson: --> --> -->

<!-- <!-- <!-- ```{r auditoria mais plausivel md_n.ref2} --> --> -->
<!-- <!-- <!-- l_p <- vector("list",4) --> --> -->
<!-- <!-- <!-- l_p[[1]] <- plot(md_nRef, sqrt(abs(resid(.)))~fitted(.), --> --> -->
<!-- <!-- <!--                  type=c("p","smooth"),ylab=expression(sqrt(abs(resid)))) --> --> -->
<!-- <!-- <!-- l_p[[2]] <- plot(md_nRef,resid(.,type="pearson")~p.z, --> --> -->
<!-- <!-- <!--       type=c("p","smooth"), --> --> -->
<!-- <!-- <!--       id=0.05,idLabels=~SiteCode) --> --> -->
<!-- <!-- <!-- l_p[[3]] <- plot(md_nRef,resid(.,type="pearson")~d_Lplot.z, --> --> -->
<!-- <!-- <!--       type=c("p","smooth"), --> --> -->
<!-- <!-- <!--       id=0.05,idLabels=~SiteCode) --> --> -->
<!-- <!-- <!-- l_p[[4]] <- plot(md_nRef,MN~resid(.,type="pearson"), --> --> -->
<!-- <!-- <!--       type=c("p","smooth"), --> --> -->
<!-- <!-- <!--       id=0.05,idLabels=~SiteCode) --> --> -->
<!-- <!-- <!-- do.call("grid.arrange",c(l_p,ncol=2)) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 1.3__ Resíduos "Pearson" do modelo cheio para n_ref ~ p * I(d/L_plot)*MN + (I(d/L_plot)|SiteCode) --> --> -->

<!-- <!-- <!-- Os resíduos de Pearson indicam que podem existir outliers: alguns sítios apresentam erros agrupados em valores extremos. Pelo gráfico dos resíduos por MN parecem existir 5 sítios em que apresentam comportamento muito distinto dos demais. --> --> -->

<!-- <!-- <!-- ```{r selecao do modelo cheio sem os sitios outliers} --> --> -->
<!-- <!-- <!-- # prepração dos dados --> --> -->
<!-- <!-- <!-- df_md_n_nRef <- augment(md_nRef) --> --> -->
<!-- <!-- <!-- df_md_n_nRef$.pearson_resid <- resid(md_nRef,type="pearson") --> --> -->
<!-- <!-- <!-- Sites <- df_md_n_nRef %>%  --> --> -->
<!-- <!-- <!--   filter(.pearson_resid>100 | .pearson_resid< -50) %>% .$SiteCode %>% as.character() --> --> -->
<!-- <!-- <!-- df_resultados.s_out <- df_resultados %>% filter(!(SiteCode %in% Sites)) --> --> -->
<!-- <!-- <!-- # seleção do modelo mais plausível --> --> -->
<!-- <!-- <!-- l_md <- vector("list",8) --> --> -->
<!-- <!-- <!-- names(l_md) <- c("k0 1|Site","k0 MN|Site","k0 k0*MN|Site", --> --> -->
<!-- <!-- <!--                  "kf 1|Site","kf MN|Site", --> --> -->
<!-- <!-- <!--                  "d/L_plot 1|Site","d/L_plot MN|Site","d/L_plot d/L_plot*MN|Site") --> --> -->
<!-- <!-- <!-- l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + (1|SiteCode), --> --> -->
<!-- <!-- <!--                    family = "binomial",data=df_resultados.s_out, --> --> -->
<!-- <!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> -->
<!-- <!-- <!-- l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + (MN|SiteCode), --> --> -->
<!-- <!-- <!--                    family = "binomial",data=df_resultados.s_out, --> --> -->
<!-- <!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> -->
<!-- <!-- <!-- l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + (MN*k_1.z|SiteCode), --> --> -->
<!-- <!-- <!--                    family = "binomial",data=df_resultados.s_out, --> --> -->
<!-- <!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> -->
<!-- <!-- <!-- l_md[[4]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k * MN + (1|SiteCode), --> --> -->
<!-- <!-- <!--                    family = "binomial",data=df_resultados.s_out, --> --> -->
<!-- <!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> -->
<!-- <!-- <!-- l_md[[5]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k * MN + (MN|SiteCode), --> --> -->
<!-- <!-- <!--                    family = "binomial",data=df_resultados.s_out, --> --> -->
<!-- <!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> -->
<!-- <!-- <!-- l_md[[6]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + (1|SiteCode), --> --> -->
<!-- <!-- <!--                    family = "binomial",data=df_resultados.s_out, --> --> -->
<!-- <!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> -->
<!-- <!-- <!-- l_md[[7]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + (MN|SiteCode), --> --> -->
<!-- <!-- <!--                    family = "binomial",data=df_resultados.s_out, --> --> -->
<!-- <!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> -->
<!-- <!-- <!-- l_md[[8]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + (MN*d_Lplot.z|SiteCode), --> --> -->
<!-- <!-- <!--                    family = "binomial",data=df_resultados.s_out, --> --> -->
<!-- <!-- <!--                    control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> -->
<!-- <!-- <!-- AICctab(l_md,weights=T) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- A seleção de modelos é robusta à remoção dos outliers: o único plausível é link=cloglog, d/L_plot e d/L_plot *MN | SiteCode --> --> -->

<!-- <!-- <!-- ```{r auditoria md_n.ref sem outliers 1} --> --> -->
<!-- <!-- <!-- p_plot <- DHARMa::simulateResiduals(l_md[["d/L_plot d/L_plot*MN|Site"]],n=1000) --> --> -->
<!-- <!-- <!-- plot(p_plot) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __figura 1.4__ Resíduos Quantílicos do modelo cheio sem outliers --> --> -->


<!-- <!-- <!-- O pressuposto de binomial(link=cloglog) continua não sendo adequado.   --> --> -->

<!-- <!-- <!-- ### Modelo mais plausível: seleção e avaliação --> --> -->

<!-- <!-- <!-- Sigo com a seleção das variáveis. A estrutura aleatória completa é (MN * d_Lplot.z | SiteCode) para os modelos que possuirem a interação MN*d_Lplot.z, para os demais modelos que não apresentam esse termo a estrutura aleatória segue a relação de MN e d_Lplot.z na estrutura fixa.  --> --> -->

<!-- <!-- <!-- ```{r n_nRef selecao de modelos} --> --> -->
<!-- <!-- <!-- l_md <- vector("list",19) --> --> -->
<!-- <!-- <!-- names(l_md) <- c("p*d*MN",# modelo cheio --> --> -->
<!-- <!-- <!--                  "p*d*MN-p:d:MN", #MC - 3a ordem --> --> -->
<!-- <!-- <!--                  "p*(d+MN)","d*(p+MN)","MN*(p+d)", #2 interações --> --> -->
<!-- <!-- <!--                  "p*d+MN","p*MN+d","d*MN+p", #1 interação + preditor --> --> -->
<!-- <!-- <!--                  "p*d","p*MN","d*MN", #1 interação --> --> -->
<!-- <!-- <!--                  "p+d+MN",#aditivo 3 --> --> -->
<!-- <!-- <!--                  "p+d","p+MN","d+MN", #aditivo 2  --> --> -->
<!-- <!-- <!--                  "p","d","MN", #preditor isolado --> --> -->
<!-- <!-- <!--                  "1") #nulo --> --> -->
<!-- <!-- <!-- #modelo cheio --> --> -->
<!-- <!-- <!-- l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + (d_Lplot.z * MN|SiteCode), family = "binomial",data=df_resultados, --> --> -->
<!-- <!-- <!--               control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> -->
<!-- <!-- <!-- #modelo cheio - interação 3a ordem --> --> -->
<!-- <!-- <!-- l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN - p.z:d_Lplot.z:MN + (d_Lplot.z * MN|SiteCode), family = "binomial",data=df_resultados, --> --> -->
<!-- <!-- <!--               control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> -->
<!-- <!-- <!-- #2 interações --> --> -->
<!-- <!-- <!-- l_md[[3]] <- glmer(c--- --> -->
<!-- <!-- <!-- title: "Estatistica" --> --> -->
<!-- <!-- <!-- author: "Mori, Danilo" --> --> -->
<!-- <!-- <!-- date: "31/10/2019" --> --> -->
<!-- <!-- <!-- output:  --> --> -->
<!-- <!-- <!--   html_document: --> --> -->
<!-- <!-- <!--     toc: true --> --> -->
<!-- <!-- <!--     toc_depth: 5 --> --> -->
<!-- <!-- <!-- editor_options:  --> --> -->
<!-- <!-- <!--   chunk_output_type: inline --> --> -->
<!-- <!-- <!-- --- --> --> -->

<!-- <!-- <!-- <!-- <style> --> --> --> -->
<!-- <!-- <!-- <!-- body { --> --> --> -->
<!-- <!-- <!-- <!-- text-align: justify} --> --> --> -->
<!-- <!-- <!-- <!-- </style> --> --> --> -->

<!-- <!-- <!-- <!-- ```{r setup, include=TRUE,echo=FALSE} --> --> --> -->
<!-- <!-- <!-- <!-- knitr::opts_chunk$set(echo = FALSE, tidy = FALSE, include = TRUE, warning = FALSE,cache = TRUE,message=FALSE,eval=TRUE) --> --> --> -->
<!-- <!-- <!-- <!-- knitr::opts_knit$set(root.dir = "~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/") --> --> --> -->
<!-- <!-- <!-- <!-- setwd("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/") --> --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- ```{r pacotes,eval=TRUE,echo=F} --> --> -->
<!-- <!-- <!-- library(gtools) --> --> -->
<!-- <!-- <!-- library(doMC) --> --> -->
<!-- <!-- <!-- library(mgcv) --> --> -->
<!-- <!-- <!-- library(gratia) --> --> -->
<!-- <!-- <!-- library(GUILDS) --> --> -->
<!-- <!-- <!-- library(broom) --> --> -->
<!-- <!-- <!-- library(bbmle) --> --> -->
<!-- <!-- <!-- library(gamm4) --> --> -->
<!-- <!-- <!-- library(lme4) --> --> -->
<!-- <!-- <!-- library(merTools) --> --> -->
<!-- <!-- <!-- library(magrittr) --> --> -->
<!-- <!-- <!-- library(gridExtra) --> --> -->
<!-- <!-- <!-- library(plotly) --> --> -->
<!-- <!-- <!-- library(sjPlot) --> --> -->
<!-- <!-- <!-- library(sjlabelled) --> --> -->
<!-- <!-- <!-- library(sjmisc) --> --> -->
<!-- <!-- <!-- library(ggplot2) --> --> -->
<!-- <!-- <!-- library(stringr) --> --> -->
<!-- <!-- <!-- library(tidyr) --> --> -->
<!-- <!-- <!-- library(plyr) --> --> -->
<!-- <!-- <!-- library(purrr) --> --> -->
<!-- <!-- <!-- library(dplyr) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- ```{r dados} --> --> -->
<!-- <!-- <!-- ### dados ### --> --> -->
<!-- <!-- <!-- # leitura --> --> -->
<!-- <!-- <!-- df_resultados <- read.table(file="./resultados/df_resultados.csv",header = TRUE,sep = ";",dec = ".",as.is=FALSE) --> --> -->
<!-- <!-- <!-- df_resultados$k.0_1 <- 1 - df_resultados$k.0 --> --> -->
<!-- <!-- <!-- # padronização --> --> -->
<!-- <!-- <!-- level_k <- unique(as.character(df_resultados$k)) --> --> -->
<!-- <!-- <!-- df_resultados$k <- factor(as.character(df_resultados$k),levels = level_k) --> --> -->
<!-- <!-- <!-- levels(df_resultados$k)[19] <- "0.1" --> --> -->
<!-- <!-- <!-- df_resultados %<>% mutate(L_plot = 100*sqrt(Ntotal/DA), --> --> -->
<!-- <!-- <!--                           d_Lplot = d / L_plot, --> --> -->
<!-- <!-- <!--                           log_Stotal=log(Stotal)) --> --> -->
<!-- <!-- <!-- # z score --> --> -->
<!-- <!-- <!-- f_z <- function(x){ --> --> -->
<!-- <!-- <!--   m <- base::mean(x,na.rm=TRUE) --> --> -->
<!-- <!-- <!--   sd <- sd(x,na.rm=TRUE) --> --> -->
<!-- <!-- <!--   output <- (x-m)/sd --> --> -->
<!-- <!-- <!--   return(output) --> --> -->
<!-- <!-- <!-- }  --> --> -->
<!-- <!-- <!-- # names(df_resultados) --> --> -->
<!-- <!-- <!-- df_resultados.z <- as.data.frame(apply(df_resultados[c("p","Ntotal","log_Stotal","k.0","k.0_1","d_Lplot")],2,f_z)) --> --> -->
<!-- <!-- <!-- names(df_resultados.z) <- sapply(names(df_resultados.z), function(x) paste(gsub(".0","",x),".z",sep="")) --> --> -->
<!-- <!-- <!-- df_resultados %<>% cbind(.,df_resultados.z) --> --> -->
<!-- <!-- <!-- names(df_resultados)[c(5:6,26,33)] <- c("n_nRef","n_Ref","d_Lplot","d_Lplot.z") --> --> -->
<!-- <!-- <!-- df_resultados.U <- df_resultados %>% filter(MN=="EE") %>% distinct()  --> --> -->
<!-- <!-- <!-- # summary(df_resultados) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- # Número de SADs preditas não refutadas --> --> -->

<!-- <!-- <!-- ## Padrões gerais --> --> -->

<!-- <!-- <!-- ```{r n_nRef padroes gerais} --> --> -->
<!-- <!-- <!-- l_p <- vector("list",2) --> --> -->
<!-- <!-- <!-- l_p[[1]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[1:10]), --> --> -->
<!-- <!-- <!--                    aes(x=p,y=n_nRef)) +  --> --> -->
<!-- <!-- <!--   geom_point() +  --> --> -->
<!-- <!-- <!--   geom_smooth(method="loess") + --> --> -->
<!-- <!-- <!--   facet_grid(k~MN) --> --> -->
<!-- <!-- <!-- l_p[[2]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[11:20]), --> --> -->
<!-- <!-- <!--                    aes(x=p,y=n_nRef)) +  --> --> -->
<!-- <!-- <!--   geom_point() +  --> --> -->
<!-- <!-- <!--   geom_smooth(method="loess") + --> --> -->
<!-- <!-- <!--   facet_grid(k~MN)  --> --> -->
<!-- <!-- <!-- do.call("grid.arrange",c(l_p,ncol=2)) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 1.1__ número de SADs não refutadas ~ p * I(1-k) * MN. A linha azul é uma estimativa baseada em 'loess'.  --> --> -->

<!-- <!-- <!-- Para descrever estatisticamente o número de SADs preditas não refutadas iremos utilizar a distribuição binomial com função de ligação logito. Agruparemos os dados pelo sítio de amostragem. Esperamos que MNEE apresente melhor congruência com o observado para sítios em paisagens com proporção intermediária de cobertura vegetal e para cenários de extrema limitação de dispersão. Uma interpretação desta predição pode ser obtida se possibilitarmos que, para cada sítios de amostragem, a probabilidade de uma predição ser refutada seja uma função da variável de dispersão para cada modelo, ou seja, (dispersão * modelo neutro | sítio de amostragem). O modelo cheio considera a interação de terceira ordem entre as preditoras cobertura vegetal (p, contínua), dispersão (k, categorica; k_1, contínua; d_Lplot, contínua) e a classe do modelo neutro (MNEE e MNEI). Utilizamos uma abordagem baseada em seleção de modelos para determinar a relação entre as variáveis mais parcimoniosa. --> --> -->


<!-- <!-- <!-- ## GAMM binomial: número de predições não refutadas   --> --> -->

<!-- <!-- <!-- A hipótese de trabalho é sobre uma relação não linear, uma escolha são generalized additive models onde há maior flexibilidade para estimar a tendência global dos dados (Wood 2017). --> --> -->


<!-- <!-- <!-- ### Comparação de Modelos Cheios --> --> -->


<!-- <!-- <!-- ```{r gam binomial n_nRef selecao de variaveis, echo=TRUE} --> --> -->
<!-- <!-- <!-- l_md <- vector("list",6) --> --> -->
<!-- <!-- <!-- names(l_md) <- c("k 1|SiteCode", "k MN|SiteCode", --> --> -->
<!-- <!-- <!--                  "k_1 1|SiteCode","k_1 MN|SiteCode", --> --> -->
<!-- <!-- <!--                  "d/L 1|SiteCode","d/L MN|SiteCode") --> --> -->
<!-- <!-- <!-- # muitos parametros para poucos dados "k_1 k_1 * MN|SiteCode","d_Lplot d_Lplot * MN|SiteCode") --> --> -->
<!-- <!-- <!-- # k --> --> -->
<!-- <!-- <!-- l_md[[1]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs") + --> --> -->
<!-- <!-- <!--                    s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                    family = "binomial", --> --> -->
<!-- <!-- <!--                    data = df_resultados, method = "REML") --> --> -->
<!-- <!-- <!-- l_md[[2]] <- gam(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,k,by=MN,bs="fs") + --> --> -->
<!-- <!-- <!--                    s(SiteCode,by=MN,bs="re"), --> --> -->
<!-- <!-- <!--                    family = "binomial", --> --> -->
<!-- <!-- <!--                    data = df_resultados, method = "REML") --> --> -->
<!-- <!-- <!-- # k_1 --> --> -->
<!-- <!-- <!-- l_md[[3]] <- gam(cbind(n_nRef,100-n_nRef) ~ MN + s(p.z,by=MN,bs="tp") + s(k_1.z,by=MN,bs="tp") + ti(p.z,k_1.z,by=MN,bs=c("tp","tp")) + --> --> -->
<!-- <!-- <!--                    s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                    family = "binomial", --> --> -->
<!-- <!-- <!--                    data = df_resultados, method = "REML") --> --> -->
<!-- <!-- <!-- l_md[[4]] <- gam(cbind(n_nRef,100-n_nRef) ~ MN +  s(p.z,by=MN,bs="tp") + s(k_1.z,by=MN,bs="tp") + ti(p.z,k_1.z,by=MN,bs=c("tp","tp")) + --> --> -->
<!-- <!-- <!--                    s(SiteCode,by=MN,bs="re"), --> --> -->
<!-- <!-- <!--                    family = "binomial", --> --> -->
<!-- <!-- <!--                    data = df_resultados, method = "REML") --> --> -->
<!-- <!-- <!-- # d/L --> --> -->
<!-- <!-- <!-- l_md[[5]] <- gam(cbind(n_nRef,100-n_nRef) ~ MN + s(p.z,by=MN,bs="tp") + s(d_Lplot.z,by=MN,bs="tp") + ti(p.z,d_Lplot.z,by=MN,bs=c("tp","tp")) + --> --> -->
<!-- <!-- <!--                    s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                    family = "binomial", --> --> -->
<!-- <!-- <!--                    data = df_resultados, method = "REML") --> --> -->
<!-- <!-- <!-- l_md[[6]] <- gam(cbind(n_nRef,100-n_nRef) ~ MN +  s(p.z,by=MN,bs="tp") + s(d_Lplot.z,by=MN,bs="tp") + ti(p.z,d_Lplot.z,by=MN,bs=c("tp","tp")) + --> --> -->
<!-- <!-- <!--                    s(SiteCode,by=MN,bs="re"), --> --> -->
<!-- <!-- <!--                    family = "binomial", --> --> -->
<!-- <!-- <!--                    data = df_resultados, method = "REML") --> --> -->
<!-- <!-- <!-- AICctab(l_md,weights=TRUE) --> --> -->
<!-- <!-- <!-- # save(l_md,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/md_nRef.Rdata") --> --> -->
<!-- <!-- <!-- # load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/md_nRef.Rdata") --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- O único modelo plausível considera a variável k (fator) e estrutura aleatória MN|SiteCode. --> --> -->

<!-- <!-- <!-- ```{r appraise l_md[[k MN|SiteCode]] 1} --> --> -->
<!-- <!-- <!-- appraise(l_md[["k MN|SiteCode"]]) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 1.2__ appraise(gam( cbind(n_nRef,100-n_nRef) ~ k*MN + s(p.z,MN,by=k), binomial(logit) )   --> --> -->

<!-- <!-- <!-- ```{r sumario md_nRef mais plausivel} --> --> -->
<!-- <!-- <!-- summary(l_md[["k MN|SiteCode"]]) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- ```{r estudo gamm4,include=FALSE} --> --> -->
<!-- <!-- <!-- teste_gamm4 <- gamm4(cbind(n_nRef,100-n_nRef) ~ k * MN + s(p.z,MN,by=k,bs="fs"), --> --> -->
<!-- <!-- <!--                      random = ~(MN|SiteCode), --> --> -->
<!-- <!-- <!--                      family = "binomial", --> --> -->
<!-- <!-- <!--                      data = df_resultados, method = "REML") --> --> -->
<!-- <!-- <!-- ``` --> --> -->


<!-- <!-- <!-- ### Comparação com o observado   --> --> -->

<!-- <!-- <!-- ```{r predicao n_nRef} --> --> -->
<!-- <!-- <!-- ## modelo mais plausível --> --> -->
<!-- <!-- <!-- df_pred.k <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1], --> --> -->
<!-- <!-- <!--                           MN=levels(df_resultados$MN), --> --> -->
<!-- <!-- <!--                           k=levels(df_resultados$k), --> --> -->
<!-- <!-- <!--                           p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=103)) %>%  --> --> -->
<!-- <!-- <!--   mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p)) --> --> -->
<!-- <!-- <!-- df_pred.k <- cbind(df_pred.k, --> --> -->
<!-- <!-- <!--                    predict(l_md[["k MN|SiteCode"]], --> --> -->
<!-- <!-- <!--                            df_pred.k,type="response",se.fit=TRUE)) --> --> -->
<!-- <!-- <!-- df_pred.k[,c("fit","se.fit")] <- df_pred.k[,c("fit","se.fit")]*100 --> --> -->


<!-- <!-- <!-- ## segundo modelo mais plausível (mais fácil de interpretar) --> --> -->
<!-- <!-- <!-- # df_pred.k_1 <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1], --> --> -->
<!-- <!-- <!-- #                             MN=levels(df_resultados$MN), --> --> -->
<!-- <!-- <!-- #                             k_1.z=unique(df_resultados$k_1.z), --> --> -->
<!-- <!-- <!-- #                             p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=103)) --> --> -->
<!-- <!-- <!-- # df_pred.k_1 <- cbind(df_pred.k_1, --> --> -->
<!-- <!-- <!-- #                      predict(l_md[["k_1 MN|SiteCode"]], --> --> -->
<!-- <!-- <!-- #                              df_pred.k_1,type="response",se.fit=TRUE)) --> --> -->
<!-- <!-- <!-- # df_pred.k_1[,c("fit","se.fit")] <- df_pred.k_1[,c("fit","se.fit")]*100 --> --> -->
<!-- <!-- <!-- # names(df_pred.k_1)[5:6] <- c("fit.k_1","se.k_1") --> --> -->
<!-- <!-- <!-- # df_pred.k_1 %<>% inner_join(x=., --> --> -->
<!-- <!-- <!-- #                             y=distinct(select(df_resultados,k,k_1.z,p,p.z)), --> --> -->
<!-- <!-- <!-- #                             by=c("k_1.z","p.z")) --> --> -->
<!-- <!-- <!-- # Gráficos Exploratórios --> --> -->
<!-- <!-- <!-- # l_p <- vector("list",2) --> --> -->
<!-- <!-- <!-- # l_p[[1]] <- --> --> -->
<!-- <!-- <!-- ggplot(df_pred.k,aes(x=p,y=fit,color=MN)) + --> --> -->
<!-- <!-- <!-- geom_line() + --> --> -->
<!-- <!-- <!-- facet_wrap(~k,ncol=4) + --> --> -->
<!-- <!-- <!-- labs(title = "MN*k + s(p,k,by=MN,bs=fs)") + ylab("Pr(não refutar)") + --> --> -->
<!-- <!-- <!-- scale_color_manual(values=c("#FF0000", "#000000")) --> --> -->
<!-- <!-- <!-- # l_p[[2]] <- ggplot(df_pred.k_1,aes(x=p.z,y=fit.k_1,color=MN)) + --> --> -->
<!-- <!-- <!--   # geom_line() + --> --> -->
<!-- <!-- <!--   # facet_wrap(~k,ncol=5) + --> --> -->
<!-- <!-- <!--   # labs(title = "ti(p,k_1,by=MN)") + --> --> -->
<!-- <!-- <!--   # ylab("") --> --> -->
<!-- <!-- <!-- # do.call("grid.arrange",c(l_p,ncol=2)) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- <!-- __Figura 1.3__ Probabilidade de não refutar uma SAD neutra para cada modelo estatístico (título dos paineis); na esquerda o modelo mais plausível, na esquerda o segundo modelo plausível (>1000 deltaAIC). Os valores médios de cada modelo neutro apresentam semelhante entre os dois gráficos, contudo o modelo mais plausível apresenta maior flexibilidade na descrição dos modelos.  --> --> --> -->


<!-- <!-- <!-- ```{r predito e observado n_nRef graficos} --> --> -->
<!-- <!-- <!-- # código adaptado de Pedersen et al. 2017 Support Information --> --> -->
<!-- <!-- <!-- # gráficos --> --> -->
<!-- <!-- <!-- l_p <- vector("list",2) --> --> -->
<!-- <!-- <!-- l_p[[1]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[1:10]),aes(x=p,y=n_nRef)) +  --> --> -->
<!-- <!-- <!--   geom_point() + facet_grid(k~MN) + --> --> -->
<!-- <!-- <!--   # k --> --> -->
<!-- <!-- <!--   geom_ribbon(aes(ymin=I(fit - 2*se.fit), ymax=I(fit + 2*se.fit), x=p), --> --> -->
<!-- <!-- <!--               data=filter(df_pred.k,k %in% levels(df_resultados$k)[1:10]), --> --> -->
<!-- <!-- <!--               alpha=0.3, --> --> -->
<!-- <!-- <!--               inherit.aes=FALSE, --> --> -->
<!-- <!-- <!--               color="red") + --> --> -->
<!-- <!-- <!--   geom_line(aes(y=fit),color="white", data=filter(df_pred.k,k %in% levels(df_resultados$k)[1:10])) + --> --> -->
<!-- <!-- <!--   ylab("Pr(not ref. SAD)") + xlab("Proportion of Tree Cover") + --> --> -->
<!-- <!-- <!--   theme(panel.background = element_rect(fill = "gray"), --> --> -->
<!-- <!-- <!--         panel.grid.major = element_blank(), --> --> -->
<!-- <!-- <!--         panel.grid.minor = element_blank()) --> --> -->
<!-- <!-- <!--   # # k_1 --> --> -->
<!-- <!-- <!--   # geom_ribbon(aes(ymin=exp(fit.k_1 - 2*se.k_1), ymax=exp(fit.k_1 + 2*se.k_1), x=p.z), --> --> -->
<!-- <!-- <!--   #             data=filter(df_pred.k_1,k %in% levels(df_resultados$k)[1:10]),  --> --> -->
<!-- <!-- <!--   #             alpha=0.3,  --> --> -->
<!-- <!-- <!--   #             inherit.aes=FALSE, --> --> -->
<!-- <!-- <!--   #             color="blue") + --> --> -->
<!-- <!-- <!--   # geom_line(aes(y=fit.k_1), data=filter(df_pred.k_1,k %in% levels(df_resultados$k)[1:10])) --> --> -->
<!-- <!-- <!-- l_p[[2]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[11:20]),aes(x=p,y=n_nRef)) +  --> --> -->
<!-- <!-- <!--   geom_point() + facet_grid(k~MN) + --> --> -->
<!-- <!-- <!--   # k --> --> -->
<!-- <!-- <!--   geom_ribbon(aes(ymin=I(fit - 2*se.fit), ymax=I(fit + 2*se.fit), x=p), --> --> -->
<!-- <!-- <!--               data=filter(df_pred.k,k %in% levels(df_resultados$k)[11:20]),  --> --> -->
<!-- <!-- <!--               alpha=0.3,  --> --> -->
<!-- <!-- <!--               inherit.aes=FALSE, --> --> -->
<!-- <!-- <!--               color="red") + --> --> -->
<!-- <!-- <!--   geom_line(aes(y=fit),color="white", data=filter(df_pred.k,k %in% levels(df_resultados$k)[11:20])) + --> --> -->
<!-- <!-- <!--   ylab("") + xlab("Proportion of Tree Cover") + --> --> -->
<!-- <!-- <!--   theme(panel.background = element_rect(fill = "gray"), --> --> -->
<!-- <!-- <!--         panel.grid.major = element_blank(), --> --> -->
<!-- <!-- <!--         panel.grid.minor = element_blank()) --> --> -->
<!-- <!-- <!--   # k_1 --> --> -->
<!-- <!-- <!--   # geom_ribbon(aes(ymin=exp(fit - 2*se.fit), ymax=exp(fit + 2*se.fit), x=p.z), --> --> -->
<!-- <!-- <!--   #             data=filter(df_pred.k_1,k %in% levels(df_resultados$k)[11:20]),  --> --> -->
<!-- <!-- <!--   #             alpha=0.3,  --> --> -->
<!-- <!-- <!--   #             inherit.aes=FALSE, --> --> -->
<!-- <!-- <!--   #             color="blue") + --> --> -->
<!-- <!-- <!--   # geom_line(aes(y=fit), data=filter(df_pred.k_1,k %in% levels(df_resultados$k)[11:20])) --> --> -->
<!-- <!-- <!-- do.call("grid.arrange",c(l_p,ncol=2)) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 1.3__ Observado e predito pelo modelo mais plausível. Eixo x = prop. de cobertura vegetal na paisagem; Eixo y: número de SADs não refutadas. Em branco o padrão geral estimado e em vermelho o erro padrão.  --> --> -->

<!-- <!-- <!-- O padrão estimado parece ser muito sensível  a valores extremo: a média de EI parece estar muito abaixo da mediana; essa tendência também parece ser observada para algum grau do vale que surge para p.z ~ -1 e p->0.05. Vejo duas opções: a) avaliar outliers e b) parâmetros da gam (parâmetro de penalidade, número de funções base; por padrão ambos são estimados utilizando REML, começar pelo parâmetro de penalidade) --> --> -->

<!-- <!-- <!-- ### Melhoria do modelo mais plausível: CONSTRUÇÃO --> --> -->

<!-- <!-- <!-- #### comparação de smoothers --> --> -->

<!-- <!-- <!-- #### comparação de parâmetro de penalização --> --> -->


<!-- <!-- <!-- # diff_S = (S_obs - S_MN)/S_obs --> --> -->

<!-- <!-- <!-- ## Padrão Geral --> --> -->

<!-- <!-- <!-- ```{r preparacao dos dados} --> --> -->
<!-- <!-- <!-- df_resultados %<>% mutate(diff_S0 = (Stotal-S.MN_mean)/Stotal) --> --> -->
<!-- <!-- <!-- df_resultados$diff_S <- df_resultados$diff_S0 + min(df_resultados$diff_S)*(-1) + 0.01 --> --> -->
<!-- <!-- <!-- # hist(df_resultados$diff_S0,breaks=60) --> --> -->
<!-- <!-- <!-- # boxplot(I(df_resultados$diff_S0)) --> --> -->
<!-- <!-- <!-- ggplot(df_resultados,aes(x=log(Stotal),y=diff_S,group=MN)) + --> --> -->
<!-- <!-- <!--   geom_point() + --> --> -->
<!-- <!-- <!--   geom_smooth(method="loess") +  --> --> -->
<!-- <!-- <!--   ylab("(Sobs-S_MN)/Sobs") + --> --> -->
<!-- <!-- <!--   facet_wrap(~k,ncol=5,scales="free") --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 2.1__ diff_S = (S_obs - S_MN)/S_obs + (-1) * min(diff_S) + 0.01, inclinação_MNEE ~ 0 para todo k. --> --> -->

<!-- <!-- <!-- Parece que existem alguns outliers. De maneira geral MNEE apresenta boa congruência com os dados enquanto o comportamento de MNEI depende da dispersão: para k->100% o desvio aumento para ps extremos (bimodal/quadratica), apresentando boa congruência para proporção intermediárias de habitat, mas sempre subestimando S_obs. Com o aumento da capacidade de dispersão as estimavas de S se tornam mais próximas ao observado para p>0.5, superestimando o observado para valores elevados de p e k>0.5 o que leva a reduzir a porção de p em que MNEI faz uma boa aproximação. --> --> -->

<!-- <!-- <!-- ## GAMM: diff_S --> --> -->

<!-- <!-- <!-- Para modelar o padrão não linear dos dados vou utilizar GAMM: normal, Gamma(log) e Gamma(inverse) com duas estruturas aleatórias (1|SiteCode e MN|SiteCode).  --> --> -->

<!-- <!-- <!-- ### Modelo Cheio e Gráficos Diagnosticos --> --> -->

<!-- <!-- <!-- ```{r md cheio diff_S} --> --> -->
<!-- <!-- <!-- l_md.diff_S <- vector("list",length=6) --> --> -->
<!-- <!-- <!-- names(l_md.diff_S) <- c("normal id MN|SiteCode","normal id 1|SiteCode", --> --> -->
<!-- <!-- <!--                         "Gamma log MN|SiteCode","Gamma log 1|SiteCode", --> --> -->
<!-- <!-- <!--                         "Gamma inverse MN|SiteCode","Gamma inverse 1|SiteCode") --> --> -->
<!-- <!-- <!-- l_md.diff_S[[1]] <- gam(diff_S ~ k*MN + s(log_Stotal.z,bs="tp") + s(p.z,k,by=MN,bs="fs",xt=list(bs="tp")) + --> --> -->
<!-- <!-- <!--                           s(SiteCode,by=MN,bs="re"), --> --> -->
<!-- <!-- <!--                         data=df_resultados, --> --> -->
<!-- <!-- <!--                         family = "gaussian", --> --> -->
<!-- <!-- <!--                         method="REML") --> --> -->
<!-- <!-- <!-- l_md.diff_S[[2]] <- gam(diff_S ~ k*MN + s(log_Stotal.z,bs="tp") + s(p.z,k,by=MN,bs="fs",xt=list(bs="tp")) + --> --> -->
<!-- <!-- <!--                           s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                         data=df_resultados, --> --> -->
<!-- <!-- <!--                         family = "gaussian", --> --> -->
<!-- <!-- <!--                         method="REML") --> --> -->
<!-- <!-- <!-- l_md.diff_S[[3]] <- gam(diff_S ~ k*MN + s(log_Stotal.z,bs="tp") + s(p.z,k,by=MN,bs="fs",xt=list(bs="tp")) + --> --> -->
<!-- <!-- <!--                           s(SiteCode,by=MN,bs="re"), --> --> -->
<!-- <!-- <!--                         data=df_resultados, --> --> -->
<!-- <!-- <!--                         family = "Gamma", --> --> -->
<!-- <!-- <!--                         method="REML") --> --> -->
<!-- <!-- <!-- l_md.diff_S[[4]] <- gam(diff_S ~ k*MN + s(log_Stotal.z,bs="tp") + s(p.z,k,by=MN,bs="fs",xt=list(bs="tp")) + --> --> -->
<!-- <!-- <!--                           s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                         data=df_resultados, --> --> -->
<!-- <!-- <!--                         family = "Gamma", --> --> -->
<!-- <!-- <!--                         method="REML") --> --> -->
<!-- <!-- <!-- l_md.diff_S[[5]] <- gam(diff_S ~ k*MN + s(log_Stotal.z,bs="tp") + s(p.z,k,by=MN,bs="fs",xt=list(bs="tp")) + --> --> -->
<!-- <!-- <!--                           s(SiteCode,by=MN,bs="re"), --> --> -->
<!-- <!-- <!--                         data=df_resultados, --> --> -->
<!-- <!-- <!--                         family = "Gamma"(link="log"), --> --> -->
<!-- <!-- <!--                         method="REML") --> --> -->
<!-- <!-- <!-- l_md.diff_S[[6]] <- gam(diff_S ~ k*MN + s(log_Stotal.z,bs="tp") + s(p.z,k,by=MN,bs="fs",xt=list(bs="tp")) + --> --> -->
<!-- <!-- <!--                           s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                         data=df_resultados, --> --> -->
<!-- <!-- <!--                         family = "Gamma"(link="log"), --> --> -->
<!-- <!-- <!--                         method="REML") --> --> -->
<!-- <!-- <!-- AICctab(l_md.diff_S,weights=TRUE) --> --> -->
<!-- <!-- <!-- md_diffS <-  gam(diff_S0 ~ k*MN + s(log_Stotal.z,bs="tp") + s(p.z,k,by=MN,bs="fs",xt=list(bs="tp")) + --> --> -->
<!-- <!-- <!--                           s(SiteCode,by=MN,bs="re"), --> --> -->
<!-- <!-- <!--                         data=df_resultados, --> --> -->
<!-- <!-- <!--                         family = "gaussian", --> --> -->
<!-- <!-- <!--                         method="REML") --> --> -->
<!-- <!-- <!-- # l_md1 <- l_md.diff_S[1:2] --> --> -->
<!-- <!-- <!-- # l_md.diff_S[1:2] <- l_md1 --> --> -->
<!-- <!-- <!-- # save(l_md.diff_S,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diffS.Rdata") --> --> -->
<!-- <!-- <!-- # save(md_diffS,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/md_diffS.Rdata") --> --> -->
<!-- <!-- <!-- # load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/md_diffS.Rdata") --> --> -->
<!-- <!-- <!-- ``` --> --> -->


<!-- <!-- <!-- ```{r appraise diff_S[[k|SiteCode]]} --> --> -->
<!-- <!-- <!-- appraise(md_diffS) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 2.2__ Graficos diagnosticos do modelo mais plausível para diff_S.    --> --> -->

<!-- <!-- <!-- Parece que o pressuposto de distribuição normal não é adequado, assim como parece haver alguma tendência nos dados que não está sendo detectada. Especulo que existam outliers que estão inflenciando muito a estimativa dos dados.  --> --> -->

<!-- <!-- <!-- #### Observado e Predito   --> --> -->

<!-- <!-- <!-- ```{r observado e predito diff_S} --> --> -->
<!-- <!-- <!-- df_pred.k <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1], --> --> -->
<!-- <!-- <!--                           MN=levels(df_resultados$MN), --> --> -->
<!-- <!-- <!--                           k=levels(df_resultados$k), --> --> -->
<!-- <!-- <!--                           p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=103), --> --> -->
<!-- <!-- <!--                           log_Stotal.z=seq(min(df_resultados$log_Stotal.z),max(df_resultados$log_Stotal.z),length=103)) %>%  --> --> -->
<!-- <!-- <!--   mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p)) --> --> -->
<!-- <!-- <!-- df_pred.k <- cbind(df_pred.k, --> --> -->
<!-- <!-- <!--                    predict(md_diffS, --> --> -->
<!-- <!-- <!--                            df_pred.k,type="response",se.fit=TRUE)) --> --> -->
<!-- <!-- <!-- # grafico --> --> -->
<!-- <!-- <!-- l_p <- vector("list",2) --> --> -->
<!-- <!-- <!-- l_p[[1]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[1:10]),aes(x=p,y=diff_S0)) +  --> --> -->
<!-- <!-- <!--   geom_point() + facet_grid(k~MN,scales="free") + --> --> -->
<!-- <!-- <!--   geom_ribbon(aes(ymin=I(fit - 2*se.fit), ymax=I(fit + 2*se.fit), x=p), --> --> -->
<!-- <!-- <!--               data=filter(df_pred.k,k %in% levels(df_resultados$k)[1:10]), --> --> -->
<!-- <!-- <!--               alpha=0.3, --> --> -->
<!-- <!-- <!--               inherit.aes=FALSE, --> --> -->
<!-- <!-- <!--               color="red") + --> --> -->
<!-- <!-- <!--   geom_line(aes(y=fit),color="white", data=filter(df_pred.k,k %in% levels(df_resultados$k)[1:10])) + --> --> -->
<!-- <!-- <!--   ylab("(S_obs - S_modelo.neutro) * S_obs^(-1)") + xlab("Proportion of Tree Cover") + --> --> -->
<!-- <!-- <!--   theme(panel.background = element_rect(fill = "gray"), --> --> -->
<!-- <!-- <!--         panel.grid.major = element_blank(), --> --> -->
<!-- <!-- <!--         panel.grid.minor = element_blank()) --> --> -->
<!-- <!-- <!-- l_p[[2]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[11:20]),aes(x=p,y=diff_S0)) +  --> --> -->
<!-- <!-- <!--   geom_point() + facet_grid(k~MN,scales="free") + --> --> -->
<!-- <!-- <!--   geom_ribbon(aes(ymin=I(fit - 2*se.fit), ymax=I(fit + 2*se.fit), x=p), --> --> -->
<!-- <!-- <!--               data=filter(df_pred.k,k %in% levels(df_resultados$k)[11:20]),  --> --> -->
<!-- <!-- <!--               alpha=0.3,  --> --> -->
<!-- <!-- <!--               inherit.aes=FALSE, --> --> -->
<!-- <!-- <!--               color="red") + --> --> -->
<!-- <!-- <!--   geom_line(aes(y=fit),color="white", data=filter(df_pred.k,k %in% levels(df_resultados$k)[11:20])) + --> --> -->
<!-- <!-- <!--   ylab("") + xlab("Proportion of Tree Cover") + --> --> -->
<!-- <!-- <!--   theme(panel.background = element_rect(fill = "gray"), --> --> -->
<!-- <!-- <!--         panel.grid.major = element_blank(), --> --> -->
<!-- <!-- <!--         panel.grid.minor = element_blank()) --> --> -->
<!-- <!-- <!-- do.call("grid.arrange",c(l_p,ncol=2)) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 2.3__ Diferença na riqueza observada e estimada pela proporção de cobertura vegetal. --> --> -->

<!-- <!-- <!-- Os modelos ajustados para MNEI estão sistematicamente com problemas de errar a média (figura 1.1 e 1.4; figura 2.1 e 2.3). Especulo que talvez alguns pontos estão influenciando muito as estimativas centrais ou estou usando configuração errada nas funções. Além disso para MNEI percebo que a tendência geral não está descrevendo o padrão dos dados, em especial para k->1. --> --> -->


<!-- <!-- <!-- # U - taxa de especiação necessária para obter a riqueza observada no equilíbrio --> --> -->

<!-- <!-- <!-- ## Padrões Gerais --> --> -->

<!-- <!-- <!-- ```{r padroes gerais U,echo=FALSE,fig.width=6,fig.height=4} --> --> -->
<!-- <!-- <!-- # graficos --> --> -->
<!-- <!-- <!-- l_p <- vector("list",4) --> --> -->
<!-- <!-- <!-- l_p[[1]] <- ggplot(df_resultados,aes(x=k,y=U_med)) + --> --> -->
<!-- <!-- <!--   geom_point() + --> --> -->
<!-- <!-- <!--   geom_line(aes(group=SiteCode)) + --> --> -->
<!-- <!-- <!--   geom_boxplot(aes(group=k)) --> --> -->
<!-- <!-- <!-- l_p[[2]] <- ggplot(df_resultados,aes(x=p,y=U_med)) + --> --> -->
<!-- <!-- <!--   geom_point() + --> --> -->
<!-- <!-- <!--   geom_smooth(method = "auto") + --> --> -->
<!-- <!-- <!--   labs(y="") --> --> -->
<!-- <!-- <!-- l_p[[3]] <- ggplot(df_resultados,aes(x=log(Stotal),y=U_med)) + --> --> -->
<!-- <!-- <!--   geom_point() + --> --> -->
<!-- <!-- <!--   geom_smooth(method = "auto") --> --> -->
<!-- <!-- <!-- l_p[[4]] <- ggplot(df_resultados,aes(x=p,y=log(Stotal))) + --> --> -->
<!-- <!-- <!--   geom_point() + --> --> -->
<!-- <!-- <!--   geom_smooth(method="auto") --> --> -->
<!-- <!-- <!-- do.call("grid.arrange",c(l_p,ncol=2)) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 3.1__ Padrões gerais de U_med: ~ k (% de propágulos até a vizinhança imediata da planta progenitora); ~ Stotal (riqueza observada na área amostral). E o padrão empírico encontrado nos dados Stotal ~ p --> --> -->


<!-- <!-- <!-- ```{r padroes gerais U por SiteCode,echo=FALSE,fig.height=50,fig.width=12,include=FALSE} --> --> -->
<!-- <!-- <!-- # dados --> --> -->
<!-- <!-- <!-- df_plot <- df_resultados %>% select(SiteCode,p,U_med,k,d_Lplot) %>% --> --> -->
<!-- <!-- <!--   mutate(label_facet.wrap = paste0(SiteCode,";p=",round(p,4))) %>% --> --> -->
<!-- <!-- <!--   distinct() %>% arrange(p) --> --> -->
<!-- <!-- <!-- levels_label <- unique(df_plot$label_facet.wrap) --> --> -->
<!-- <!-- <!-- df_plot$label_facet.wrap <- factor(df_plot$label_facet.wrap,levels = levels_label) --> --> -->
<!-- <!-- <!-- # graficos --> --> -->
<!-- <!-- <!-- l_p <- vector("list",2) --> --> -->
<!-- <!-- <!-- l_p[[1]] <- ggplot(df_plot,aes(x=k,U_med)) + --> --> -->
<!-- <!-- <!--   geom_point() + --> --> -->
<!-- <!-- <!--   geom_line(aes(group=SiteCode)) + --> --> -->
<!-- <!-- <!--   facet_wrap(~label_facet.wrap,ncol=5,scales="free") + --> --> -->
<!-- <!-- <!--   ggtitle(label="eixo x = k") --> --> -->
<!-- <!-- <!-- l_p[[2]] <- ggplot(df_plot,aes(x=d_Lplot,U_med)) + --> --> -->
<!-- <!-- <!--   geom_point() + --> --> -->
<!-- <!-- <!--   geom_line(aes(group=SiteCode)) + --> --> -->
<!-- <!-- <!--   facet_wrap(~label_facet.wrap,ncol=5,scales="free") + --> --> -->
<!-- <!-- <!--   ggtitle(label="eixo x = d / L_plot") --> --> -->
<!-- <!-- <!-- do.call("grid.arrange",c(l_p,ncol=1)) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- <!-- __Figura 3.2__ Padrões gerais de U_med por SiteCode: ~ k (% de propágulos até a vizinhança imediata da planta progenitora); ~ d / L_plot (distância média de dispersão / Lado do área amostral) --> --> --> -->


<!-- <!-- <!-- ## GAMM --> --> -->

<!-- <!-- <!-- Como os modelos com estrutura aleatória mais complexa levam muito tempo para estimar, irei começar com a estrutura aleatória mais simples para avaliar qual a melhor variável de dispersão e se for necessário refazer a seleção da estrutura aleatória. --> --> -->

<!-- <!-- <!-- <!-- Para descrever o padrão de U em função da proporção de habitat disponível e da diminuição da limitação de dispersão vamos utilizar GAMM (generalized additive mixed models, Wood 2017). Há pelo menos 3 formas de descrevermos o padrão global (Pedersen et al. 2019): a) um intercepto por SiteCode (1|SiteCode); b) um smoother por SiteCode (dispersão | SiteCode), porém com penalização para aqueles smoothers muito distintos do padrão global; e c) um smoother por SiteCode (dispersão | SiteCode) com seu próprio parâmetro de 'flexibilidade' (smoothing parameter).    --> --> --> -->

<!-- <!-- <!-- <!-- GAMM oferecem grande flexibilidade ao custo de aumento do número de parâmetros estimados e do custo computacional, além da perda de interpretabilidade. Então irei começar por um modelo cuja estrutura aleatória é a mais simples possível (1 intercepto por SiteCode) para poder oferecer mais flexibilidade para o tensor(variável_dispersão,p).    --> --> --> -->

<!-- <!-- <!-- <!-- ### Seleção de Modelo cheio   --> --> --> -->

<!-- <!-- <!-- <!-- - 2 famílias: gaussian e gamma   --> --> --> -->
<!-- <!-- <!-- <!-- - 3 funções de ligação: identity (apenas para gaussian), log, inverse   --> --> --> -->
<!-- <!-- <!-- <!-- - 2 variáveis concorrentes para descrever a dispersão: (1 - k) e (d/L_plot)   --> --> --> -->
<!-- <!-- <!-- <!-- - log_Stotal.z como preditora linear   --> --> --> -->
<!-- <!-- <!-- <!-- - (1|SiteCode) como estrutura aleatória   --> --> --> -->

<!-- <!-- <!-- <!-- __exemplo de código:__   --> --> --> -->
<!-- <!-- <!-- <!-- gam(U_med ~ s(d_Lplot.z) + s(p.z) + ti(d_Lplot.z,p.z) +   --> --> --> -->
<!-- <!-- <!-- <!--                       log_Stotal.z +   --> --> --> -->
<!-- <!-- <!-- <!--                       s(SiteCode,bs="re"),   --> --> --> -->
<!-- <!-- <!-- <!--                     family="gaussian",   --> --> --> -->
<!-- <!-- <!-- <!--                     data = df_resultados, method = "REML",control=ctrl)   --> --> --> -->

<!-- <!-- <!-- __Tabela de Seleção do Modelo Mais plausível:__   --> --> -->

<!-- <!-- <!-- ```{r selecao de modelo cheio GAMM(U)} --> --> -->
<!-- <!-- <!-- ctrl <- list(nthreads=3) #número de cores para paralelizar --> --> -->
<!-- <!-- <!-- l_md.U <- vector("list",length = 15) --> --> -->
<!-- <!-- <!-- names(l_md.U) <- c("d id normal","d log normal", "d inverse normal", "d log gamma", "d inverse gamma", --> --> -->
<!-- <!-- <!--                  "1-k id normal","1-k log normal", "1-k inverse normal", "1-k log gamma", "1-k inverse gamma", --> --> -->
<!-- <!-- <!--                  "k.f id normal","k.f log normal", "k.f inverse normal", "k.f log gamma", "k.f inverse gamma") --> --> -->
<!-- <!-- <!-- l_md.U[[1]] <- gam(U_med ~ s(d_Lplot) + s(p) + ti(d_Lplot,p) + --> --> -->
<!-- <!-- <!--                   s(log_Stotal) + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family="gaussian", --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=ctrl) --> --> -->
<!-- <!-- <!-- l_md.U[[2]] <- gam(U_med ~ s(d_Lplot) + s(p) + ti(d_Lplot,p) + --> --> -->
<!-- <!-- <!--                   s(log_Stotal) + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family=gaussian(link = "log"), --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=ctrl) --> --> -->
<!-- <!-- <!-- l_md.U[[3]] <- gam(U_med ~ s(d_Lplot) + s(p) + ti(d_Lplot,p) + --> --> -->
<!-- <!-- <!--                   s(log_Stotal) + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family=gaussian(link = "inverse"), --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=ctrl) --> --> -->
<!-- <!-- <!-- l_md.U[[4]] <- gam(U_med ~ s(d_Lplot) + s(p) + ti(d_Lplot,p) + --> --> -->
<!-- <!-- <!--                   s(log_Stotal) + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family=Gamma(link = "log"), --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=ctrl) --> --> -->
<!-- <!-- <!-- l_md.U[[5]] <- gam(U_med ~ s(d_Lplot) + s(p) + ti(d_Lplot,p) + --> --> -->
<!-- <!-- <!--                   s(log_Stotal) + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family=Gamma(link = "inverse"), --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=ctrl) --> --> -->
<!-- <!-- <!-- # k_1 --> --> -->
<!-- <!-- <!-- l_md.U[[6]] <- gam(U_med ~ s(k.0_1) + s(p) + ti(k.0_1,p) + --> --> -->
<!-- <!-- <!--                   s(log_Stotal) + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family="gaussian", --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=ctrl) --> --> -->
<!-- <!-- <!-- l_md.U[[7]] <- gam(U_med ~ s(k.0_1) + s(p) + ti(k.0_1,p) + --> --> -->
<!-- <!-- <!--                   s(log_Stotal) + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family=gaussian(link = "log"), --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=ctrl) --> --> -->
<!-- <!-- <!-- l_md.U[[8]] <- gam(U_med ~ s(k.0_1) + s(p) + ti(k.0_1,p) + --> --> -->
<!-- <!-- <!--                   s(log_Stotal) + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family=gaussian(link = "inverse"), --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=ctrl) --> --> -->
<!-- <!-- <!-- l_md.U[[9]] <- gam(U_med ~ s(k.0_1) + s(p) + ti(k.0_1,p) + --> --> -->
<!-- <!-- <!--                   s(log_Stotal) + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family=Gamma(link = "log"), --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=ctrl) --> --> -->
<!-- <!-- <!-- l_md.U[[10]] <- gam(U_med ~ s(k.0_1) + s(p) + ti(k.0_1,p) + --> --> -->
<!-- <!-- <!--                   s(log_Stotal) + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family=Gamma(link = "inverse"), --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=ctrl) --> --> -->
<!-- <!-- <!-- # k.f --> --> -->
<!-- <!-- <!-- l_md.U[[11]] <- gam(U_med ~ s(p,k,bs="fs") + k + --> --> -->
<!-- <!-- <!--                   s(log_Stotal) + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family="gaussian", --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=ctrl) --> --> -->
<!-- <!-- <!-- l_md.U[[12]] <- gam(U_med ~ s(p,k,bs="fs") + k + --> --> -->
<!-- <!-- <!--                   s(log_Stotal) + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family=gaussian(link = "log"), --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=ctrl) --> --> -->
<!-- <!-- <!-- l_md.U[[13]] <- gam(U_med ~ s(p,k,bs="fs") + k + --> --> -->
<!-- <!-- <!--                   s(log_Stotal) + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family=gaussian(link = "inverse"), --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=ctrl) --> --> -->
<!-- <!-- <!-- l_md.U[[14]] <- gam(U_med ~ s(p,k,bs="fs") + k + --> --> -->
<!-- <!-- <!--                   s(log_Stotal) + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family=Gamma(link = "log"), --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=ctrl) --> --> -->
<!-- <!-- <!-- l_md.U[[15]] <- gam(U_med ~ s(p,k,bs="fs") + k + --> --> -->
<!-- <!-- <!--                   s(log_Stotal) + --> --> -->
<!-- <!-- <!--                   s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                 family=Gamma(link = "inverse"), --> --> -->
<!-- <!-- <!--                 data = df_resultados.U, method = "REML",control=ctrl) --> --> -->
<!-- <!-- <!-- AICctab(l_md.U,weights=TRUE) --> --> -->
<!-- <!-- <!-- # save(l_md.U,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_U.Rdata") --> --> -->
<!-- <!-- <!-- # load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_U.Rdata") --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- Segue gráficos diagnosticos do modelo mais plausível --> --> -->


<!-- <!-- <!-- ```{r diag gamm(U) modelo cheio} --> --> -->
<!-- <!-- <!-- appraise(l_md.U[["d log gamma"]]) --> --> -->
<!-- <!-- <!-- p_plot <- DHARMa::simulateResiduals(l_md.U[["d log gamma"]],n=1000) --> --> -->
<!-- <!-- <!-- plot(p_plot) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 3.2__ Gráficos Diagnóstico do modelo mais plausível --> --> -->

<!-- <!-- <!-- O modelo apresenta boa congruência com os dados, porém parece existir outliers  no entando. --> --> -->

<!-- <!-- <!-- ```{r avaliacao outliers gammU} --> --> -->
<!-- <!-- <!-- # install.packages("mgcViz") --> --> -->
<!-- <!-- <!-- # library(mgcViz) --> --> -->
<!-- <!-- <!-- df_mdU <- augment(l_md.U[["d log gamma"]]) --> --> -->
<!-- <!-- <!-- # df_mdU %>% str --> --> -->
<!-- <!-- <!-- l_p <- vector("list",length = 2) --> --> -->
<!-- <!-- <!-- l_p[[1]] <- ggplot(df_mdU,aes(x=.fitted,y=.hat)) + --> --> -->
<!-- <!-- <!--   geom_point() --> --> -->
<!-- <!-- <!-- l_p[[2]] <- ggplot(df_mdU,aes(x=.fitted,y=.cooksd)) + --> --> -->
<!-- <!-- <!--   geom_point() --> --> -->
<!-- <!-- <!-- l_p[[3]] <- ggplot(df_mdU,aes(x=.fitted,y=.resid)) + --> --> -->
<!-- <!-- <!--   geom_point() --> --> -->
<!-- <!-- <!-- do.call("grid.arrange",c(l_p,ncol=3)) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 3.3__ Métricas de influência dos dados (broom::augment()) --> --> -->

<!-- <!-- <!-- Exclui os dois sítios com valores de grande influência do conjunto de dados: --> --> -->

<!-- <!-- <!-- ```{r modelo mais plausivel sem outliers U_med} --> --> -->
<!-- <!-- <!-- Site_outliers <- df_mdU %>% filter(.fitted < -7.5 & .resid < -0.5 | .cooksd > 0.01) %>% .$SiteCode %>% unique --> --> -->
<!-- <!-- <!-- md_U.sOut <- update(l_md.U[["d log gamma"]],data=filter(df_resultados.U,!(SiteCode %in% Site_outliers))) --> --> -->
<!-- <!-- <!-- appraise(md_U.sOut) --> --> -->
<!-- <!-- <!-- p_plot <- DHARMa::simulateResiduals(l_md.U[["d log gamma"]],n=1000) --> --> -->
<!-- <!-- <!-- plot(p_plot) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 3.4__ Grafico diagnostico do modelo mais plausivel sem os outliers. --> --> -->

<!-- <!-- <!-- ```{r draw md_U} --> --> -->
<!-- <!-- <!-- gratia::draw(md_U.sOut) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 4.5__ Efeitos Parciais do modelo mais plausível   --> --> -->



<!-- <!-- <!-- # Parâmetros dos Modelos Neutros --> --> -->

<!-- <!-- <!-- ## d / L_plot --> --> -->

<!-- <!-- <!-- ### padrões gerais   --> --> -->

<!-- <!-- <!-- ```{r d_Lplot padroes gerais} --> --> -->
<!-- <!-- <!-- ggplot(df_resultados,aes(x=k,y=d_Lplot)) + geom_jitter() + geom_boxplot() --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 5.1.1__ d/Lplot ~ k --> --> -->

<!-- <!-- <!-- ### Descrição Estatística --> --> -->

<!-- <!-- <!-- ```{r md d_Lplot} --> --> -->
<!-- <!-- <!-- md_d_plot <- gam(d ~ k + s(DA,by=k) + s(SiteCode,bs="re"), --> --> -->
<!-- <!-- <!--                  data=filter(df_resultados,MN=="EE"), --> --> -->
<!-- <!-- <!--                  family = Gamma(link="log"),method = "REML") --> --> -->
<!-- <!-- <!-- # md_d_plot.Normal <- gam(d ~ k + s(DA,by=k) + s(SiteCode,bs="re"),data=filter(df_resultados,MN=="EE")) # , family = Gamma(link = "inverse")  --> --> -->
<!-- <!-- <!-- gratia::appraise(md_d_plot) --> --> -->
<!-- <!-- <!-- show("exp(coef):") --> --> -->
<!-- <!-- <!-- exp(coef(md_d_plot)[1:20]) --> --> -->
<!-- <!-- <!-- # df_plot <- cbind(filter(df_resultados,MN=="EE"), --> --> -->
<!-- <!-- <!-- #                  predict(md_d_plot,type="response",se=TRUE)) --> --> -->
<!-- <!-- <!-- # ggplot(df_plot,aes(x=k,y=d)) + geom_jitter() + geom_boxplot(aes(y=fit)) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 5.1.2__ Gráficos Diagnósticos do modelo gam(d ~ k + s(DA,by=k), family=Gamma(link="log")). Exponenciação dos coeficientes parametricos estimados pelo modelo.  --> --> -->

<!-- <!-- <!-- ## m' --> --> -->

<!-- <!-- <!-- ### padrões gerais --> --> -->

<!-- <!-- <!-- ```{r padroes gerais m'} --> --> -->
<!-- <!-- <!-- # df_resultados %>% names --> --> -->
<!-- <!-- <!-- # df_resultados %>% ggplot(aes(x=p,y=m_)) + geom_point() + geom_smooth() + facet_wrap(~k,ncol=4,scales="free") --> --> -->
<!-- <!-- <!-- df_resultados %>% ggplot(aes(x=k,y=m_)) + geom_jitter() + geom_boxplot() --> --> -->
<!-- <!-- <!-- hist(I(df_resultados$m_),breaks=60) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 5.2.1__ m' ~ p (~k). A variável m' é uma função de p, d e I(1/J) --> --> -->

<!-- <!-- <!-- ### Descrição Estatística --> --> -->

<!-- <!-- <!-- ```{r md_m_} --> --> -->
<!-- <!-- <!-- l_md_m <- vector("list",length = 2) --> --> -->
<!-- <!-- <!-- l_md_m[[1]] <- gam(m_ ~ s(p) + s(d) + ti(p,d) + s(I(1/Ntotal)) + s(SiteCode,bs="re"),  --> --> -->
<!-- <!-- <!--                    family = Gamma(link = "log"),filter(df_resultados,MN=="EI"),method="REML") --> --> -->
<!-- <!-- <!-- l_md_m[[2]] <- gam(m_ ~ k + s(p,by=k) + s(I(1/Ntotal)) + s(SiteCode,bs="re"),  --> --> -->
<!-- <!-- <!--                    family = Gamma(link = "log"),filter(df_resultados,MN=="EI"),method="REML") --> --> -->
<!-- <!-- <!-- l_md_m[[3]] <- glmer(m_ ~ k * p + I(1/Ntotal) + (1|SiteCode),  --> --> -->
<!-- <!-- <!--                    family = Gamma(link = "log"),filter(df_resultados,MN=="EI")) --> --> -->

<!-- <!-- <!-- AICctab(l_md_m,weights=TRUE) --> --> -->
<!-- <!-- <!-- appraise(l_md_m[[2]]) --> --> -->
<!-- <!-- <!-- # gratia::draw(l_md_m[[2]]) --> --> -->
<!-- <!-- <!-- ``` --> --> -->


<!-- <!-- <!-- ## theta --> --> -->

<!-- <!-- <!-- ### padrões gerais --> --> -->

<!-- <!-- <!-- ```{r padroes gerais theta} --> --> -->
<!-- <!-- <!-- df_resultados %>% ggplot(aes(x=p,y=log(theta))) + geom_point() + facet_wrap(~k,ncol=4,scales="free") --> --> -->
<!-- <!-- <!-- hist(df_resultados$theta,breaks=60) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 5.3.1__ log(theta) ~ p  --> --> -->

<!-- <!-- <!-- ### Descrição Estatística --> --> -->

<!-- <!-- <!-- ```{r md theta e diag, warning=FALSE} --> --> -->
<!-- <!-- <!-- md_theta <- gam(theta ~ s(p,by=k) + s(U_med) + s(SiteCode,bs="re"), family=Gamma(link = "log"),data=filter(df_resultados,MN=="EI")) --> --> -->
<!-- <!-- <!-- appraise(md_theta) --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 5.3.2__ Gráfico diagnostico de gam(theta ~ s(p,by=k) + s(U_med) + s(SiteCode,bs="re"), family=Gamma(link = "log")) --> --> -->

<!-- <!-- <!-- ```{r outliers theta} --> --> -->
<!-- <!-- <!-- df_theta <- augment(md_theta) --> --> -->
<!-- <!-- <!-- df_theta$devianceResiduals <- residuals.gam(md_theta) --> --> -->
<!-- <!-- <!-- df_theta %>% ggplot(aes(y=devianceResiduals,x=k)) + geom_jitter() + geom_boxplot() --> --> -->
<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- __Figura 5.3.3__ Resíduos e valores fitados, parece que há alguns outliers   --> --> -->



<!-- <!-- <!-- ```{r md_theta S_out} --> --> -->
<!-- <!-- <!-- Site_outliers <- df_theta %>% filter(devianceResiduals >0.25 | devianceResiduals < -0.3) %>% .$SiteCode %>% unique --> --> -->
<!-- <!-- <!-- md_theta.Sout <- update(md_theta,data=filter(df_resultados,MN=="EI" & !(SiteCode %in% Site_outliers))) --> --> -->
<!-- <!-- <!-- appraise(md_theta) --> --> -->
<!-- <!-- <!-- ``` --> --> -->


<!-- <!-- <!-- <!--               control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> --> -->
<!-- <!-- <!-- <!-- l_md[[4]] <- glmer(cbind(n_nRef,100-n_nRef) ~ d_Lplot.z * (p.z + MN) + (d_Lplot.z * MN|SiteCode), family = "binomial",data=df_resultados, --> --> --> -->
<!-- <!-- <!-- <!--               control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> --> -->
<!-- <!-- <!-- <!-- l_md[[5]] <- glmer(cbind(n_nRef,100-n_nRef) ~ MN * (p.z + d_Lplot.z) + (d_Lplot.z * MN|SiteCode), family = "binomial",data=df_resultados, --> --> --> -->
<!-- <!-- <!-- <!--               control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> --> -->
<!-- <!-- <!-- <!-- #1 interação + preditor --> --> --> -->
<!-- <!-- <!-- <!-- l_md[[6]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z + MN + (MN+d_Lplot.z|SiteCode), family = "binomial",data=df_resultados, --> --> --> -->
<!-- <!-- <!-- <!--               control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> --> -->
<!-- <!-- <!-- <!-- l_md[[7]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * MN + d_Lplot.z + (MN+d_Lplot.z|SiteCode), family = "binomial",data=df_resultados, --> --> --> -->
<!-- <!-- <!-- <!--               control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> --> -->
<!-- <!-- <!-- <!-- l_md[[8]] <- glmer(cbind(n_nRef,100-n_nRef) ~ d_Lplot.z * MN + p.z + (d_Lplot.z * MN|SiteCode), family = "binomial",data=df_resultados, --> --> --> -->
<!-- <!-- <!-- <!--               control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> --> -->
<!-- <!-- <!-- <!-- #1 interação --> --> --> -->
<!-- <!-- <!-- <!-- l_md[[9]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z + (d_Lplot.z|SiteCode), family = "binomial",data=df_resultados, --> --> --> -->
<!-- <!-- <!-- <!--               control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> --> -->
<!-- <!-- <!-- <!-- l_md[[10]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * MN + (MN|SiteCode), family = "binomial",data=df_resultados, --> --> --> -->
<!-- <!-- <!-- <!--               control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> --> -->
<!-- <!-- <!-- <!-- l_md[[11]] <- glmer(cbind(n_nRef,100-n_nRef) ~ d_Lplot.z * MN + (d_Lplot.z * MN|SiteCode), family = "binomial",data=df_resultados, --> --> --> -->
<!-- <!-- <!-- <!--               control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> --> -->
<!-- <!-- <!-- <!-- #aditivo 3 --> --> --> -->
<!-- <!-- <!-- <!-- l_md[[12]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z + d_Lplot.z + MN + (MN+d_Lplot.z|SiteCode), family = "binomial",data=df_resultados, --> --> --> -->
<!-- <!-- <!-- <!--               control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> --> -->
<!-- <!-- <!-- <!-- #aditivo 2 --> --> --> -->
<!-- <!-- <!-- <!-- l_md[[13]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z + d_Lplot.z + (d_Lplot.z|SiteCode), family = "binomial",data=df_resultados, --> --> --> -->
<!-- <!-- <!-- <!--               control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> --> -->
<!-- <!-- <!-- <!-- l_md[[14]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z + MN + (MN|SiteCode), family = "binomial",data=df_resultados, --> --> --> -->
<!-- <!-- <!-- <!--               control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> --> -->
<!-- <!-- <!-- <!-- l_md[[15]] <- glmer(cbind(n_nRef,100-n_nRef) ~ d_Lplot.z + MN + (MN+d_Lplot.z|SiteCode), family = "binomial",data=df_resultados, --> --> --> -->
<!-- <!-- <!-- <!--               control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> --> -->
<!-- <!-- <!-- <!-- #aditivo 1 --> --> --> -->
<!-- <!-- <!-- <!-- l_md[[16]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z + (1|SiteCode), family = "binomial",data=df_resultados, --> --> --> -->
<!-- <!-- <!-- <!--               control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> --> -->
<!-- <!-- <!-- <!-- l_md[[17]] <- glmer(cbind(n_nRef,100-n_nRef) ~ d_Lplot.z + (d_Lplot.z|SiteCode), family = "binomial",data=df_resultados, --> --> --> -->
<!-- <!-- <!-- <!--               control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> --> -->
<!-- <!-- <!-- <!-- l_md[[18]] <- glmer(cbind(n_nRef,100-n_nRef) ~ MN + (MN|SiteCode), family = "binomial",data=df_resultados, --> --> --> -->
<!-- <!-- <!-- <!--               control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> --> -->
<!-- <!-- <!-- <!-- # nulo --> --> --> -->
<!-- <!-- <!-- <!-- l_md[[19]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 1 + (1|SiteCode), family = "binomial",data=df_resultados, --> --> --> -->
<!-- <!-- <!-- <!--               control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000))) --> --> --> -->
<!-- <!-- <!-- <!-- AICctab(l_md,weights=T) --> --> --> -->
<!-- <!-- <!-- <!-- ``` --> --> --> -->

<!-- <!-- <!-- <!-- O único modelo plausível com 0.909 do peso de evidência é o modelo cheio. --> --> --> -->

<!-- <!-- <!-- <!-- Como visto anteriormente este modelo não apresenta pressupostos que se aproximam do observado para os dados.    --> --> --> -->

<!-- <!-- <!-- <!-- __Tabela 1__ Modelo mais plausível para descrever o número de SADs não refutadas   --> --> --> -->

<!-- <!-- <!-- <!-- ```{r tabela do modelo plausivel} --> --> --> -->
<!-- <!-- <!-- <!-- tab_model(l_md[["p*d*MN"]]) --> --> --> -->
<!-- <!-- <!-- <!-- # summary(l_md[["p*d*MN"]]) --> --> --> -->
<!-- <!-- <!-- <!-- ``` --> --> --> -->

<!-- <!-- <!-- <!-- O R2 marginal é baixo (0.088) enquanto o R2 condicional é elevado (0.836). Segue avaliação visual da congruência com o observado comparando a probabilidade de se refutar uma predição neutra e a estimada pelo modelo.   --> --> --> -->

<!-- <!-- <!-- <!-- ```{r auditoria modelo mais plausivel md_nRef,include=FALSE,echo=TRUE} --> --> --> -->
<!-- <!-- <!-- <!-- df_plot <- df_resultados %>% select(SiteCode,p.z,d_Lplot.z,MN,n_nRef) %>% mutate(p_nRef = n_nRef/100) --> --> --> -->
<!-- <!-- <!-- <!-- df_plot$predict <- predict(l_md[["p*d*MN"]],type="response") --> --> --> -->
<!-- <!-- <!-- <!-- # grafico --> --> --> -->

<!-- <!-- <!-- <!-- sites <- levels(df_plot$SiteCode) --> --> --> -->
<!-- <!-- <!-- <!-- # l_p <- vector("list",length = 103) --> --> --> -->
<!-- <!-- <!-- <!-- # par(mfrow=c(21,5)) --> --> --> -->
<!-- <!-- <!-- <!-- for(i in 1:length(sites)){ --> --> --> -->
<!-- <!-- <!-- <!--   df_ <- filter(df_plot,SiteCode == sites[i]) --> --> --> -->
<!-- <!-- <!-- <!--   # l_p[[i]] <- ggplot(df_,aes(x=p_nRef,y=predict,colour=MN,shape=MN)) +  --> --> --> -->
<!-- <!-- <!-- <!--   #   geom_point() + --> --> --> -->
<!-- <!-- <!-- <!--   #   geom_abline(slope=1,intercept = 0,color="red") + --> --> --> -->
<!-- <!-- <!-- <!--   #   scale_color_manual(values=c("#000000", "#0000FF")) + --> --> --> -->
<!-- <!-- <!-- <!--   #   labs(title = sites[i]) --> --> --> -->
<!-- <!-- <!-- <!--   plot(df_$predict ~ df_$p_nRef, --> --> --> -->
<!-- <!-- <!-- <!--        xlim=c(0,1),ylim=c(0,1),col=df_$MN, --> --> --> -->
<!-- <!-- <!-- <!--        main=sites[i], xlab="Prob. Obs", ylab="Prob. Est.") --> --> --> -->
<!-- <!-- <!-- <!--   abline(a=0,b=1,color="red",add=TRUE) --> --> --> -->
<!-- <!-- <!-- <!-- } --> --> --> -->
<!-- <!-- <!-- <!-- # do.call("grid.arrange",c(l_p,ncol=10)) --> --> --> -->
<!-- <!-- <!-- <!-- ``` --> --> --> -->

<!-- <!-- <!-- <!-- __Figura 1.5__ Probabilidade de não refutar uma SAD neutra observada ~ predita pelo modelo mais plausível. Pontos pretos = MNEE, pontos vermelhos = MNEI --> --> --> -->

<!-- <!-- <!-- <!-- Observamos que para alguns sítios os valores se aproximam de uma relação linear, como esperado pelo modelo, contudo para outros valores observa-se tendência não lineares onde alguns valores são bem ajustados enquanto outros aumentam e diminuiem. Isso pode indicar que seja mais adequado considerar um modelo que possibilite maior flexibilidade para estimar a tendência global dos dados.  --> --> --> -->

<!-- <!-- <!-- <!-- Em resumo:   --> --> --> -->
<!-- <!-- <!-- <!-- i) O modelo mais plausível apresenta R2_marginal > 80%, porém pouco é explicado pela estrutura fixa do modelo (R2_condicional < 10%);         --> --> --> -->
<!-- <!-- <!-- <!-- ii) Os modelos neutros apresentam variância distinta: enquanto MNEE varia em valores próximos de 98 SADs não refutadas para a maior parte dos sítios, MNEI varia em [0;100].   --> --> --> -->
<!-- <!-- <!-- <!-- iii) O pressuposto de linearidade pode não ser suficiente para estimar a tendência global para todos os sítios de amostragem, uma vez que outras tendências são observadas no gráfico de estimado X observado (figura 1.5).   --> --> --> -->

<!-- <!-- <!-- <!-- ### Infêrência --> --> --> -->

<!-- <!-- <!-- <!-- Uma avaliação direta da predição de que MNEE pode apresentar melhor congruência para paisagens com proporções intermediárias de cobertura vegetal é a de comparar a inclinação e intercepto do efeito do aumento da dispersão entre os modelos neutros por sítio e então plotar as estimativas pela proporção de cobertura vegetal.  --> --> --> -->

<!-- <!-- <!-- <!-- __Esquema da Figura__ --> --> --> -->

<!-- <!-- <!-- <!-- i) obter os coeficientes para cada sítio pela função coef();   --> --> --> -->
<!-- <!-- <!-- <!-- ii) multiplicar todos os coeficientes que apresentam alguma relação com a preditora "p.z" pelo correspondete valor de p.z para aquele sítio;   --> --> --> -->
<!-- <!-- <!-- <!-- iii) MNEE é o nível padrão e MNEI é o contraste.   --> --> --> -->
<!-- <!-- <!-- <!-- iv) Assim, por SiteCode:    --> --> --> -->
<!-- <!-- <!-- <!--   a) alfa_EE = intercept + p.z   --> --> --> -->
<!-- <!-- <!-- <!--   b) beta_EE = d_Lplot.z + p.z:d_Lplot.z   --> --> --> -->
<!-- <!-- <!-- <!--   c) alfa_EI = alfa_EE + MNEI + p:MNEI   --> --> --> -->
<!-- <!-- <!-- <!--   d) beta_EI = beta_EE + d_Lplot:MNEI + p:d_Lplot:MNEI   --> --> --> -->


<!-- <!-- <!-- <!-- ```{r inferencia n_nRef, warning=FALSE,message=FALSE,include=FALSE} --> --> --> -->
<!-- <!-- <!-- <!-- # dados brutos --> --> --> -->
<!-- <!-- <!-- <!-- df_coef.Site <- coef(l_md[["p*d*MN"]])$SiteCode --> --> --> -->
<!-- <!-- <!-- <!-- ## arrumando os nomes --> --> --> -->
<!-- <!-- <!-- <!-- df_coef.Site$SiteCode <- row.names(coef(l_md[["p*d*MN"]])$SiteCode)  --> --> --> -->
<!-- <!-- <!-- <!-- row.names(df_coef.Site) <- NULL --> --> --> -->
<!-- <!-- <!-- <!-- names(df_coef.Site) <- c("intercept","p_coef","d_Lplot_coef","MNEI","p__d_Lplot_coef","p__MNEI","d_Lplot__MNEI","p__d_Lplot__MNEI","SiteCode") --> --> --> -->
<!-- <!-- <!-- <!-- # multiplicao pelo respectivo valor de p.z --> --> --> -->
<!-- <!-- <!-- <!-- df_ <- df_coef.Site[,c(2,5,6,8,9)] %>% inner_join(x=., --> --> --> -->
<!-- <!-- <!-- <!--                             y=distinct(select(df_resultados,SiteCode,p.z,p)), --> --> --> -->
<!-- <!-- <!-- <!--                             by="SiteCode") %>%  --> --> --> -->
<!-- <!-- <!-- <!--   adply(.,1,.fun=function(X) data.frame(coef_p = X$p.z * X$p_coef, --> --> --> -->
<!-- <!-- <!-- <!--                                         coef_p__d_Lplot = X$p.z * X$p__d_Lplot_coef, --> --> --> -->
<!-- <!-- <!-- <!--                                         coef_p__MNEI = X$p.z * X$p__MNEI, --> --> --> -->
<!-- <!-- <!-- <!--                                         coef_p__d_Lplot__MNEI = X$p.z * X$p__d_Lplot__MNEI --> --> --> -->
<!-- <!-- <!-- <!--                                         ) --> --> --> -->
<!-- <!-- <!-- <!--         ) --> --> --> -->
<!-- <!-- <!-- <!-- # merge e escolha das colunas que já foram multiplicados pelos valores de p.z --> --> --> -->
<!-- <!-- <!-- <!-- df_coef.Site %<>% inner_join(x=., --> --> --> -->
<!-- <!-- <!-- <!--                             y=df_[,5:11], --> --> --> -->
<!-- <!-- <!-- <!--                             by="SiteCode") %>%  --> --> --> -->
<!-- <!-- <!-- <!--   select(SiteCode, p.z, p, intercept, coef_p, d_Lplot_coef, MNEI, coef_p__d_Lplot, coef_p__MNEI, d_Lplot__MNEI,coef_p__d_Lplot__MNEI) --> --> --> -->
<!-- <!-- <!-- <!-- # grafico --> --> --> -->
<!-- <!-- <!-- <!-- ## dados --> --> --> -->
<!-- <!-- <!-- <!-- df_plot <- df_coef.Site %>%  --> --> --> -->
<!-- <!-- <!-- <!--   mutate(alfa_EE = intercept + coef_p,  --> --> --> -->
<!-- <!-- <!-- <!--          beta_EE = d_Lplot_coef + coef_p__d_Lplot, --> --> --> -->
<!-- <!-- <!-- <!--          alfa_EI = alfa_EE + MNEI + coef_p__MNEI,  --> --> --> -->
<!-- <!-- <!-- <!--          beta_EI = beta_EE + d_Lplot__MNEI + coef_p__d_Lplot__MNEI) %>% --> --> --> -->
<!-- <!-- <!-- <!--   select(SiteCode, p.z, p, alfa_EE, alfa_EI, beta_EE, beta_EI) %>%  --> --> --> -->
<!-- <!-- <!-- <!--   gather(.,key="coef","logito_P.nRef",alfa_EE,alfa_EI,beta_EE,beta_EI) --> --> --> -->
<!-- <!-- <!-- <!-- # filter(df_plot,coef %in% c("beta_EE","beta_EI")) %>% summary --> --> --> -->
<!-- <!-- <!-- <!-- ## grafico --> --> --> -->
<!-- <!-- <!-- <!-- l_p <- vector("list",2) --> --> --> -->
<!-- <!-- <!-- <!-- l_p[[1]] <- ggplot(filter(df_plot,coef %in% c("alfa_EE","alfa_EI")), aes(x=p,y=logito_P.nRef,colour=coef,shape=coef,group=SiteCode)) + --> --> --> -->
<!-- <!-- <!-- <!--   geom_line(color="#A9A9A9") + --> --> --> -->
<!-- <!-- <!-- <!--   geom_point() + --> --> --> -->
<!-- <!-- <!-- <!--   scale_color_manual(values=c("#000000", "#0000FF")) + --> --> --> -->
<!-- <!-- <!-- <!--   xlim(0, 1) + ylim(-23.5, 8.5) +  --> --> --> -->
<!-- <!-- <!-- <!--   geom_hline(yintercept = 0,color="red") --> --> --> -->
<!-- <!-- <!-- <!-- l_p[[2]] <- ggplot(filter(df_plot,coef %in% c("beta_EE","beta_EI")), aes(x=p,y=logito_P.nRef,colour=coef,shape=coef,group=SiteCode)) + --> --> --> -->
<!-- <!-- <!-- <!--   geom_line(color="#A9A9A9") + --> --> --> -->
<!-- <!-- <!-- <!--   geom_point() + --> --> --> -->
<!-- <!-- <!-- <!--   scale_color_manual(values=c("#000000", "#0000FF")) + --> --> --> -->
<!-- <!-- <!-- <!--   xlim(0, 1) + ylim(-22.65, 5.8) +  --> --> --> -->
<!-- <!-- <!-- <!--   geom_hline(yintercept = 0,color="red") --> --> --> -->
<!-- <!-- <!-- <!-- do.call("grid.arrange",c(l_p,ncol=1)) --> --> --> -->
<!-- <!-- <!-- <!-- ``` --> --> --> -->

<!-- <!-- <!-- <!-- __Figura 1.6__ Coeficientes estimados por Sítio de Amostragem, logito(Probabilidade(não refutar uma SAD neutra) no eixo y e proporção de cobertura vegetal (p) no eixo x. Para sítios possibilitamos um intercepto e uma inclinação em d/Lplot por modelo neutro, no primeiro painel temos os interceptos e no segundo as inclinações. --> --> --> -->


<!-- <!-- <!-- <!-- Essa figura não me auxilia na interpretação da predição. Gráficos de 3 dimensões (logito(Pr(nRef)) X p X d/L_plot) devem ser mais adequados para interpretar os resultados. Como este modelo não apresenta boa adequação ao conjunto de dados (pressuposto de binomial e padrões não lineares) vou seguir para um modelo que possibilita maior flexibilidade.   --> --> --> -->
