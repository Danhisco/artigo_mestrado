---
title: "Apêndice 2: Descrição Estatística"
author: "Mori, Danilo"
date: "31/10/2019"
output: 
  html_document:
    toc: true
    toc_depth: 5
editor_options: 
  chunk_output_type: inline
---

<style>
body {
text-align: justify}
</style>


```{r setup, include=TRUE,echo=FALSE}
knitr::opts_chunk$set(echo = FALSE, tidy = FALSE, include = TRUE, warning = FALSE,cache = TRUE,message=FALSE,eval=TRUE)
# setwd("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/")
knitr::opts_knit$set(root.dir = "~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/")
```

```{r pacotes,eval=TRUE,echo=TRUE}
library(parallel)
library(doMC)
library(DHARMa)
library(broom.mixed)
library(gratia)
library(MuMIn)
library(mgcv)
library(bbmle)
library(lme4)
library(merTools)
library(magrittr)
library(gridExtra)
library(ggplot2); theme_set(theme_classic())
library(tidymv)
library(purrr)
library(plyr)
library(dplyr)
```

```{r dados,message=FALSE}
### dados ###
# leitura
df_resultados <- read.csv(file="/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/resultados/df_resultados.csv",
                            header = TRUE,as.is=FALSE)[,1:13]
# padronização
level_k <- as.character(unique(sort(as.numeric(df_resultados$k),decreasing = TRUE)))
df_resultados$k <- factor(df_resultados$k,levels = level_k)
levels(df_resultados$k)[19] <- "0.1"
# z score
f_z <- function(x){
  m <- base::mean(x,na.rm=FALSE)
  sd <- sd(x,na.rm=FALSE)
  output <- (x-m)/sd
  return(output)
} 
# names(df_resultados)
# str(df_resultados)
df_resultados %<>% mutate(diffS_gamma = diffS_mean + min(diffS_mean)*(-1) + 0.01,
                          modulo_diffS = abs(diffS_mean),
                          log_Sobs=log(S_obs))

df_resultados.z <- as.data.frame(apply(df_resultados[,c("p","Ntotal","log_Sobs","k_1","d_Lplot","d","modulo_diffS")],2,f_z))
names(df_resultados.z) <- sapply(names(df_resultados.z), function(x) paste0(x,".z"))
df_resultados %<>% cbind(.,df_resultados.z) %>% 
  select(-k_1,-k_1.z)
```


# 1 - Variables

__table 1:__
Variáveis utilizadas na descrição estatística

```{r 1 tabela de variaveis,echo=FALSE, eval=TRUE}
df_variaveis <- read.csv("/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/tabela_variaveis.csv",
                         header = TRUE,as.is = FALSE) %>% 
  filter(code != "1-k")
knitr::kable(df_variaveis,caption = "Variables") %>%
  kableExtra::kable_styling()
```

  
    
__Figure 1__ Possible Predictor Variables  
  
    
```{r figura 11 possiveis variaveis preditoras,echo=FALSE,include=TRUE,fig.height=7,fig.align='center',fig.width=7}
l_p <- list()
l_p[[1]] <- ggplot(df_resultados,aes(x=k,y=d)) +
  geom_jitter(alpha=0.3) +
  geom_boxplot(alpha=0.6) +
  coord_flip()
l_p[[2]] <- ggplot(df_resultados,aes(x=k,y=d_Lplot)) +
  geom_jitter(alpha=0.3) +
  geom_boxplot(alpha=0.6) +
  coord_flip()
l_p[[3]] <- ggplot(filter(df_resultados,MN=="EE"&k=="0.99"), aes(x=p,y=S_obs)) +
  geom_point(alpha=0.3)
l_p[[4]] <- ggplot(filter(df_resultados,MN=="EE"&k=="0.99"),aes(x="",y=p)) + geom_jitter(alpha=0.3) + geom_boxplot(alpha=0.6) + labs(x="")
l_p[[5]] <- ggplot(filter(df_resultados,MN=="EE"&k=="0.99"),aes(x="",y=S_obs)) + geom_jitter(alpha=0.3) + geom_boxplot(alpha=0.6) + labs(x="")
layout_mat <- rbind(c(1,1,1,2,2,2),
                    c(3,3,3,4,5,NA))
# do.call("grid.arrange",c(l_p[1:3],layout_matrix=1,top="Possible Predictor Variables"))
grid.arrange(l_p[[1]],l_p[[2]],l_p[[3]],l_p[[4]],l_p[[5]],top="Possible Predictor Variables",layout_matrix=layout_mat)
```


  
# 2 - Number of unrefuted SADs
  
    
__Figura 2.1__ número de SADs não refutadas ~ p *  k * MN. A linha azul é uma estimativa baseada em 'loess'.   
    
```{r n_nRef padroes gerais fig21}
l_p <- vector("list",2)
l_p[[1]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[1:10]),
                   aes(x=p,y=n_nRef)) + 
  geom_point() + 
  geom_smooth(method="loess") +
  facet_grid(k~MN)
l_p[[2]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[11:20]),
                   aes(x=p,y=n_nRef)) + 
  geom_point() + 
  geom_smooth(method="loess") +
  facet_grid(k~MN) 
do.call("grid.arrange",c(l_p,ncol=2))
```
    
  
  
  
__Figura 2.2__ número de SADs não refutadas ~ (d * MN|Site ~ p). Site está ordenado pelo valor de p.  
  
  
```{r n_nRef padroes gerais fig22 ,fig.width=8, fig.height=27}
df_plot <- df_resultados %>% mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
ggplot(df_plot,aes(x=d.z,y=n_nRef,group=MN)) +
  geom_point(aes(color=MN),alpha=0.3) +
  # geom_line(aes(y=Pr_nRef,color=MN),alpha=0.3) +
  scale_color_manual(values=c("#FF0000", "#000000")) +
  theme_classic() + theme(legend.position="top") + labs(x="d(metros)",y="nRef(count)") +
  facet_wrap(~title,ncol=6)
```


  
    
## 2.1 GLMM binomial

### Modelo cheio 1: 


__linear term__  
  
i) ~ (p + p^2) * (d + d^2) * MN; if : var_dispersao = contiguous  
ii) ~ ( p + p^2) * k * MN;   if : var_dispersao = category    
  
__random term__
  
a) 1|SiteCode  
b) MN|SiteCode  
c)  (var_dispersao + var_dispersao^2)*MN|SiteCode, if : var = dispersao : contiguous



```{r glmm n_nRef comparacao modelos cheios, echo=TRUE,eval=FALSE,cache=TRUE,message=FALSE,warning=FALSE}
# dados
df_md <- df_resultados %>% 
  select(n_nRef,p,SiteCode,MN,p.z,k,d.z,d_Lplot.z)
df_md[,6:8] <- apply(df_md[,6:8],2,as.character)
df_md %<>% 
  gather(key = var_dispersao, value = value_dispersao, k:d_Lplot.z) 
# funcao ajuste dos modelos
f_md <- function(dados){
  var_dispersao <- unique(dados$var_dispersao)
  if(var_dispersao == "k"){
    l_md <- vector("list",2)
    names(l_md) <- c(paste0(var_dispersao," 1|Site"),
                     paste0(var_dispersao," MN|Site"))
    dados$value_dispersao <- factor(dados$value_dispersao,levels = unique(dados$value_dispersao)[20:1])
    l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN +
                         (1|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN +
                         (MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
  }else{
    dados$value_dispersao <- as.numeric(dados$value_dispersao)
    l_md <- vector("list",3)
    names(l_md) <- c(paste0(var_dispersao," 1|Site"),
                     paste0(var_dispersao," MN|Site"),
                     paste0(var_dispersao," (",var_dispersao,"+",var_dispersao,"^2)*MN|Site"))
    l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * (value_dispersao + I(value_dispersao^2)) * MN + 
                         (1|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * (value_dispersao + I(value_dispersao^2)) * MN + 
                         (MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * (value_dispersao + I(value_dispersao^2)) * MN + 
                         ( (value_dispersao + I(value_dispersao^2) ) * MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    
  }
  return(l_md)
}
registerDoMC(3)
l_nRef__modeloCheio <- dlply(df_md,.(var_dispersao),f_md,.parallel = TRUE)
names(l_nRef__modeloCheio) <- NULL
l_nRef__modeloCheio <- do.call(c,l_nRef__modeloCheio)
#
f_warning <- function(glmm_object){
  # glmm_object <- l_nRef__modeloCheio[[4]]
  v_message <- glmm_object@optinfo$conv$lme4$messages %>% 
    as.character()
  if(length(v_message)==0){v_message <- "OK"}
  if(length(v_message)>1){v_message <- v_message[1] }
  return(v_message)
}
df_auditoria.md <- ldply(l_nRef__modeloCheio,f_warning,.id="glmer") %>% 
  rename(warning_message = V1)
```


```{r l_md_nRef.GLMM, eval=FALSE,echo=FALSE}
save(l_nRef__modeloCheio,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_GLMM.Rdata")
```
  
__Table 2.1__ Modelos Cheios estimados e avisos de convergência  
  
```{r data frame com os avisos de ajustes,eval=TRUE,echo=FALSE}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_GLMM.Rdata")
# avaliação e melhora do ajuste dos modelos
## warnings
f_warning <- function(glmm_object){
  # glmm_object <- l_nRef__modeloCheio[[4]]
  v_message <- glmm_object@optinfo$conv$lme4$messages %>% 
    as.character()
  if(length(v_message)==0){v_message <- "OK"}
  if(length(v_message)>1){v_message <- v_message[1] }
  return(v_message)
}
df_auditoria.md <- ldply(l_nRef__modeloCheio,f_warning,.id="glmer") %>% 
  rename(warning_message = V1)
v_glmerUpdate <- df_auditoria.md[df_auditoria.md$warning_message != "OK",]$glmer %>% 
  as.character()
knitr::kable(df_auditoria.md) %>% 
  kableExtra::kable_styling()
```
  
    
#### allFit  
  
  
```{r rotina de avaliacao individual dos modelos cheios 1,echo=TRUE,eval=FALSE}
i <- 1
names(l_nRef__modeloCheio[v_glmerUpdate])[i]
#
## update1:
md_allFit <- allFit(l_nRef__modeloCheio[v_glmerUpdate][[i]],maxfun = 1e5, parallel = 'multicore', ncpus = 3)
```
  
  
  
__1) d_Lplot 1|Site__  

7 optimizer(s) failed

__2) d_Lplot MN|Site__  
  
7 optimizer(s) failed
      
__3) d 1|Site__  

7 optimizer(s) failed
         
__4) d MN|Site__      
  
7 optimizer(s) failed    

  
### Modelo cheio 2: 


```{r glmm n_nRef comparacao modelos cheios2, echo=TRUE,eval=FALSE,cache=TRUE,message=FALSE,warning=FALSE}
# dados
df_md <- df_resultados %>% 
  select(n_nRef,p,SiteCode,MN,p.z,k,d.z,d_Lplot.z)
df_md[,6:8] <- apply(df_md[,6:8],2,as.character)
df_md %<>% 
  gather(key = var_dispersao, value = value_dispersao, k:d_Lplot.z) 
# funcao ajuste dos modelos
f_md <- function(dados){
  var_dispersao <- unique(dados$var_dispersao)
  if(var_dispersao == "k"){
    l_md <- vector("list",2)
    names(l_md) <- c(paste0(var_dispersao," 1|Site"),
                     paste0(var_dispersao," MN|Site"))
    dados$value_dispersao <- factor(dados$value_dispersao,levels = unique(dados$value_dispersao)[20:1])
    l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN +
                         (1|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN +
                         (MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
  }else{
    dados$value_dispersao <- as.numeric(dados$value_dispersao)
    l_md <- vector("list",4)
    names(l_md) <- c(paste0(var_dispersao," 1|Site"),
                     paste0(var_dispersao," MN|Site"),
                     paste0(var_dispersao," ",var_dispersao,"*MN|Site"),
                     paste0(var_dispersao,"^2 (",var_dispersao,"+",var_dispersao,"^2)*MN|Site"))
    l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN + 
                         (1|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN + 
                         (MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * value_dispersao * MN + 
                         (value_dispersao * MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    l_md[[4]] <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                         (p.z + I(p.z^2)) * (value_dispersao + I(value_dispersao^2)) * MN + 
                         ( (value_dispersao + I(value_dispersao^2) ) * MN|SiteCode),
                       family = "binomial",data=dados,
                       control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)))
    
  }
  return(l_md)
}
registerDoMC(3)
l_nRef__modeloCheio2 <- dlply(df_md,.(var_dispersao),f_md,.parallel = TRUE)
names(l_nRef__modeloCheio2) <- NULL
l_nRef__modeloCheio2 <- do.call(c,l_nRef__modeloCheio2)
#
f_warning <- function(glmm_object){
  v_message <- glmm_object@optinfo$conv$lme4$messages %>% 
    as.character()
  if(length(v_message)==0){v_message <- "OK"}
  if(length(v_message)>1){v_message <- v_message[1] }
  return(v_message)
}
df_auditoria.md <- ldply(l_nRef__modeloCheio2,f_warning,.id="glmer") %>% 
  rename(warning_message = V1)
```


```{r l_nRef__modeloCheio2,eval=FALSE,echo=FALSE}
save(l_nRef__modeloCheio2,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_GLMM2.Rdata")
```
  
    
__Table 2.2__ Modelos Cheios estimados e avisos de convergência    
    
      
```{r warningns l_nRef__modeloCheio2,eval=TRUE,echo=FALSE}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_GLMM2.Rdata")
# avaliação e melhora do ajuste dos modelos
## warnings
f_warning <- function(glmm_object){
  v_message <- glmm_object@optinfo$conv$lme4$messages %>% 
    as.character()
  if(length(v_message)==0){v_message <- "OK"}
  if(length(v_message)>1){v_message <- v_message[1] }
  return(v_message)
}
df_auditoria.md <- ldply(l_nRef__modeloCheio2,f_warning,.id="glmer") %>% 
  rename(warning_message = V1)
v_glmerUpdate <- df_auditoria.md[df_auditoria.md$warning_message != "OK",]$glmer %>% 
  as.character()
knitr::kable(df_auditoria.md) %>% 
  kableExtra::kable_styling()
```
  
#### allFit  
  
```{r melhoria de modelo cheio 2,eval=FALSE}
i <- 2
names(l_nRef__modeloCheio2[v_glmerUpdate])[i]
md_allFit <- allFit(l_nRef__modeloCheio2[v_glmerUpdate][[i]],maxfun = 1e5, parallel = 'multicore', ncpus = 3)
```
  
  
__d_Lplot.z 1|Site__    
7 optimizer(s) failed


__d.z 1|Site__   
7 optimizer(s) failed


### Comparação de Modelos Cheios:

```{r l_nRef_ModeloCheioFinal,eval=FALSE,echo=FALSE}
v_glmerOK <- df_auditoria.md[df_auditoria.md$warning_message == "OK",]$glmer %>% 
  as.character()
l_nRef_ModeloCheioFinal <- l_nRef__modeloCheio2[v_glmerOK]
save(l_nRef_ModeloCheioFinal,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_ModeloCheioFinal.Rdata")
```

```{r nRef modelo cheio final tabela de aIC,results="hide"}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_ModeloCheioFinal.Rdata")
df_tableGLMM <- print(AICctab(l_nRef_ModeloCheioFinal,weights=TRUE)) %>% 
  as.data.frame()
df_tableGLMM$GLMM <- row.names(df_tableGLMM) %>% gsub(".z","",.)
df_tableGLMM$weight <- as.character(df_tableGLMM$weight)
df_tableGLMM$dAICc <- as.numeric(as.character(df_tableGLMM$dAICc))
rownames(df_tableGLMM) <- NULL
df_tableGLMM <- df_tableGLMM[,c(4,1:3)]
```

__Tabela 2.3__ Comparação baseada em AICc dos modelos cheios  
  
```{r tabela 23}
knitr::kable(df_tableGLMM) %>% 
  kableExtra::kable_styling()
```
  
  
__Tabela 2.4__ Coeficiente de Determinação Condicional e Marginal

```{r tabela 24 coeficiente de determinacao condicional e marginal,cache=TRUE}
md_nRef <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                   (p.z + I(p.z^2)) * (d.z + I(d.z^2)) * MN + 
                   ( (d.z + I(d.z^2) ) * MN|SiteCode),
                 family = "binomial",data=df_resultados,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e9)),
                 na.action = "na.fail")
r.squaredGLMM(md_nRef)
```




#### Diagnostico do modelo cheio mais plausível 
  
  
__Figura 2.3__ Resíduos Quantílicos do modelo cheio plausível  
  
    
```{r auditoria mais plausivel md_n.ref1, message=FALSE,eval=TRUE,echo=FALSE}
p_plot <- simulateResiduals(md_nRef,n=1000)
plot(p_plot)
```
  
  
    
__Figura 2.4__ Quantile-quantile plot random effects.    
  
    
```{r figura 24 qqplots random effects}
df_ranef <- ranef(md_nRef)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  ggplot(aes(sample=parameter_value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") + theme_classic() +
  facet_wrap(~parameter_class,scales="free",ncol=3)
```
      
  
  
  
__Figura 2.5__ Predito e observado pelo modelo. Em vermelho linha y=x; em azul um modelo linear por sítio de amostragem.      
    
      
```{r fiigura 25,fig.height=4}
# dados
df_md <- md_nRef@frame
df_md$nRef_observado <- df_md$`cbind(n_nRef, 100 - n_nRef)`[,1]
df_md$nRef_predito <- predict(md_nRef,type="response") * 100
# graficos
ggplot(df_md,aes(x=nRef_observado,y=nRef_predito)) +
  geom_smooth(method = "lm",aes(group=SiteCode),se=FALSE,alpha=0.3) +
  geom_abline(slope = 1,intercept = 0,col="red",alpha=0.8,size=2) +
  geom_point(alpha=0.3) +
  facet_wrap(~MN,ncol=2,scales="free") + theme_classic() + xlim(0,100) + ylim(0,100) 
```
  
  
  
  
__Figura 2.6__ Predito e observado para modelo cheio    
  
```{r avaliacao por site fig 26, fig.width=8, fig.height=30,message=FALSE,eval=TRUE,echo=FALSE}
# Dados
## filtrados para o modelo
df_plot <- df_resultados
df_plot$Pr_nRef <- predict(md_nRef,type="response")*100
# df_plot %>% str
# Graficos
df_plot %<>% mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
ggplot(df_plot,aes(x=d.z,y=n_nRef,group=MN)) +
  geom_point(aes(color=MN),alpha=0.3) +
  geom_line(aes(y=Pr_nRef,color=MN),alpha=0.3) +
  scale_color_manual(values=c("#FF0000", "#000000")) +
  theme_classic() + theme(legend.position="top") + labs(x="d(metros)",y="nRef(count)") +
  facet_wrap(~title,ncol=6)
```


      
  
  
## 2.2 Subset=MNEE

### Estudo GAMM: smoother type

i) Antes de comparar os modelos cheios preciso avaliar smoother type mais para utilizar na GAMM;
ii) Pelo observado nos dados (figuras 2.1 e 2.2) vou comparar dois smoother type: "tp" e "cr"
iii) Para isso vou ajuster um smoother para d por Sítio de amostragem com um mesmo parâmetro de penalização, dessa maneira eu considero a variação por sítio de amostragem na variável d sem um elevado custo computacional.  


```{r nRef MNEE estudo GAMM smoother type,echo=TRUE,eval=FALSE}
# dados
df_md <- df_resultados %>% filter(MN=="EE") %>% distinct()
df_md <- rbind(mutate(df_md,model_class = "cr"),
               mutate(df_md,model_class = "tp"))
df_md$model_class <- factor(df_md$model_class)
# função
f_md <- function(dados){
  model_class <- unique(dados$model_class)
  if(model_class == "cr"){
    md_ <- gam(cbind(n_nRef,100-n_nRef) ~ 
                 s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                 s(d.z,SiteCode,bs="fs",xt=list(bs="cr"), m=1),
                data = dados, family = "binomial")
    
  }else{
    md_ <- gam(cbind(n_nRef,100-n_nRef) ~ 
                 s(p.z,bs="tp") + s(d.z,bs="tp") + ti(p.z,d.z,bs=c("tp","tp")) +
                 s(d.z,SiteCode,bs="fs",xt=list(bs="tp"), m=1),
                data = dados, family = "binomial")
    
  }
  return(md_)
}
registerDoMC(2)
l_nRefEE_estudoGAMM <- dlply(df_md,"model_class",f_md,.parallel = TRUE)
```


```{r l_nRefEE_estudoGAMM, echo=FALSE, eval=FALSE}
save(l_nRefEE_estudoGAMM,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEE_estudoGAMM.Rdata")
```

```{r AICctab ,eval=FALSE,echo=FALSE}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEE_estudoGAMM.Rdata")
AICctab(l_nRefEE_estudoGAMM,weights=TRUE)
```



### Comparação Modelos Cheios

```{r comparacao modelos cheios nRefEE,echo=TRUE,eval=TRUE}
# dados
df_md <- df_resultados %>% filter(MN=="EE") %>% 
  distinct() %>% 
  mutate(rep = 1)
df_md <- left_join(x=data.frame(rep=1,
                                md_class=c("glmm d+d^2|Site",
                                           "glmm d|Site",
                                           "glmm 1|Site",
                                           "gamm d|Site for each",
                                           "gamm d|Site common",
                                           "gamm 1|Site")),
                   y=df_md,
                   by="rep")
# função de ajuste
f_md <- function(dados){
  md_class <- unique(dados$md_class)
  if(md_class == "glmm d+d^2|Site"){
    md_ <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                      (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                      (d.z + I(d.z^2)|SiteCode),
                 family = "binomial",data=dados,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)),
                 na.action = "na.fail")
  }else if(md_class == "glmm d|Site"){
    md_ <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                      (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                      (d.z|SiteCode),
                 family = "binomial",data=dados,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)),
                 na.action = "na.fail")
  }else if(md_class == "glmm 1|Site"){
    md_ <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                      (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                      (1|SiteCode),
                 family = "binomial",data=dados,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)),
                 na.action = "na.fail")
  }else if(md_class == "gamm d|Site for each"){
    md_ <- gam(cbind(n_nRef,100-n_nRef) ~ 
                 s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                 s(SiteCode,bs="re") + s(d.z,by=SiteCode,bs="cr",m=1),
                data = dados, family = "binomial")
  }else if(md_class == "gamm d|Site common"){
    md_ <- gam(cbind(n_nRef,100-n_nRef) ~ 
                 s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                 s(d.z,SiteCode,bs="fs",xt=list(bs="cr"), m=1),
                data = dados, family = "binomial")
  }else{
    md_ <- gam(cbind(n_nRef,100-n_nRef) ~ 
                 s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                 s(SiteCode,bs="re"),
                data = dados, family = "binomial")
  }
  return(md_)
}
```

```{r dlply f md nRef EE, eval=FALSE,echo=TRUE}
registerDoMC(3)
l_nRefEE_mdCheio <- dlply(df_md,"md_class",f_md,.parallel = TRUE)
```


```{r save l_nRefEE_mdCheio, eval=FALSE}
save(l_nRefEE_mdCheio,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEE_mdCheio.Rdata")
```

```{r AICctab l_nRefEE_mdCheio,echo=FALSE,eval=TRUE}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEE_mdCheio.Rdata")
AICctab(l_nRefEE_mdCheio,weights=TRUE)
md_nRefEE1 <- l_nRefEE_mdCheio[["gamm d|Site for each"]]
```


#### Diagnostico modelo cheio

__Figura 2.2.1__ gam.check(md_nRefEE1)


```{r fig 221,eval=TRUE,echo=FALSE}
par(mfrow=c(2,2))
gam.check(md_nRefEE1)
```
  
  
__tabela 2.2.1__ Summary
  
```{r tabela 221,eval=TRUE,echo=FALSE}
summary(md_nRefEE1)
```




__Figura 2.2.2__ Observado e predito pelo modelo cheio mais plausível  

```{r fig 222 predito e observado por sitio md_nRefEE, echo=FALSE,eval=TRUE, fig.width=8, fig.height=30,message=FALSE}
# dados
df_plot <- df_resultados %>% filter(MN=="EE") %>% distinct()
df_plot$nRef_predito <- predict.gam(md_nRefEE1,se.fit = TRUE,type="response")$fit*100
df_plot$nRef_se <- predict.gam(md_nRefEE1,se.fit = TRUE,type="response")$se*100
df_plot %<>%
  mutate(title = paste0(SiteCode, " p=",round(p,digits = 3)),
         yLower=nRef_predito-nRef_se,
         yUpper=nRef_predito+nRef_se) %>% 
  arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
# plot
ggplot(df_plot,aes(x=d.z,y=n_nRef)) +
  geom_ribbon(aes(ymin = yLower, ymax = yUpper),alpha=0.3,fill="blue") +
  geom_point(alpha=0.3) +
  geom_line(aes(y=nRef_predito),alpha=0.5,col="red") +
  theme_classic() + labs(x="d(metros)",y="nRef(count)") + labs(title = "subset : MN==EE")+
  facet_wrap(~title,ncol=6)
```



__Figura 2.2.3__ Diagnostico: avaliação do ajuste pelas preditoras lineares

```{r fig 223,echo=FALSE,eval=TRUE,fig.height=5}
#
df_plot <- augment(md_nRefEE1) 
df_plot1 <- df_plot %>% 
  select(p.z,d.z,.fitted,.resid,.hat,.cooksd) %>% 
  gather(key = preditora_class, value = preditora_value,p.z:d.z) %>% 
  gather(key = var_diagnostico, value = var_value,.fitted:.cooksd)
df_plot1$var_diagnostico <- factor(df_plot1$var_diagnostico,levels = unique(df_plot1$var_diagnostico))
#
f_p <- function(dados){
  title_ <- unique(dados$var_diagnostico) %>% 
    as.character()
  p <- ggplot(dados,aes(x=preditora_value,y=var_value)) + 
  geom_point(alpha=0.3) + 
  geom_smooth(method = "loess",se=TRUE) + 
  facet_wrap(~preditora_class,ncol=2,scales="free") +
  labs(title = title_,x="",y="")
}
l_p <- dlply(df_plot1,.(var_diagnostico),f_p)
# p_ <- ggplot(df_plot,aes(y=var_value)) + 
#   # geom_jitter(alpha=0.3) +
#   geom_boxplot() + 
#   facet_wrap(~var_diagnostico,ncol=4,scales="free")
do.call("grid.arrange",c(l_p,ncol=2))
#
# ggplot(df_plot,aes(x=p.z,y=.fitted)) + 
#   geom_point(alpha=0.3) + 
#   geom_smooth(method = "loess",se=TRUE) +
#   scale_y_continuous(breaks = round(seq(min(df_plot$.fitted), max(df_plot$.fitted), by = 100),1))
  # facet_wrap(~preditora_class,ncol=2,scales="free") +
  # labs(title = title_,x="",y="")
```


```{r nRefEE candidatos outlier,eval=TRUE,echo=TRUE}
v_sitesOut_nRefEE <- filter(df_plot,.fitted < -300 | .fitted > 380 | .cooksd > 2000) %>%
  .$SiteCode %>% unique
```

```{r nRefEE possiveis sitios outliers,eval=TRUE,echo=FALSE,fig.width=4, fig.height=2}
# dados
df_plot <- df_resultados %>% filter(MN=="EE") %>% distinct()
df_plot$nRef_predito <- predict.gam(md_nRefEE1,se.fit = TRUE,type="response")$fit*100
df_plot$nRef_se <- predict.gam(md_nRefEE1,se.fit = TRUE,type="response")$se*100
df_plot %<>%
  mutate(title = paste0(SiteCode, " p=",round(p,digits = 3)),
         yLower=nRef_predito-nRef_se,
         yUpper=nRef_predito+nRef_se) %>% 
  arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
df_plot %<>% filter(SiteCode %in% v_sitesOut_nRefEE)
# plot
ggplot(df_plot,aes(x=d.z,y=n_nRef)) +
  geom_ribbon(aes(ymin = yLower, ymax = yUpper),alpha=0.3,fill="blue") +
  geom_point(alpha=0.3) +
  geom_line(aes(y=nRef_predito),alpha=0.5,col="red") +
  theme_classic() + labs(x="d(metros)",y="nRef(count)") + labs(title = "subset : MN==EE, outliers?")+
  facet_wrap(~title,ncol=3)
```


  
#### Comparação Modelo Cheio sem outliers

```{r nRefEE sem outliers md cheio,eval=FALSE,echo=TRUE}
# sites outlier
v_sitesOut_nRefEE <- filter(df_plot,.fitted < -300 | .fitted > 380 | .cooksd > 2000) %>%
  .$SiteCode %>% unique
# dados
df_md <- df_resultados %>% filter(MN=="EE" & !(SiteCode %in% v_sitesOut_nRefEE)) %>% 
  distinct() %>% 
  mutate(rep = 1) 
df_md <- left_join(x=data.frame(rep=1,
                                md_class=c("glmm d+d^2|Site",
                                           "glmm d|Site",
                                           "glmm 1|Site",
                                           "gamm d|Site for each",
                                           "gamm d|Site common",
                                           "gamm 1|Site")),
                   y=df_md,
                   by="rep")
# ajuste modelos
registerDoMC(3)
l_nRefEE_mdCheio__sOut <- dlply(df_md,"md_class",f_md,.parallel = TRUE)
```

```{r save l_nRefEE_mdCheio__sOut,eval=FALSE,echo=FALSE}
save(l_nRefEE_mdCheio__sOut,file = "~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEE_mdCheio__sOut.Rdata")
```

```{r AICctab l_nRefEE_mdCheio__sOut}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEE_mdCheio__sOut.Rdata")
AICctab(l_nRefEE_mdCheio__sOut,weights=TRUE)
```
  
    
#### Diagnosticos modelo cheio sem outliers  

__Figura 2.2.4__ Appraise(md_nRefEE_sOut)       
      
```{r md cheio sOut nRefEE,echo=FALSE,eval=TRUE}
md_nRefEE_sOut <- l_nRefEE_mdCheio__sOut[["gamm d|Site for each"]]
df_md <- df_resultados %>% filter(MN=="EE" & !(SiteCode %in% v_sitesOut_nRefEE))
appraise(md_nRefEE_sOut)
```
  
  
<!-- __Figura 2.2.5__ Observado e predito pelo modelo cheio mais plausível   -->
  
```{r fig 225 predito e observado por sitio md_nRefEE, echo=FALSE,eval=FALSE, fig.width=8, fig.height=30,message=FALSE}
# dados
df_plot <- df_md
df_plot$nRef_predito <- predict.gam(md_nRefEE_sOut,se.fit = TRUE,type="response")$fit*100
df_plot$nRef_se <- predict.gam(md_nRefEE_sOut,se.fit = TRUE,type="response")$se*100
df_plot %<>%
  mutate(title = paste0(SiteCode, " p=",round(p,digits = 3)),
         yLower=nRef_predito-nRef_se,
         yUpper=nRef_predito+nRef_se) %>% 
  arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
# plot
ggplot(df_plot,aes(x=d.z,y=n_nRef)) +
  geom_ribbon(aes(ymin = yLower, ymax = yUpper),alpha=0.3,fill="blue") +
  geom_point(alpha=0.3) +
  geom_line(aes(y=nRef_predito),alpha=0.5,col="red") +
  theme_classic() + labs(x="d(metros)",y="nRef(count)") + labs(title = "subset : MN==EE")+
  facet_wrap(~title,ncol=6)
```


__Figura 2.2.5__ Diagnostico: avaliação do ajuste pelas preditoras lineares

```{r fig 225,echo=FALSE,eval=TRUE,fig.height=5}
#
df_plot <- augment(md_nRefEE_sOut) 
df_plot1 <- df_plot %>% 
  select(p.z,d.z,.fitted,.resid,.hat,.cooksd) %>% 
  gather(key = preditora_class, value = preditora_value,p.z:d.z) %>% 
  gather(key = var_diagnostico, value = var_value,.fitted:.cooksd)
df_plot1$var_diagnostico <- factor(df_plot1$var_diagnostico,levels = unique(df_plot1$var_diagnostico))
#
f_p <- function(dados){
  title_ <- unique(dados$var_diagnostico) %>% 
    as.character()
  p <- ggplot(dados,aes(x=preditora_value,y=var_value)) + 
  geom_point(alpha=0.3) + 
  geom_smooth(method = "loess",se=TRUE) + 
  facet_wrap(~preditora_class,ncol=2,scales="free") +
  labs(title = title_,x="",y="")
}
l_p <- dlply(df_plot1,.(var_diagnostico),f_p)
# p_ <- ggplot(df_plot,aes(y=var_value)) + 
#   # geom_jitter(alpha=0.3) +
#   geom_boxplot() + 
#   facet_wrap(~var_diagnostico,ncol=4,scales="free")
do.call("grid.arrange",c(l_p,ncol=2))
#
# ggplot(df_plot,aes(x=p.z,y=.fitted)) + 
#   geom_point(alpha=0.3) + 
#   geom_smooth(method = "loess",se=TRUE) +
#   scale_y_continuous(breaks = round(seq(min(df_plot$.fitted), max(df_plot$.fitted), by = 100),1))
  # facet_wrap(~preditora_class,ncol=2,scales="free") +
  # labs(title = title_,x="",y="")
```
  
  
## 2.3 Subset=MNEI

### Estudo GAMM: smoother type

i) Antes de comparar os modelos cheios preciso avaliar smoother type mais para utilizar na GAMM;
ii) Pelo observado nos dados (figuras 2.1 e 2.2) vou comparar dois smoother type: "tp" e "cr"
iii) Para isso vou ajuster um smoother para d por Sítio de amostragem com um mesmo parâmetro de penalização, dessa maneira eu considero a variação por sítio de amostragem na variável d sem um elevado custo computacional.  


```{r nRef MNEI estudo GAMM smoother type,echo=TRUE,eval=FALSE}
# dados
df_md <- df_resultados %>% filter(MN=="EI") %>% distinct()
df_md <- rbind(mutate(df_md,model_class = "cr"),
               mutate(df_md,model_class = "tp"))
df_md$model_class <- factor(df_md$model_class)
# função
f_md <- function(dados){
  model_class <- unique(dados$model_class)
  if(model_class == "cr"){
    md_ <- gam(cbind(n_nRef,100-n_nRef) ~ 
                 s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                 s(d.z,SiteCode,bs="fs",xt=list(bs="cr"), m=1),
                data = dados, family = "binomial")
    
  }else{
    md_ <- gam(cbind(n_nRef,100-n_nRef) ~ 
                 s(p.z,bs="tp") + s(d.z,bs="tp") + ti(p.z,d.z,bs=c("tp","tp")) +
                 s(d.z,SiteCode,bs="fs",xt=list(bs="tp"), m=1),
                data = dados, family = "binomial")
    
  }
  return(md_)
}
registerDoMC(2)
l_nRefEI_estudoGAMM <- dlply(df_md,"model_class",f_md,.parallel = TRUE)
```

```{r save l_nRefEI_estudoGAMM,eval=FALSE}
save(l_nRefEI_estudoGAMM,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEI_estudoGAMM.Rdata")
```

```{r AICctab l_nRefEI_estudoGAMM,eval=TRUE,echo=FALSE}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEI_estudoGAMM.Rdata")
AICctab(l_nRefEI_estudoGAMM,weights=TRUE)
```


### Comparação Modelos Cheios

```{r comparacao modelos cheios nRefEI,echo=TRUE,eval=FALSE}
# dados
df_md <- df_resultados %>% filter(MN=="EI") %>% 
  distinct() %>% 
  mutate(rep = 1)
df_md <- left_join(x=data.frame(rep=1,
                                md_class=c("glmm d+d^2|Site",
                                           "glmm d|Site",
                                           "glmm 1|Site",
                                           "gamm d|Site for each",
                                           "gamm d|Site common",
                                           "gamm 1|Site")),
                   y=df_md,
                   by="rep")
# função de ajuste
registerDoMC(3)
l_nRefEI_mdCheio <- dlply(df_md,"md_class",f_md,.parallel = TRUE)
```


```{r save l_nRefEI_mdCheio, eval=FALSE}
save(l_nRefEI_mdCheio,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEI_mdCheio.Rdata")
```

```{r AICctab l_nRefEI_mdCheio,echo=FALSE,eval=TRUE}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEI_mdCheio.Rdata")
AICctab(l_nRefEI_mdCheio,weights=TRUE)
md_nRefEI <- l_nRefEI_mdCheio[["gamm d|Site for each"]]
```


#### Diagnostico modelo cheio

__Figura 2.3.1__ appraise(md_nRefEI)

```{r fig 231,echo=FALSE,eval=TRUE}
par(mfrow=c(2,2))
gam.check(md_nRefEI)
```

```{r summary nRefEI,echo=FALSE}
summary(md_nRefEI)
```


__Figura 2.3.2__ Predito e observado por sítio 

```{r fig 232 predito e observado por sitio md_nRefEE, echo=FALSE,eval=TRUE, fig.width=8, fig.height=30,message=FALSE}
# dados
df_plot <- df_resultados %>% filter(MN=="EI") %>% distinct()
df_plot$nRef_predito <- predict.gam(md_nRefEI,se.fit = TRUE,type="response")$fit*100
df_plot$nRef_se <- predict.gam(md_nRefEI,se.fit = TRUE,type="response")$se*100
df_plot %<>%
  mutate(title = paste0(SiteCode, " p=",round(p,digits = 3)),
         yLower=nRef_predito-nRef_se,
         yUpper=nRef_predito+nRef_se) %>% 
  arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
# plot
ggplot(df_plot,aes(x=d.z,y=n_nRef)) +
  geom_ribbon(aes(ymin = yLower, ymax = yUpper),alpha=0.3,fill="blue") +
  geom_point(alpha=0.3) +
  geom_line(aes(y=nRef_predito),alpha=0.5,col="red") +
  theme_classic() + labs(x="d(metros)",y="nRef(count)") + labs(title = "subset : MN==EI")+
  facet_wrap(~title,ncol=6)
```
  
  
__Figura 2.3.3__ Diagnostico: avaliação do ajuste pelas preditoras lineares

```{r fig 233,echo=FALSE,eval=TRUE,fig.height=5}
#
df_plot <- augment(md_nRefEI) 
df_plot1 <- df_plot %>% 
  select(p.z,d.z,.fitted,.resid,.hat,.cooksd) %>% 
  gather(key = preditora_class, value = preditora_value,p.z:d.z) %>% 
  gather(key = var_diagnostico, value = var_value,.fitted:.cooksd)
df_plot1$var_diagnostico <- factor(df_plot1$var_diagnostico,levels = unique(df_plot1$var_diagnostico))
#
f_p <- function(dados){
  title_ <- unique(dados$var_diagnostico) %>% 
    as.character()
  p <- ggplot(dados,aes(x=preditora_value,y=var_value)) + 
  geom_point(alpha=0.3) + 
  geom_smooth(method = "loess",se=TRUE) + 
  facet_wrap(~preditora_class,ncol=2,scales="free") +
  labs(title = title_,x="",y="")
}
l_p <- dlply(df_plot1,.(var_diagnostico),f_p)
# p_ <- ggplot(df_plot,aes(y=var_value)) + 
#   # geom_jitter(alpha=0.3) +
#   geom_boxplot() + 
#   facet_wrap(~var_diagnostico,ncol=4,scales="free")
do.call("grid.arrange",c(l_p,ncol=2))
#
# ggplot(df_plot,aes(x=p.z,y=.fitted)) + 
#   geom_point(alpha=0.3) + 
#   geom_smooth(method = "loess",se=TRUE) +
#   scale_y_continuous(breaks = round(seq(min(df_plot$.fitted), max(df_plot$.fitted), by = 100),1))
  # facet_wrap(~preditora_class,ncol=2,scales="free") +
  # labs(title = title_,x="",y="")
#
```
  
    
  
## 2.4 Conjunto Completo dos Dados

### Métodos de Estimativa do Intervalo de Confiança

```{r objetos para a figura final nRef,eval=TRUE,echo=FALSE}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEE_mdCheio.Rdata")
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_nRefEI_mdCheio.Rdata")
```
  
The following code was adapted from Gavin Simpson (2016) blog post [acessado em abril de 2020]:  
https://fromthebottomoftheheap.net/2016/12/15/simultaneous-interval-revisited/



```{r calculo do intervalo de confianca da distuicao posteriori,eval=FALSE,echo=TRUE}
# new data
df_pred0 <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1],
                       d.z=seq(min(df_resultados$d.z),max(df_resultados$d.z),length=40),
                       p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=200))
l_mdNref <- list()
l_mdNref[[1]] <- l_nRefEE_mdCheio[["gamm d|Site for each"]]
l_mdNref[[2]] <- l_nRefEI_mdCheio[["gamm d|Site for each"]]
names(l_mdNref) <- c("EE","EI")
# function
f_predict_PostDist <- function(gamm,df=df_pred0,N=1e4){
  #objetos em comum
  beta <- coef(gamm)
  Vb <- vcov(gamm)
  Xp <- predict(gamm,df,type="lpmatrix")
  pred <- predict.gam(gamm,df,se.fit = TRUE)
  se.fit <- pred$se.fit 
  pred.response <- predict.gam(gamm,newdata = df,type = "response",se.fit = TRUE)
  ### estabelece um fator de correção para se.fit
  BUdiff <- MASS::mvrnorm(N,mu=rep(0,nrow(Vb)),Sigma=Vb)
  simDev <- Xp %*% t(BUdiff)
  absDev <- abs(sweep(simDev, 1, se.fit, FUN = "/"))
  masd <- apply(absDev, 2L, max)
  crit <- quantile(masd,prob=0.95,type=8)
  ### simula todos os intervalos de confinça
  ### e então calcula os quantis para cada ponto predito
  sims <- MASS::mvrnorm(N,mu=beta,Sigma=Vb)
  fits <- Xp %*% t(sims)
  q_fits <- t(apply(fits,1,quantile,prob=c(.025,0.5,0.975)))
  ## output
  df_return <- cbind(df,
                     data.frame(fit = pred$fit,
                                se.fit = pred$se.fit,
                                fitResponse = pred.response$fit,
                                se.fitResponse = pred.response$se.fit,
                                avg_fit = apply(fits,1,mean),
                                median_fit = q_fits[,2],
                                q_.025 = q_fits[,1],
                                q_.975 = q_fits[,3])
                     )
  df_return %<>% 
    mutate(upper.fit = fit + (crit*se.fit),
           lower.fit = fit - (crit*se.fit)) %>% 
    select(SiteCode,d.z,p.z,fitResponse,se.fitResponse,fit,se.fit,upper.fit,lower.fit,avg_fit,median_fit,q_.025,q_.975)
  return(df_return)
}
df_plot <- ldply(l_mdNref,f_predict_PostDist,.id="MN")
df_plot %<>% mutate(upper.fit_link = fit + (2*se.fit),
                    lower.fit_link = fit + (2*se.fit))
df_plot1 <- as.data.frame(apply(df_plot[,7:16],2,function(X) arm::invlogit(X)*100))
names(df_plot1) <- sapply(names(df_plot1), function(x) paste0(x,"_response"))
df_plot %<>% cbind(.,df_plot1)
```

```{r save df_plotnRef,eval=FALSE,echo=FALSE}
df_plot_nRef <- df_plot
write.csv(df_plot_nRef,
          file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/df_plot_nRef",
          row.names = FALSE)
```

```{r read df_plot_nRef,eval=TRUE,echo=FALSE}
df_plot <- read.csv("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/df_plot_nRef",
                         header = TRUE, as.is = TRUE)
# df_pred0 <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1],
#                        d.z=seq(min(df_resultados$d.z),max(df_resultados$d.z),length=40),
#                        p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=200))
# l_mdNref <- list()
# l_mdNref[[1]] <- l_nRefEE_mdCheio[["gamm d|Site for each"]]
# l_mdNref[[2]] <- l_nRefEI_mdCheio[["gamm d|Site for each"]]
# names(l_mdNref) <- c("EE","EI")
```


__Figura 2.4.1__ Comparação dos métodos para obter o predito e IC

```{r Comparacao metodos nRef IC fig 241,echo=FALSE,eval=TRUE,fig.width=10}
# df_plot %>% names
l_p <- list()
l_p[[1]] <- ggplot(df_plot,aes(x=fitResponse,y=fit_response)) +
  geom_point(alpha=0.3) + labs(title = "mean:invLink(link) ~ response")
l_p[[2]] <- ggplot(df_plot,aes(x=se.fitResponse,y=se.fit_response)) +
  geom_point(alpha=0.3) + labs(title = "se:invLink(link) ~ response")
l_p[[3]] <- ggplot(df_plot,aes(x=fit_response,y=avg_fit_response)) +
  geom_point(alpha=0.3) + labs(title = "mean posterior ~ link")
l_p[[4]] <- ggplot(df_plot,aes(x=upper.fit_response,y=q_.025_response)) +
  geom_point(alpha=0.3) + labs(title = " 97,5% posterior ~ fit + crit*se.fit")
l_p[[5]] <- ggplot(df_plot,aes(x=lower.fit_response,y=q_.975_response)) +
  geom_point(alpha=0.3) + labs(title = "2,5% posterior ~ fit - crit*se.fit")
# do.call("grid.arrange",c(l_p,ncol=3))
grid.arrange(l_p[[1]],l_p[[2]],l_p[[3]],l_p[[4]],l_p[[5]],
             layout_matrix=rbind(c(1,3,NA),
                                 c(2,4,5)),
             top="response scale")
```


### Figura Final: Predito e IC
  
- Média da Probabilidade de não refutar uma SAD neutra: invLink(preditct(type="link))  
- IC Probabilidade de não refutar uma SAD neutra: invLink(crit * se.fit)  
  
  
```{r figura final nRef fig 242,echo=FALSE,eval=TRUE}
# dados
df_plot <- read.csv("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/df_plot_nRef",
                         header = TRUE, as.is = TRUE)
df_plot %<>% mutate(p = p.z*sd(df_resultados$p) + mean(df_resultados$p),
                   d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
# df_plot %>% names
# graficos
l_p <- list()
df_plot %>% names
l_p[[1]] <- ggplot(df_plot,aes(x=p.z,y=d.z)) +
  geom_tile(aes(fill=fit_response)) +
  scale_fill_gradient2(low = "red",mid = "green",high = "blue") +
  facet_wrap(~MN,ncol=2)
ggplot(df_plot,aes(x=p,y=fit_response,color=d)) +
  geom_point(alpha=0.3) +
  scale_color_gradient2(mid = "green",midpoint = mean(df_plot$d)) +
  facet_wrap(~MN,ncol=2)
```



