---
Ftitle: "Estatistica"
author: "Mori, Danilo"
date: "31/10/2019"
output: 
  html_document:
    toc: true
    toc_depth: 5
editor_options: 
  chunk_output_type: console
---

<style>
body {
text-align: justify}
</style>

<!--  -->

```{r setup, include=TRUE,echo=FALSE}
knitr::opts_chunk$set(echo = FALSE, tidy = FALSE, include = TRUE, warning = FALSE,cache = TRUE,message=FALSE,eval=TRUE)
# setwd("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/")
knitr::opts_knit$set(root.dir = "~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/")
```

```{r pacotes,eval=TRUE,echo=F}
library(gtools)
library(GGally)
library(doMC)
library(parallel)
library(DHARMa)
library(broom.mixed)
library(KSgeneral)
library(twosamples)
library(MuMIn)
library(mgcv)
library(gratia)
library(GUILDS)
library(broom)
library(sads)
library(bbmle)
library(gamm4)
library(lme4)
library(merTools)
library(magrittr)
library(gridExtra)
library(plotly)
library(sjPlot)
library(sjlabelled)
library(sjmisc)
library(ggplot2)
library(stringr)
library(tidyr)
library(plyr)
library(purrr)
library(dplyr)
```

```{r dados,message=FALSE}
### dados ###
# leitura
df_resultados <- read.table(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/resultados/df_resultados.csv",header = TRUE,sep = ";",dec = ".",as.is=FALSE)
df_resultados$k.0_1 <- 1 - df_resultados$k.0
# padronização
level_k <- unique(as.character(df_resultados$k))
df_resultados$k <- factor(as.character(df_resultados$k),levels = level_k)
levels(df_resultados$k)[19] <- "0.1"
df_resultados %<>% mutate(L_plot = 100*sqrt(Ntotal/DA),
                          d_Lplot = d / L_plot,
                          log_Stotal=log(Stotal))
# z score
f_z <- function(x){
  m <- base::mean(x,na.rm=TRUE)
  sd <- sd(x,na.rm=TRUE)
  output <- (x-m)/sd
  return(output)
} 
# names(df_resultados)
# summary(df_resultados)
df_resultados %<>% mutate(diff_S0 = (S.MN_mean-Stotal)/Stotal,
                          diff_S = diff_S0 + min(diff_S0)*(-1) + 0.01,
                          modulo_diffS = abs(diff_S0))

df_resultados.z <- as.data.frame(apply(df_resultados[c("p","Ntotal","log_Stotal","k.0","k.0_1","d_Lplot","d","modulo_diffS")],2,f_z))
names(df_resultados.z) <- sapply(names(df_resultados.z), function(x) paste(gsub(".0","",x),".z",sep=""))
df_resultados %<>% cbind(.,df_resultados.z)
names(df_resultados)[5:6] <- c("n_nRef","n_Ref")
# df_U
df_resultados.U <- df_resultados %>% filter(MN=="EE") %>% distinct()
# df_EI
df_resultados.EI <- df_resultados %>% filter(MN=="EI") %>% distinct()
df_resultados.EI$modulo_diffS[df_resultados.EI$modulo_diffS == 0] <- 
  min(df_resultados.EI$modulo_diffS[df_resultados.EI$modulo_diffS != 0])*IQR(df_resultados.EI$modulo_diffS)/max(df_resultados.EI$modulo_diffS)
df_resultados.EI %<>% mutate(log_modulo_diffS = log(modulo_diffS),
                             log_modulo_diffS.z = f_z(log_modulo_diffS))
```

# 1 - Número de SADs preditas não refutadas


```{r n_nRef padroes gerais fig11}
l_p <- vector("list",2)
l_p[[1]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[1:10]),
                   aes(x=p,y=n_nRef)) + 
  geom_point() + 
  geom_smooth(method="loess") +
  facet_grid(k~MN)
l_p[[2]] <- ggplot(filter(df_resultados,k %in% levels(df_resultados$k)[11:20]),
                   aes(x=p,y=n_nRef)) + 
  geom_point() + 
  geom_smooth(method="loess") +
  facet_grid(k~MN) 
do.call("grid.arrange",c(l_p,ncol=2))
```

__Figura 1.1__ logito(número de SADs não refutadas) ~ p *  k * MN. A linha azul é uma estimativa baseada em 'loess'. 

A figura 1.1 mostra que o padrão geral dos dados não é linear na escala da função de ligação, assim utilizamos GAM. Possibilitamos até 1 intercepto por modelo neutro por sítio de amostragem (MN|SiteCode); para modelos com variáveis de dispersão continua não foi possível um smoother por Sítio de Amostragem e Modelo Neutro



## 1.1 GLMM binomial

### 1.1.1 Modelo Cheio e Auditoria

```{r glmm n_nRef comparacao modelos cheios,echo=TRUE,eval=FALSE,cache=TRUE}
l_md <- vector("list",11)
names(l_md) <- c("k0 1|Site","k0 MN|Site","k0 k0*MN|Site",
                 "kf 1|Site","kf MN|Site",
                 "d 1|Site","d MN|Site","d d*MN|Site",
                 "d/L_plot 1|Site","d/L_plot MN|Site","d/L_plot d/L_plot*MN|Site")
l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + I(p.z^2) * k_1.z * MN + (1|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + I(p.z^2) * k_1.z * MN + (MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k_1.z * MN + I(p.z^2) * k_1.z * MN + (k_1.z*MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[4]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k * MN + I(p.z^2) * k * MN + (1|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[5]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * k * MN + I(p.z^2) * k * MN + (MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[6]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d.z * MN + I(p.z^2) * d.z * MN + (1|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[7]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d.z * MN + I(p.z^2)G * d.z * MN + (MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[8]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d.z * MN + I(p.z^2) * d.z * MN + (d.z*MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[9]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + I(p.z^2) * d_Lplot.z * MN + (1|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[10]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + I(p.z^2) * d_Lplot.z * MN + (MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[11]] <- glmer(cbind(n_nRef,100-n_nRef) ~ p.z * d_Lplot.z * MN + I(p.z^2) * d_Lplot.z * MN + (d_Lplot.z*MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
```


```{r l_md_nRef.GLMM, eval=FALSE}
l_md_nRef.GLMM <- l_md
save(l_md_nRef.GLMM,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_GLMM.Rdata")
```



__Tabela 1.1 __ AICctab 

```{r AICctab n_nRef p^2 n_nRef,eval=TRUE,cache=FALSE}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef_GLMM.Rdata")
bbmle::AICctab(l_md_nRef.GLMM,weights=T)
```


O único modelo plausível é aquele com função de ligação logito, a variável d e a estrutura aleatória MN * d |SiteCode.


```{r auditoria mais plausivel md_n.ref1, message=FALSE}
# library(DHARMa)
md_nRef <- l_md_nRef.GLMM[["d d*MN|Site"]]
# p_plot <- simulateResiduals(md_nRef,n=1000)
# plot(p_plot)
```

__Figura 1.2__ Resíduos Quantílicos do modelo cheio para n_nRef ~ p*d*MN + p^2*d*MN + (d*MN|SiteCode)

NOTA: não entendo o motivo de não rodar os resíduos quantílicos quando compilo o Rmarkdown: 

mensagem de erro:

Error in if (family$family %in% c("binomial","poisson","quasibinomial", : argumento tem comprimento zero Calls: <Anonymous> ... withCallingHandlers -> withVisible -> eval -> eval -> simulateResiduals Além disso: warining message: In checkModel(fittedModel) : DHARMa: fittedModel not in class of supported models. Absolutely no guarantee that this will work


```{r graf diag 2 glmm p^2 n_nRef fig 13, include=FALSE,eval=FALSE}
# teste <- augment(lm(log(Stotal) ~ p,df_resultados)) %>% as.data.frame()
# df_plot <- augment(md_nRef) %>% as.data.frame() # demorando muito
# # df_plot %>% names
# l_p <- vector("list",3)
# l_p[[1]] <- ggplot(df_plot,aes(x=p.z,y=.fitted)) + geom_point(alpha=0.3) + geom_line(aes(group=SiteCode)) + facet_wrap(~MN,ncol=2)
# l_p[[2]] <- ggplot(df_plot,aes(x=I.p.z.2.,y=.fitted)) + geom_point(alpha=0.3) + geom_line(aes(group=SiteCode)) + facet_wrap(~MN,ncol=2)
# l_p[[3]] <- ggplot(df_plot,aes(x=d_Lplot.z,y=.fitted)) + geom_point(alpha=0.3) + geom_line(aes(group=SiteCode)) + facet_wrap(~MN,ncol=2)
# do.call("grid.arrange",c(l_p,ncol=1))
```

<!-- __Figura 1.3__ Valores ajustados contra as preditoras lineares  - ESTA DEMORANDO MUITO PARA RODAR AUGMENT PARA O MODELO MAIS PLAUSIVEL -->
  
### 1.1.2 Modelo cheio: predições

```{r avaliacao por site fig 14,fig.width=8, fig.height=30,message=FALSE,eval=FALSE}
# Dados
df_plot <- df_resultados
# df_plot <- cbind(df_plot,
#   predictInterval(merMod = md_nRef,
#                          level = 0.95, n.sims=200,
#                          stat="median",type = "probability",
#                          include.resid.var = TRUE)*100
#                  )
df_plot$Pr_nRef <- predict(md_nRef,type="response")*100
# Graficos
df_plot %<>% mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
ggplot(df_plot,aes(x=d.z,y=n_nRef,group=MN)) +
  geom_point(aes(color=MN)) +
  geom_line(aes(y=Pr_nRef,color=MN)) +
  scale_color_manual(values=c("#FF0000", "#000000")) +
  theme_light() + theme(legend.position="top") + facet_wrap(~title,ncol=5)
```

__Figura 1.3__ Predito e observado por SiteCode  
  

Observamos que é necessário considerar também um termo quadrático para d. Então sigo com a adição de um termo quadrático para d

__Tabela 1.2 __ R2 condicional e marginal do modelo cheio com termo quadrático para p e d 

```{r md_nRef2 e r2cm,echo=TRUE,cache=TRUE}
md_nRef2 <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                     (p.z + I(p.z^2)) * (d.z + I(d.z^2)) * MN + ((d.z + I(d.z^2)) * MN|SiteCode),
                   family = "binomial",data=df_resultados,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
r.squaredGLMM(md_nRef2)
```


```{r md_nRef2 quant res}
p_plot <- simulateResiduals(md_nRef2,n = 1000)
plot(p_plot)
```

__Figura 1.4__ Resíduos quantílicos para o modelo cheio com termos quadráticos para p e d.  


```{r avaliacao por site fig 15 glmm p2 d2,fig.width=8, fig.height=30,message=FALSE}
# Dados
df_plot <- df_resultados
df_plot <- cbind(df_plot,
  predictInterval(merMod = md_nRef2,
                         level = 0.95, n.sims=200,
                         stat="median",type = "probability",
                         include.resid.var = TRUE)*100
                 )
# df_plot$Pr_nRef <- predict(md_nRef,type="response")*100
# Graficos
df_plot %<>% mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
ggplot(df_plot,aes(x=d.z,y=n_nRef,group=MN)) +
  geom_point(aes(color=MN)) +
  geom_line(aes(y=fit,color=MN)) +
  scale_color_manual(values=c("#FF0000", "#000000")) +
  theme_classic() + theme(legend.position="top") + facet_wrap(~title,ncol=5)
```
  
__Figura 1.5__ Predito pelo modelo com termo quadrático para p e d

O modelo cheio com termo quadrático para p e d não foi foi suficiente para descrever o padrão observado nos dados. Hipotetizamos que a razão é a divergência no grau de variação entre os modelos neutros. Assim iremos ajustar modelos para cada conjunto de dados. Para possibilitar a comparação irei manter a estrutura comum das preditoras porem comparando a estrutura aleatória e função de ligação para cada modelo neutro.
   


## 1.2 GLMM binomail subset:MN==EE

### Modelo cheio

```{r glmm quadratico n_nRef MNEE modelo cheio,echo=TRUE,eval=FALSE}
l_md <- vector("list",3)
names(l_md) <- c("1|Site","d|Site","d + d^2|Site")
l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (1|SiteCode),
                   family = "binomial",data=filter(df_resultados,MN=="EE"),
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (d.z|SiteCode),
                   family = "binomial",data=filter(df_resultados,MN=="EE"),
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (d.z + I(d.z^2)|SiteCode),
                   family = "binomial",data=filter(df_resultados,MN=="EE"),
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
```

```{r l_md_nRef.GLMM_EE,echo=FALSE,eval=FALSE}
l_md_nRef.GLMM_EE <- l_md
save(l_md_nRef.GLMM_EE,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef.GLMM_EE.Rdata")
```

__Tabela 1.2.1__ AICctab para n_nRef MNEE 

```{r glmm quadratico n_nRef MNEE modelo cheio AICctab}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef.GLMM_EE.Rdata")
AICctab(l_md_nRef.GLMM_EE,weights=TRUE)
```

  
O modelo mais plausível considera um termo linear e quadrático para d na estrutura aletória. 


```{r fig 119 res quant glmm cheio MNEE}
p_plot <- DHARMa::simulateResiduals(l_md_nRef.GLMM_EE[["d + d^2|Site"]],n=1000)
plot(p_plot)  
```
  
__Figura 1.6__ Resíduos Quantílicos do glmm cheio para MNEE    


__Tabela 1.2.2__ R2 condicional e marginal modelo cheio nRef 

```{r tabela md cheio para MNEE nRef,message=FALSE,warning=FALSE}
r.squaredGLMM(l_md_nRef.GLMM_EE[["d + d^2|Site"]])
```


   
```{r avaliacao por site fig 17 glmm EE p2 d2,fig.width=8, fig.height=30,message=FALSE,eval=FALSE}
# Dados
df_plot <- df_resultados %>% filter(MN=="EE")
# df_plot <- cbind(df_plot,
#   predictInterval(merMod = l_md_nRef.GLMM_EE[["d + d^2|Site"]],
#                          level = 0.95, n.sims=200,
#                          stat="median",type = "probability",
#                          include.resid.var = TRUE)*100
#                  )
df_plot$Pr_nRef <- predict(l_md_nRef.GLMM_EE[["d + d^2|Site"]],type="response")*100
# Graficos
df_plot %<>% mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
ggplot(df_plot,aes(x=d.z,y=n_nRef)) +
  geom_point() +
  geom_line(aes(y=Pr_nRef),color="red") +
  theme_light() + theme(legend.position="top") + facet_wrap(~title,ncol=5)
```
  
<!-- __Figura 1.7__ Predito pelo modelo cheio com termo quadrático para p e d para MN=EE -->

  
### Seleção de Variáveis
  


```{r modelo global e R2m/c MNEE, echo=TRUE,cache=TRUE}
# dados
df_md <- filter(df_resultados,MN=="EE")
# modelo global
global_md <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (d.z + I(d.z^2)|SiteCode),
                   family = "binomial",data=df_md,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)),na.action = "na.fail")
```
  
  
__Tabela 1.2.3__ R2 condicional e marginal do modelo global

```{r modelo global dredge e AICctab delta 7 n_nRefEE}
dredge_glmmEE <- dredge(global_md,trace = FALSE,evaluate=TRUE)
subset(dredge_glmmEE,delta<7)
```






```{r model averaging EE MuMIn e AICcmodavg,message=FALSE,eval=FALSE}
library(AICcmodavg)
# todas as combinações de modelo do modelo cheio
l_md.dredge_nRefEE <- lapply(dredge(global_md,trace = FALSE,evaluate=FALSE), eval)
# Model Averaging for SiteCode predictions
mdAvg_nRefEE__MuMIn <- model.avg(l_md.dredge_nRefEE) #,subset<2
save(mdAvg_nRefEE__MuMIn,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__MuMIn.Rdata")
# Model Averaging for new data predictions
df_pred <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1],
                       d.z=seq(min(df_resultados$d.z),max(df_resultados$d.z),length=40),
                       p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=200))
mdAvg_nRefEE__AICcmodavg <- modavgPred(l_md.dredge_nRefEE,newdata = df_pred) %>%
  cbind(df_pred)
save(mdAvg_nRefEE__AICcmodavg,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__AICcmodavg.Rdata")
```

#### Predito para cada Sítio

Para avaliar o ajuste do modelo ao conjunto de dados utilizo funções do pacote MuMIn (REF) que permite calcular a predição do modelo médio para o conjunto original de dados.  
  

```{r glmm quadratico n_nRef MNEE selecao de variaveis, comment=FALSE, message=FALSE,warning=FALSE,results="hide",fig.width=8, fig.height=30}
# Modelo Global
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__MuMIn.Rdata")
# Predição
df_md <- df_resultados %>% filter(MN=="EE")
df_md$Pr_nRef <- predict(mdAvg_nRefEE__MuMIn,type="response")*100
# Gráfico
df_md %<>% mutate(title = paste0(SiteCode," p=",round(p,3))) %>% arrange(p)
df_md$title <- factor(df_md$title,levels = unique(df_md$title))
ggplot(df_md,aes(x=d,y=n_nRef)) + 
  geom_point() + geom_line(aes(y=Pr_nRef),color="red") + 
  labs(x="Dispersão Média",
       y="Número de SADs não Refutadas",
       title="Prob. Não Refutar uma SAD neutra MN=EE") +
  facet_wrap(~title,ncol=5) + theme_light()
```

__Figura 1.7__ Predições por sítio de amostragem do modelo médio calculado a partir do modelo global 
; pontos: número de SADs neutras refutadas para uma bateria de simulações com um determinada distância média de dispersão; eixo x = distância média de dispersão / largura da área de amostragem; a linha é a probabilidade de não refutar uma SAD neutra segundo a predição média do conjunto de sub-modelos dentro do intervalo de plausibilidade de 7 (Burnham et al 2011)
  
  
#### Predito para novo conjunto de dados  
  
Para avaliar o predito e intervalo de confiança de 95% pelo modelo médio utilizo funções do pacote AICcmodavg (REF).  

```{r fig 18 predito para novo conjunto de dados glmm nRefEE AICcmodavg}
# dados
## modelo médio
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__AICcmodavg.Rdata")
df_plot <- mdAvg_nRefEE__AICcmodavg
# df_plot %>% names
df_plot %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),d = d.z*sd(df_resultados$d) + mean(df_resultados$d))


l_p.nRefEE_AICcmodavg <- list()
l_p.nRefEE_AICcmodavg[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Prob de não Refutar",
       fill="Probability") + theme_classic()
l_p.nRefEE_AICcmodavg[[2]] <- ggplot(df_plot,aes(x=p,y=d,fill=lower.CL)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Lower IC (5%)",
       fill="Probability") + theme_classic()
l_p.nRefEE_AICcmodavg[[3]] <- ggplot(df_plot,aes(x=p,y=d,fill=upper.CL)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Upper IC (95%)",
       fill="Probability") + theme_classic()
grid.arrange(l_p.nRefEE_AICcmodavg[[1]],l_p.nRefEE_AICcmodavg[[2]],l_p.nRefEE_AICcmodavg[[3]],
             layout_matrix=rbind(rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 c(2,2,3,3),
                                 c(2,2,3,3))
             )
```
  
__Figura 1.8__ Efeito predito de d e p na Probabilidade de não refutar segundo o modelo médio para MN==EE.  No painel superior a predição média, nos paineis inferiores o intervalo de confiança.  
  

## 1.3 n_nRef subset:MN==EI  
  
  
```{r glmm quadratico n_nRef MNEI modelo cheio,include=FALSE,eval=FALSE,echo=TRUE}
l_md <- vector("list",3)
names(l_md) <- c("1|Site","d|Site","d + d^2|Site")
l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (1|SiteCode),
                   family = "binomial",data=filter(df_resultados,MN=="EI"),
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (d.z|SiteCode),
                   family = "binomial",data=filter(df_resultados,MN=="EI"),
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (d.z + I(d.z^2)|SiteCode),
                   family = "binomial",data=filter(df_resultados,MN=="EI"),
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
```

```{r l_md_nRef.GLMM_EI,eval=FALSE}
l_md_nRef.GLMM_EI <- l_md
save(l_md_nRef.GLMM_EI,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef.GLMM_EI.Rdata")
```



__Tabela 1.3.1__ AICctab n_nRef MNEI  

```{r glmm quadratico n_nRef MNEI modelo cheio AICctab}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_nRef.GLMM_EI.Rdata")
AICctab(l_md_nRef.GLMM_EI,weights=TRUE)
```

A função AICcmodavg::modavgPred aceita apenas a função de ligação canonica logito, então não irei comparar outras funções de ligação
O modelo mais plausível considera um termo linear e quadrático para d na estrutura aletória. Segue seleção de variáveis.

__Tabela 1.3.2__ R2 marginal e condicional n_nRef MNEI  
  

```{r r2mc nRefEI}
r.squaredGLMM(l_md_nRef.GLMM_EI[["d + d^2|Site"]])
```


```{r fig 19 res quant glmm cheio MNEI}
p_plot <- DHARMa::simulateResiduals(l_md_nRef.GLMM_EI[["d + d^2|Site"]],n=1000)
plot(p_plot)  
```
  
__Figura 1.9__ Resíduos Quantílicos do glmm cheio mais plausível para MNEI   
     

```{r modelo global n_nRef e R2m/c MNEI, include=TRUE,echo=TRUE,cache=TRUE}
# dados
df_md <- filter(df_resultados,MN=="EI")
# modelo global
global_md <- glmer(cbind(n_nRef,100-n_nRef) ~
                     ( p.z + I(p.z^2) ) * ( d.z + I(d.z^2) ) +
                     (d.z + I(d.z^2)|SiteCode),
                   family = "binomial",data=df_md,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)),na.action = "na.fail")
```

__Tabela 1.3.3__ AICctab n_nRef MNEI delta<7  
  
   

```{r modelo dredge AICctab nRefEI}
dredge_glmmEI <- dredge(global_md,trace = FALSE,evaluate=TRUE)
subset(dredge_glmmEI,delta<7)
```



```{r model averaging EI MuMIn e AICcmodavg,message=FALSE,eval=FALSE}
# todas as combinações de modelo do modelo cheio
l_md.dredge_nRefEI <- lapply(dredge(global_md,trace = FALSE,evaluate=FALSE), eval)
# Model Averaging for SiteCode predictions
mdAvg_nRefEI__MuMIn <- model.avg(l_md.dredge_nRefEI) #,subset<2
save(mdAvg_nRefEI__MuMIn,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__MuMIn.Rdata")
# Model Averaging for new data predictions
df_pred <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1],
                       d.z=seq(min(df_resultados$d.z),max(df_resultados$d.z),length=40),
                       p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=200))
mdAvg_nRefEI__AICcmodavg <- AICcmodavg::modavgPred(l_md.dredge_nRefEI,newdata = df_pred) %>%
  cbind(df_pred)
save(mdAvg_nRefEI__AICcmodavg,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__AICcmodavg.Rdata")
```

##### Predito para cada Sítio

Para avaliar o ajuste do modelo ao conjunto de dados utilizo funções do pacote MuMIn (REF) que permite calcular a predição do modelo médio para o conjunto original de dados.  
  

```{r glmm quadratico n_nRef MNEI selecao de variaveis, comment=FALSE, message=FALSE,warning=FALSE,results="hide",fig.width=8, fig.height=30}
# Modelo Global
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__MuMIn.Rdata")
# Predição
df_md <- df_resultados %>% filter(MN=="EI")
df_md$Pr_nRef <- predict(mdAvg_nRefEI__MuMIn,type="response")*100
# Gráfico
df_md %<>% mutate(title = paste0(SiteCode," p=",round(p,3))) %>% arrange(p)
df_md$title <- factor(df_md$title,levels = unique(df_md$title))
ggplot(df_md,aes(x=d_Lplot,y=n_nRef)) + 
  geom_point() + geom_line(aes(y=Pr_nRef),color="red") + 
  labs(x="Dispersão Média per capita / Lado da Área Amostrada",
       y="Número de SADs não Refutadas",
       title="Prob. Não Refutar uma SAD neutra MN=EI") +
  facet_wrap(~title,ncol=5) + theme_classic()
```  

__Figura 1.10__ Predito por SiteCode a partir do modelo médio para MNEI.  
  
  
      
  
```{r fig 111 predito para novo conjunto de dados glmm nRefEI AICcmodavg}
# dados
## modelo médio
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__AICcmodavg.Rdata")
df_plot <- mdAvg_nRefEI__AICcmodavg
# df_plot %>% names
df_plot %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),d = d.z*sd(df_resultados$d) + mean(df_resultados$d))


l_p.nRefEI_AICcmodavg <- list()
l_p.nRefEI_AICcmodavg[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Prob de não Refutar",
       fill="Probability") + theme_classic()
l_p.nRefEI_AICcmodavg[[2]] <- ggplot(df_plot,aes(x=p,y=d,fill=lower.CL)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Lower IC (5%)",
       fill="Probability") + theme_classic()
l_p.nRefEI_AICcmodavg[[3]] <- ggplot(df_plot,aes(x=p,y=d,fill=upper.CL)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(title="Upper IC (95%)",
       fill="Probability") + theme_classic()
grid.arrange(l_p.nRefEI_AICcmodavg[[1]],l_p.nRefEI_AICcmodavg[[2]],l_p.nRefEI_AICcmodavg[[3]],
             layout_matrix=rbind(rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 c(2,2,3,3),
                                 c(2,2,3,3))
             )
```
  
__Figura 1.11__ Efeito predito de d e p na Probabilidade de não refutar segundo o modelo médio para MN==EE.  No painel superior a predição média, nos paineis inferiores o intervalo de confiança.  



## 1.4 Figura Final





```{r figura final n_nRef }
#############
# dados
## MNEE
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__AICcmodavg.Rdata")
mdAvg_nRefEE__AICcmodavg$MN <- "EE"
## MNEI
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__AICcmodavg.Rdata")
mdAvg_nRefEI__AICcmodavg$MN <- "EI"
## df comum
df_plot <- rbind(mdAvg_nRefEE__AICcmodavg,mdAvg_nRefEI__AICcmodavg)
df_plot %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
                    d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
## Gráficos
l_p.nRefEE_AICcmodavg <- list()
labels_IC <- c(lower.CL="IC 5%", upper.CL="IC 95%")
## predição média para ambos modelos
l_p.nRefEE_AICcmodavg[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  labs(
    # title="Probabilidade de Não Refutar",
       fill="Probability") +
  theme_classic() + facet_wrap(~MN,ncol=2) + theme(legend.position="top")
## IC para MNEE
df_plotEE <- df_plot %>% filter(MN=="EE") %>%
  gather(key = IC_class ,value = IC_pred,lower.CL:upper.CL)
l_p.nRefEE_AICcmodavg[[2]] <- ggplot(df_plotEE,aes(x=p,y=d,fill=IC_pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  theme_classic() + facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) + theme(legend.position='none')
## IC para MNEI
df_plotEI <- df_plot %>% filter(MN=="EI") %>%
  gather(key = IC_class ,value = IC_pred,lower.CL:upper.CL)
l_p.nRefEE_AICcmodavg[[3]] <- ggplot(df_plotEI,aes(x=p,y=d,fill=IC_pred)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,1),midpoint=0.5, low="red", high="blue",mid="green") +
  theme_classic() + facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) + theme(legend.position='none')
## Arranjo dos gráficos
grid.arrange(l_p.nRefEE_AICcmodavg[[1]],l_p.nRefEE_AICcmodavg[[2]],l_p.nRefEE_AICcmodavg[[3]],
             layout_matrix=rbind(rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 c(2,2,3,3),
                                 c(2,2,3,3))
             )


```


__Figura 1.12__ Probabilidade de não refutar uma SAD neutra em função do modelo neutro (EE e EI), proporção de cobertura vegetal (p) e distância média de dispersão (d)


# 2 diff_S = (S_obs - S_MN)/S_obs

__Padrão Geral__

```{r preparacao dos dados 1,message=FALSE,eval=TRUE}
# gráfico
df_resultados %>% ggplot(aes(x=p,y=diff_S0,group=MN)) + 
  geom_abline(intercept = 0,slope = 0,col="blue") +
  geom_point(aes(color=MN),alpha=0.3) +
  scale_color_manual(values=c("#FF0000", "#000000")) +
  labs(title="diff_S = (S_MN - S_obs)/S_obs",x="p",y="diff_S") +
  facet_wrap(~k,ncol=5,scales="free") + theme_light()
# # graficos 
# filter(df_resultados,MN=="EE") %>% select(diff_S0, p, d, Stotal, Ntotal) %>% ggpairs() + labs(title="MNEE")
# do.call("grid.arrange",c(l_p,ncol=1))
```

__Figura 2.1__ diff_S (y-axis), p (x-axis).




## 2.1 MNEE



```{r diff_S MNEE modelo cheio,echo=TRUE}
l_md <- vector("list",9)
names(l_md) <- c("1-k 1|Site","1-k I(1-k)|Site",
                 "k 1|Site",
                 "d 1|Site","d d|Site",
                 "d/L 1|Site","d/L I(d/L)|Site",
                 "1 1|Site",
                 "1")
df_md <- df_resultados %>% filter(MN=="EE")
l_md[[1]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * k_1.z + (1|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[2]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * k_1.z + (k_1.z|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[3]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * k + (1|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[4]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * d.z + (1|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[5]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * d.z + (d.z|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[6]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * d_Lplot.z + (1|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[7]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * d_Lplot.z + (d_Lplot.z|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[8]] <- lmer(diff_S0 ~ 1 + (1|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[9]] <- lm(diff_S0 ~ 1,
                  data=df_md,na.action = "na.fail")
AICctab(l_md,weights=T)
```

Alguns modelos utilizados para estimar diff_S apresentaram "singularidade" (estimativas não diferem de zero), dentre eles o único modelo plausível. Isso indica que modelo com a estrutura aleatória mais simples devem ser ajustados aos dados, assim vou descartar aqueles com inclinação para a variável de dispersão por Sítio.

```{r diff_S modelo cheio 2,echo=TRUE}
l_md <- vector("list",6)
names(l_md) <- c("1-k 1|Site",
                 "k 1|Site",
                 "d 1|Site",
                 "d/L 1|Site",
                 "1 1|Site",
                 "1")
df_md <- df_resultados %>% filter(MN=="EE")
l_md[[1]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * k_1.z + (1|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[2]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * k + (1|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[3]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * d.z + (1|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[4]] <- lmer(diff_S0 ~ (p.z + I(p.z^2)) * d_Lplot.z + (1|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[5]] <- lmer(diff_S0 ~ 1 + (1|SiteCode),
                   data=df_md,na.action = "na.fail")
l_md[[6]] <- lm(diff_S0 ~ 1,
                   data=df_md,na.action = "na.fail")
AICctab(l_md,weights=T)
```
  
Nenhum destes modelos apresentou singularidade, o modelo nulo sem estrutura aleatória foi o único plausível. Segue gráfico diagnóstico:  


```{r graf diag modelo cheio mais plausivel diff_S MNEE,message=FALSE,warning=FALSE}
p_plot <- simulateResiduals(l_md[["1"]],n = 1000)
plot(p_plot)
```

__Figura 2.2__ Resíduos Quantílicos do modelo mais plausível para diff_S subset=MNEE (diff_S ~ 1)

__Tabela 2.3__ Sumário do modelo mais plausível para diff_S MNEE  

```{r}
summary(l_md[["1"]])
```
  
## MNEI  

```{r padroes gerais diff S MNEI, warning=FALSE,message=FALSE}
df_plot <- df_resultados %>% filter(MN=="EI")
ggplot(df_plot,aes(x=p,y=diff_S)) + 
  geom_smooth() + 
  geom_point(alpha=0.3) + 
  facet_wrap(~k,ncol=5,scales="free")
```

__Figura 2.3__ diffS_EI ~p*k  

Vou iniciar apenas com as preditoras de interesse (p e variáveis de dispersão). Devido a clara ausência de simetria de diff_S desloquei a distribuição apenas para valores positivos (figura 2.3 primeiro quadro) e utilizarei distribuição Gamma para ajustar os modelos com função de ligação 'log'.

```{r diff_S MNEI por sitio,fig.width=8, fig.height=30}
df_plot <- df_resultados %>% filter(MN=="EI")
df_plot %<>% mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
## por sítio de amostragem
ggplot(df_plot,aes(x=d,y=diff_S0)) +
  geom_point() +
  geom_smooth(method="loess",col="blue") + geom_smooth(method="lm",col="red") +
  theme_light() + theme(legend.position="top") + 
  labs(title=" red = lm; blue = 'loess' ") +
  facet_wrap(~title,ncol=5) #,scales="free" 
```

__Figura 2.4__ diff_S por sítio de amostragem e d

### Seleção do Modelo cheio: GLMM

```{r modelo cheio diff_S MNEI, echo=TRUE,warning=TRUE,message=TRUE,eval=FALSE}
df_md <- df_resultados %>% filter(MN=="EI")
# df_md$diff_S %>% summary
l_md <- vector("list",6)
names(l_md) <- c("1|Site","d|Site",
                 "p2*k log",
                 "p2*d2 id 1|Site",
                 "p2*d2 id d|Site",
                 "p2*d2 id d2|Site")
# modelos mínimos
l_md[[1]] <- glmer(diff_S ~ p.z*d.z + (1|SiteCode),
                   data=df_md,family="Gamma"(link="log"))
l_md[[2]] <- glmer(diff_S ~ p.z*d.z  + (d.z|SiteCode),
                   data=df_md,family="Gamma"(link="log"))
# com p2
## erro
l_md[[3]] <- glmer(diff_S ~ (p+I(p.z^2))*k + (1|SiteCode),
                   data=df_md,family="Gamma"(link="log"))
v_vars <- getME(l_md[[3]],c("theta","fixef"))
l_md[[3]] <- update(l_md[[3]],start=v_vars,control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
l_md[[3]] <- glmer(diff_S ~ I(p.z^2)*k + (1|SiteCode),
                   data=df_md,family="Gamma"(link="log"))
# com p2 e d2
#######################
# Model failed to converge with max|grad| = 0.00556207 (tol = 0.002, component 1)Model is nearly unidentifiable: very large eigenvalue
#  - Rescale variables?
l_md[[4]] <- glmer(diff_S ~ (p.z + I(p.z^2))*(d.z + I(d.z^2)) + (1|SiteCode),
                   data=df_md,family="Gamma"(link="log"))
v_vars <- getME(l_md[[4]],c("theta","fixef"))
l_md[[4]] <- update(l_md[[4]],start=v_vars,control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
#######################
#######################
# Model failed to converge with max|grad| = 0.0608783 (tol = 0.002, component 1)Model is nearly unidentifiable: very large eigenvalue
#  - Rescale variables?
l_md[[5]] <- glmer(diff_S ~ (p.z + I(p.z^2))*(d.z + I(d.z^2)) + (d.z|SiteCode),
                   data=df_md,family="Gamma"(link="log"))
v_vars <- getME(l_md[[5]],c("theta","fixef"))
l_md[[5]] <- update(l_md[[5]],start=v_vars,control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
#######################
# Model failed to converge with max|grad| = 0.336616 (tol = 0.002, component 1)Model is nearly unidentifiable: very large eigenvalue
#  - Rescale variables?
l_md[[6]] <- glmer(diff_S ~ (p.z + I(p.z^2))*(d.z + I(d.z^2)) + (d.z + I(d.z^2)|SiteCode),
                   data=df_md,family="Gamma"(link="log"))
v_vars <- getME(l_md[[6]],c("theta","fixef"))
l_md[[6]] <- update(l_md[[6]],start=v_vars,control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
#######################
```

```{r l_md.diffS_EI_glmm,eval=FALSE}
l_md.diffS_EI_glmm <- l_md
save(l_md.diffS_EI_glmm,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diffS_EI_glmm.Rdata")
```

```{r AICctab l_md.diffS_EI_glmm}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diffS_EI_glmm.Rdata")
AICctab(l_md.diffS_EI_glmm,weights=TRUE)
```

  
Não foi possível ajustar os modelos com estrutura fixa mais complexa. Vou avaliar se GAMM oferecem melhor ajuste aos dados

### GAMM cheio

```{r diff_S MNEI GAMM cheio,eval=FALSE,echo=TRUE}
l_md <- vector("list",4)
names(l_md) <- c("tp by=k","cr by=k",
                 "tp ti","cr ti")
l_md[[1]] <- gam(diff_S ~ s(p.z,by=k,bs="tp") + 
                   s(SiteCode,bs="re"),
                 data=df_md,family = "Gamma"(link="log"))
l_md[[2]] <- gam(diff_S ~ s(p.z,by=k,bs="cr") + 
                   s(SiteCode,bs="re"),
                 data=df_md,family = "Gamma"(link="log"))
l_md[[3]] <- gam(diff_S ~ s(p.z,bs="tp") + s(d.z,bs="tp") + ti(p.z,d.z,bs=c("tp","tp")) +
                   s(SiteCode,bs="re"),
                 data=df_md,family = "Gamma"(link="log"))
l_md[[4]] <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                   s(SiteCode,bs="re"),
                 data=df_md,family = "Gamma"(link="log"))
```


```{r l_md.diff_S.EI__GAMM,eval=FALSE}
l_md.diff_S.EI__GAMM <- l_md
save(l_md.diff_S.EI__GAMM,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM.Rdata")
```

  
```{r AICctab modelos cheios diff_S EI GAMM}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM.Rdata")
AICctab(l_md.diff_S.EI__GAMM,weights=TRUE)
```


O único modelo cheio plausível considera as variáveis p e d (um smoother para cada mais um tensor para ambas) e 1 intercepto por Sítio de Amostragem.


```{r gamm cheio selecionado diff_S MNEI, warning=FALSE,message=FALSE}
appraise(l_md.diff_S.EI__GAMM[["cr ti"]])
```

__Figura 2.5__ Gráficos Diagnostico do gamm cheio mais plausível para diff_S MN==EI

De maneira geral o modelo esta fazendo um bom ajuste, contudo alguns sítios distoam do padrão geral dos dados. Há duas alternativas: i) possibilitar um smoother por sítio de amostragem com um parâmetro de penalização comum; ou ii) remover sítios outliers.

```{r update gamm cheio mais plausivel diff_S MNEI,eval=FALSE,echo=TRUE}
l_md <- vector("list",2)
names(l_md) <- c("1|Site","d|Site")
l_md[[1]] <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                   s(SiteCode,bs="re"),
                 data=df_md,family = "Gamma"(link="log"))
l_md[[2]] <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                   s(d.z,SiteCode,bs="fs",xt="cr"),
                 data=df_md,family = "Gamma"(link="log"))
```

  
```{r l_md.diff_S.EI__GAMM2,eval=FALSE}
l_md.diff_S.EI__GAMM2 <- l_md
save(l_md.diff_S.EI__GAMM2,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM2.Rdata")
```



```{r AICctab gamm cheio diff_S MNEI 2}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM2.Rdata")
AICctab(l_md.diff_S.EI__GAMM2)
```

```{r graf diag gamm2 diff_S MNEI}
gratia::appraise(l_md.diff_S.EI__GAMM2[["d|Site"]])
```

__Figura 2.6__ Gráfico Diagnóstico gamm cheio com segunda estrutra aleatória diff_S MM==EI

```{r diff_S MNEI modelo cheio avaliacao,message=FALSE,warning=FALSE,results="hide"}
gratia::draw(l_md.diff_S.EI__GAMM2[["d|Site"]])
```
  
__Figura 2.7__ gratia::draw() gamm mais plausível com estrutura similar a (d|Site)  
  
Este modelo apresenta problema de concurvidade. Assim vou refazer a comparação com configuração adequada:  

```{r updata gamm cheio mais plausível d Site,eval=FALSE,echo=TRUE}
df_md <- filter(df_resultados,MN=="EI")
md_gam.diff_S.EI__update <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                   s(d.z,SiteCode,bs="fs",xt=list(bs="cp"), m=1),
                 data=df_md,family = "Gamma"(link="log"))
```

```{r md_gam.diff_S.EI__update,eval=FALSE}
save(md_gam.diff_S.EI__update,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/md_diff_S_EI__GAMM_update.Rdata")
```


```{r draw update gamm cheio mais plausivel d Site}
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/md_diff_S_EI__GAMM_update.Rdata")
l_md.diff_S.EI__GAMM2[[2]] <- md_gam.diff_S.EI__update
gratia::draw(md_gam.diff_S.EI__update)
```

__Figura 2.8__ Update do modelo da figura 2.7 com o smoother da estrutura aleatória penalizada pela 1a derivada para diminuir a concurvidade (Perdersen et al. 2019)  

O modelo diminuiu a concurvidade da estimativa.
  
```{r  diff_S MNEI gamm cheio segundo plausivel,message=FALSE,warning=FALSE,results="hide",eval=FALSE}
gratia::appraise(md_gam.diff_S.EI__update)
```
  
![](/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/appraise_gamm_diffS_EI_updata.png){ width=100% }  

__Figura 2.9__ Appraise do gamm cheio atualizado (smoother de estrutura aleatória: m=1).  
  
### Remoção de Outliers

Remoção sítios com observações fora do intervalo [-1.5;1.5] dos resíduos deviance.  
  
```{r outliers diffS_MNEI gamm,eval=FALSE,echo=TRUE}
# dados completos
df_md <- df_resultados %>% filter(MN=="EI")
df_md$resDev <- residuals.gam(md_gam.diff_S.EI__update)
# sítios considerados outliers
v_SiteOut <- df_md %>% filter(resDev < -0.15 | resDev > 0.15) %>% .$SiteCode %>% unique
# update da comparação
l_md <- vector("list",2)
names(l_md) <- c("1|Site","d|Site")
l_md[[1]] <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                   s(SiteCode,bs="re"),
                 data=filter(df_md,!(SiteCode %in% v_SiteOut)),
                 family = "Gamma"(link="log"))
l_md[[2]] <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") + ti(p.z,d.z,bs=c("cr","cr")) +
                   s(d.z,SiteCode,bs="fs",xt=list(bs="cp"),m=1),
                 data=filter(df_md,!(SiteCode %in% v_SiteOut)),
                 family = "Gamma"(link="log"))
```

```{r l_md.diff_S.EI__GAMM_sOut,eval=FALSE}
l_md.diff_S.EI__GAMM_sOut <- l_md
save(l_md.diff_S.EI__GAMM_sOut,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM_sOut.Rdata")
```


```{r AICctab gamm cheio sem outliers,eval=TRUE}
load("/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM_sOut.Rdata")
AICctab(l_md.diff_S.EI__GAMM_sOut,weights=TRUE)
```

```{r appraise gamm diffS_EI sOut,eval=TRUE}
gratia::appraise(l_md.diff_S.EI__GAMM_sOut[["d|Site"]])
```

__Figura 2.10__ Gráficos diagnóstico do gamm cheio mais plausível sem outliers

A remoção de outliers não melhorou o ajuste do modelo.

```{r graw gamm cheio diffS_EI sOut,eval=FALSE}
gratia::draw(l_md.diff_S.EI__GAMM_sOut[["d|Site"]])
```

![](/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/draw_gamm_diffS_EIsOut_fig211.png){ width=100% }

__Figura 2.11__ Efeitos estimados para o gamm cheio diffS_EI sOut

### Seleção de Variáveis

```{r gamm diffS_EI selecao de variaveis, eval=FALSE}
# dados completos
df_md <- df_resultados %>% filter(MN=="EI")
df_md$resDev <- residuals.gam(md_gam.diff_S.EI__update)
# sítios considerados outliers
v_SiteOut <- df_md %>% filter(resDev < -0.15 | resDev > 0.15) %>% .$SiteCode %>% unique
# update da comparação
l_md <- vector("list",4)
names(l_md) <- c("p + d + ti(p,d)","p + d","p","d")
l_md[[1]] <- l_md.diff_S.EI__GAMM_sOut[["d|Site"]]
l_md[[2]] <- gam(diff_S ~ s(p.z,bs="cr") + s(d.z,bs="cr") +
                   s(d.z,SiteCode,bs="fs",xt=list(bs="cp"),m=1),
                 data=filter(df_md,!(SiteCode %in% v_SiteOut)),
                 family = "Gamma"(link="log"))
l_md[[3]] <- gam(diff_S ~ s(p.z,bs="cr") +
                   s(d.z,SiteCode,bs="fs",xt=list(bs="cp"),m=1),
                 data=filter(df_md,!(SiteCode %in% v_SiteOut)),
                 family = "Gamma"(link="log"))
l_md[[4]] <- gam(diff_S ~ s(d.z,bs="cr") +
                   s(d.z,SiteCode,bs="fs",xt=list(bs="cp"),m=1),
                 data=filter(df_md,!(SiteCode %in% v_SiteOut)),
                 family = "Gamma"(link="log"))
```

```{r l_md.diffS_EI_GAMM_selVars, eval=FALSE}
l_md.diffS_EI_GAMM_selVars <- l_md
save(l_md.diffS_EI_GAMM_selVars,file="/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM_sOut.Rdata")
```

```{r l_md.diffS_EI_GAMM_selVars AICctab,eval=FALSE}
load("/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_diff_S_EI__GAMM_sOut.Rdata")
AICctab(l_md.diffS_EI_GAMM_selVars,weights=TRUE)
```


## Figura Final

```{r gamm diff_S predicao novo conjunto de dados,eval=FALSE}
l_p <- list()
# dados
## MNEE
df_md <- df_resultados %>% filter(MN=="EE")
md_diffS_EE <- lm(diff_S0 ~ 1,data=df_md)
coef_diffS_EE <- summary(md_diffS_EE)$coef
coef_diffS_EE[2]
l_p[[1]] <- ggplot(df_md,aes(y=diff_S0,x="")) + geom_jitter() + stat_summary(fun.data = "mean_cl_boot", colour = "red")
  
## MNEI
df_pred <- df_pred <- expand.grid(SiteCode=levels(df_resultados$SiteCode)[1],
                       d.z=seq(min(df_resultados$d.z),max(df_resultados$d.z),length=20),
                       p.z=seq(min(df_resultados$p.z),max(df_resultados$p.z),length=103))
df_pred <- cbind(df_pred,
                 predict(l_md.diff_S.EI__GAMM_sOut[["d|Site"]],df_pred,type="response",se.fit=TRUE)) %>% 
  mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
         d = d.z * sd(df_resultados$d) + mean(df_resultados$d),
         fit_diff_S0 = fit - min(df_resultados$diff_S0) - 0.01,
         se.fit_diff_S0 = se.fit - min(df_resultados$diff_S0) - 0.01,)
df_pred$fit_diff_S0 %>% summary
l_p[[2]] <- ggplot(df_pred,aes(x=p,y=d,fill=fit)) + geom_tile()
```


# 3 U 

## Padrões Gerais  
  
__figura 4.1 __ U ~ padrões gerais  
  

```{r padroes gerais U,warning=FALSE,message=FALSE}
# graficos
l_p <- vector("list",4)
l_p[[1]] <- ggplot(df_resultados,aes(x=k,y=U_med)) +
  geom_point() +
  geom_line(aes(group=SiteCode)) +
  geom_boxplot(aes(group=k))
l_p[[2]] <- ggplot(df_resultados,aes(x=p,y=U_med)) +
  geom_point() +
  geom_smooth(method = "auto") +
  labs(y="")
l_p[[3]] <- ggplot(df_resultados,aes(x=log(Stotal),y=U_med)) +
  geom_point() +
  geom_smooth(method = "auto")
l_p[[4]] <- ggplot(df_resultados,aes(x=p,y=log(Stotal))) +
  geom_point() +
  geom_smooth(method="auto")
do.call("grid.arrange",c(l_p,ncol=2))
```

__Figura 4.2__ U ~ d (~SiteCode)

```{r figura 42 U d Site,fig.height=45,fig.width=8}
df_plot <- df_resultados %>% 
  filter(MN=="EE") %>% 
  mutate(title = paste0(SiteCode," p=",round(p,3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
df_plot %>% ggplot(aes(x=d,y=U_med)) +
  geom_point(alpha=0.3) + theme_light() +
  facet_wrap(~title,ncol=4,scales="free")
```


## GAMM

```{r selecao de variavel de dispersao modelo cheio GAMM(U),eval=FALSE}
ctrl <- list(nthreads=3) #número de cores para paralelizar
l_md.U <- vector("list",length = 20)
names(l_md.U) <- c("d/L id normal","d/L log normal", "d/L inverse normal", "d/L log gamma", "d/L inverse gamma",
                   "1-k id normal","1-k log normal", "1-k inverse normal", "1-k log gamma", "1-k inverse gamma",
                   "k id normal","k log normal", "k inverse normal", "k log gamma", "k inverse gamma",
                   "d id normal","d log normal", "d inverse normal", "d log gamma", "d inverse gamma")
# d/L
l_md.U[[1]] <- gam(U_med ~ s(d_Lplot.z) + s(p.z) + ti(d_Lplot.z,p.z) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family="gaussian",
                data = df_resultados.U, method = "REML",control=ctrl)
l_md.U[[2]] <- gam(U_med ~ s(d_Lplot.z) + s(p.z) + ti(d_Lplot.z,p.z) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=gaussian(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md.U[[3]] <- gam(U_med ~ s(d_Lplot.z) + s(p.z) + ti(d_Lplot.z,p.z) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=gaussian(link = "inverse"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md.U[[4]] <- gam(U_med ~ s(d_Lplot.z) + s(p.z) + ti(d_Lplot.z,p.z) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md.U[[5]] <- gam(U_med ~ s(d_Lplot.z) + s(p.z) + ti(d_Lplot.z,p.z) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "inverse"),
                data = df_resultados.U, method = "REML",control=ctrl)
# k_1
l_md.U[[6]] <- gam(U_med ~ s(k_1.z) + s(p.z) + ti(k_1.z,p.z) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family="gaussian",
                data = df_resultados.U, method = "REML",control=ctrl)
l_md.U[[7]] <- gam(U_med ~ s(k_1.z) + s(p.z) + ti(k_1.z,p.z) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=gaussian(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md.U[[8]] <- gam(U_med ~ s(k_1.z) + s(p.z) + ti(k_1.z,p.z) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=gaussian(link = "inverse"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md.U[[9]] <- gam(U_med ~ s(k_1.z) + s(p.z) + ti(k_1.z,p.z) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md.U[[10]] <- gam(U_med ~ s(k_1.z) + s(p.z) + ti(k_1.z,p.z) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "inverse"),
                data = df_resultados.U, method = "REML",control=ctrl)
# k.f
l_md.U[[11]] <- gam(U_med ~ s(p.z,k,bs="fs") + k +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family="gaussian",
                data = df_resultados.U, method = "REML",control=ctrl)
l_md.U[[12]] <- gam(U_med ~ s(p.z,k,bs="fs") + k +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=gaussian(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md.U[[13]] <- gam(U_med ~ s(p.z,k,bs="fs") + k +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=gaussian(link = "inverse"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md.U[[14]] <- gam(U_med ~ s(p.z,k,bs="fs") + k +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md.U[[15]] <- gam(U_med ~ s(p.z,k,bs="fs") + k +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "inverse"),
                data = df_resultados.U, method = "REML",control=ctrl)
# d
l_md.U[[16]] <- gam(U_med ~ s(d.z) + s(p.z) + ti(d.z,p.z) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family="gaussian",
                data = df_resultados.U, method = "REML",control=ctrl)
l_md.U[[17]] <- gam(U_med ~ s(d.z) + s(p.z) + ti(d.z,p.z) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=gaussian(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md.U[[18]] <- gam(U_med ~ s(d.z) + s(p.z) + ti(d.z,p.z) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=gaussian(link = "inverse"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md.U[[19]] <- gam(U_med ~ s(d.z) + s(p.z) + ti(d.z,p.z) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md.U[[20]] <- gam(U_med ~ s(d.z) + s(p.z) + ti(d.z,p.z) +
                  s(log_Stotal) +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "inverse"),
                data = df_resultados.U, method = "REML",control=ctrl)
AICctab(l_md.U,weights=TRUE)
l_md_U_selVar_disp_1Site <- l_md.U 
save(l_md_U_selVar_disp_1Site,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_U_selVar_disp_1Site.Rdata")


############### exemplo de código para estrutura aleatoria mais complexa
# l_md[[3]] <- gam(U_med ~ s(d.z,bs="tp") + s(p.z,bs="tp") + ti(d.z,p.z,ns=c("tp","tp")) +
#                   s(log_Stotal,bs="tp") +
#                   s(d.z,by=SiteCode,bs="tp",m=1)
#                   s(SiteCode,bs="re"),
#                 family=gaussian(link = "log"),
#                 data = df_resultados.U, method = "REML",control=ctrl)
```


### Modelo Cheio: comparação estrutura aleatória

Variável de dispersão: d (como para n_nRef)

i) Na escala log a variável parece ser simetrica, então vou comparar a distribuição normal e gamma;    
ii) É possível apresentar 3 estruturas: a) 1|Site; b) d|Site, penalizacao comum; c) d|Site, penalizacao por Site [que não vou incluir a priori pelo custo computacional]  
iii) pelo menos 2 smoother type (tp,cr)  


```{r gamm cheio U_med,eval=FALSE}
ctrl <- list(nthreads=3)
l_md <- vector("list",8)
names(l_md) <- c("tp normal 1|Site","tp normal d|Site","cr normal 1|Site","cr normal d|Site",
                 "tp gamma 1|Site","tp gamma d|Site","cr gamma 1|Site","cr gamma d|Site")
### Gaussian
l_md[[1]] <- gam(U_med ~ s(d.z,bs="tp") + s(p.z,bs="tp") + ti(d.z,p.z,bs=c("tp","tp")) +
                  s(log_Stotal,bs="tp") +
                  s(SiteCode,bs="re"),
                family=gaussian(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md[[2]] <- gam(U_med ~ s(d.z,bs="tp") + s(p.z,bs="tp") + ti(d.z,p.z,bs=c("tp","tp")) +
                  s(log_Stotal,bs="tp") +
                  s(d.z,SiteCode,bs="fs",m=1,xt=list(bs="tp")),
                family=gaussian(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md[[3]] <- gam(U_med ~ s(d.z,bs="cr") + s(p.z,bs="cr") + ti(d.z,p.z,bs=c("cr","cr")) +
                  s(log_Stotal,bs="cr") +
                  s(SiteCode,bs="re"),
                family=gaussian(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md[[4]] <- gam(U_med ~ s(d.z,bs="cr") + s(p.z,bs="cr") + ti(d.z,p.z,bs=c("cr","cr")) +
                  s(log_Stotal,bs="cr") +
                  s(d.z,SiteCode,bs="fs",m=1,xt=list(bs="cr")),
                family=gaussian(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
### Gamma
l_md[[5]] <- gam(U_med ~ s(d.z,bs="tp") + s(p.z,bs="tp") + ti(d.z,p.z,bs=c("tp","tp")) +
                  s(log_Stotal,bs="tp") +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md[[6]] <- gam(U_med ~ s(d.z,bs="tp") + s(p.z,bs="tp") + ti(d.z,p.z,bs=c("tp","tp")) +
                  s(log_Stotal,bs="tp") +
                  s(d.z,SiteCode,bs="fs",m=1,xt=list(bs="tp")),
                family=Gamma(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md[[7]] <- gam(U_med ~ s(d.z,bs="cr") + s(p.z,bs="cr") + ti(d.z,p.z,bs=c("cr","cr")) +
                  s(log_Stotal,bs="cr") +
                  s(SiteCode,bs="re"),
                family=Gamma(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md[[8]] <- gam(U_med ~ s(d.z,bs="cr") + s(p.z,bs="cr") + ti(d.z,p.z,bs=c("cr","cr")) +
                  s(log_Stotal,bs="cr") +
                  s(d.z,SiteCode,bs="fs",m=1,xt=list(bs="cr")),
                family=Gamma(link = "log"),
                data = df_resultados.U, method = "REML",control=ctrl)
l_md_U_gammCheio <- l_md
AICctab(l_md)
save(l_md_U_gammCheio,file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_U_gammCheio.Rdata")
```


__Figura 4.3__ Graf Diag Gamm cheio mais plausível

```{r gamm cheio U_med graf diag} 
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/l_md_U_gammCheio.Rdata")
gratia::appraise(l_md_U_gammCheio[["cr gamma d|Site"]])
```




# 4 Comparação n_nRef e diff_S

__Figura 3.1__ Observado (pontos) e predito (linhas) para diffS e n_nRef (segunda linha no facet) em função de d*MN, por sítio de amostragem (primeira linha no facet).

```{r comparacao n_nRef e diff_S,fig.height=65,fig.width=11}
# dados
## MN=="EI"
### gamm diffS
load("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/md_diff_S_EI__GAMM_update.Rdata")
df_EI <- cbind(filter(df_resultados,MN=="EI"),
                 predict.gam(md_gam.diff_S.EI__update,type="response",se.fit=TRUE)) %>% 
  mutate(fit_diffS0 = fit + min(df_resultados$diff_S0) - 0.01)
### glmm nRef
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__MuMIn.Rdata")
df_EI$Pr_nRef <- predict(mdAvg_nRefEI__MuMIn,type="response")*100
## MN=="EI"
### gamm diffS
md_diffS_EE <- lm(diff_S0 ~ 1,data=filter(df_resultados,MN=="EE"))
df_EE <- filter(df_resultados,MN=="EE") %>% 
  mutate(fit_diffS0 = coef(md_diffS_EE))
### glmm nRef
load(file="~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__MuMIn.Rdata")
df_EE$Pr_nRef <- predict(mdAvg_nRefEE__MuMIn,type="response")*100
## conjunto completo
df_plot <- rbind.fill(df_EE,df_EI) %>%
  mutate(title = paste0(SiteCode, " p=",round(p,digits = 3))) %>% arrange(p)
df_plot$title <- factor(df_plot$title,levels = unique(df_plot$title))
df_plot <- rbind.fill(
  select(df_plot,title,d,MN,n_nRef,Pr_nRef) %>% 
    mutate(response_class = "nRef") %>% 
    rename(response_obs=n_nRef,fit_value=Pr_nRef),
  select(df_plot,title,d,MN,diff_S0,fit_diffS0) %>% 
    mutate(response_class = "diff_S") %>% 
    rename(response_obs=diff_S0,fit_value=fit_diffS0)
)
# gráficos
df_plot %>% #filter(title %in% unique(df_plot$title)[1:10]) %>% 
  ggplot(aes(x=d,y=response_obs,group=MN)) +
  geom_point(aes(color=MN),alpha=0.3) +
  geom_line(aes(y=fit_value,color=MN),alpha=0.3) +
  scale_color_manual(values=c("#FF0000", "#000000")) +
  facet_wrap(~title+response_class,ncol=6,scales="free") + labs(y="") +
  theme_light() + theme(legend.position="top")
```
  

    
      
__Figura 4.2__ |diffS| ~ n_nRef * k, subset=MNEI

```{r figura 32,fig.height=10,fig.width=7}
# dados  ,fig.height=10
df_plot <- df_resultados %>% filter(MN=="EI") %>% 
  mutate(modulo_diffS = abs(diff_S0))
# graficos
l_p <- list()
l_p[[1]] <- ggplot(df_plot,aes(x=d,y=modulo_diffS)) + 
  # geom_boxplot(col="blue") +
  # geom_jitter(alpha=0.3)
  geom_point(alpha=0.3) + geom_smooth(method = "auto",se=FALSE,color="blue")
l_p[[2]] <- ggplot(df_plot,aes(x=d,y=n_nRef)) + 
  # geom_boxplot(col="blue") +
  # geom_jitter(alpha=0.3)
  geom_point(alpha=0.3) + geom_smooth(method = "auto",se=FALSE,color="blue")
l_p[[3]] <- df_plot %>% 
  mutate(logito_nRef = logit(n_nRef/100)) %>% 
  ggplot(aes(x=log(modulo_diffS),y=logito_nRef)) + 
  geom_smooth(method="lm",se=FALSE) +
  geom_point(alpha=0.3) + labs(title="logit( n_nRef/100 ) ~ log( |diffS| ) * k",
                               y="logit( n_nRef/100 )",x="log( |diffS| )") +
  facet_wrap(~k,ncol=4,scales="free")
# do.call("grid.arrange",c(l_p,ncol=1))
grid.arrange(l_p[[1]],l_p[[2]],l_p[[3]],
             layout_matrix=rbind(c(1,2),
                                 c(3,3),
                                 c(3,3)) )
```



__Figura 3.3__ n_nRef ~ |diffS| (~SiteCode), subset=MNEI

```{r figura 33,fig.width=8, fig.height=30}
# dados
df_plot1  <-  left_join(x=df_plot,
                       y=ddply(df_plot,"SiteCode",summarise,max_mod_diffS=max(modulo_diffS)),
                       by="SiteCode") %>% 
  arrange(max_mod_diffS) %>%
  mutate(title=paste0(SiteCode," max(|diffS|)=",round(max_mod_diffS,2) ) )
df_plot1$title <- factor(df_plot1$title,levels = unique(df_plot1$title))
# graficos
df_plot1 %>% ggplot(aes(x=log(modulo_diffS),y=n_nRef)) +
  geom_point(alpha=0.3) +
  ylim(0,100) + theme_light() + labs(title="n_nRef ~ (log( |diffS| ) | SiteCode)") + 
  facet_wrap(~title,ncol=4,scales="free_y")
```


## Comparação funções para o teste KS


```{r dados para auditoria , eval=FALSE}
# dados brutos
df_auditoria <- read.csv("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/df_raster_e_SAD_atualizados.csv",
                         header = TRUE,as.is = TRUE)
df_SAD.replicas <- read.csv("/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/resultados/df_replicas.csv",
                            header = TRUE,as.is = TRUE)
df_SAD_e_paisagem <- left_join(x=df_SAD.replicas,y=select(df_auditoria,-c(SAD_obs.name,SiteCode)),by=c("ordem","refID"))
# rank máximo
registerDoMC(3)
df_SAD_e_paisagem <- left_join(x=df_SAD_e_paisagem,
                               y=ddply(df_SAD_e_paisagem,c("SiteCode","k","MN"),function(X) max(c(X$S_SAD.predita,X$S_SAD.obs)),.parallel = TRUE),
                               by=c("SiteCode","k","MN"))
df_SAD_e_paisagem %<>% rename(max_rank=V1)
df_SAD_e_paisagem$SAD_MN.name <- gsub("./SADs_preditas/","/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/SADs_preditas/",df_SAD_e_paisagem$SAD_MN.name)
# dados de congruência
# level_k <- unique(as.character(df_SAD_e_paisagem$k))
# levels(df_SAD_e_paisagem$k)[19] <- "0.1"
df_SAD_e_paisagem$k <- as.character(df_SAD_e_paisagem$k)
df_SAD_e_paisagem$k[df_SAD_e_paisagem$k=="0.0999999999999999"] <- 0.1
df_SAD_e_paisagem$k <- factor(df_SAD_e_paisagem$k,levels=unique(df_SAD_e_paisagem$k)[c(19,20,18:1)])
df_SAD_e_paisagem$SiteCode <- factor(df_SAD_e_paisagem$SiteCode,levels=levels(df_resultados$SiteCode)) 
df_SAD_e_paisagem$MN <- factor(df_SAD_e_paisagem$MN,levels=levels(df_resultados$MN)) 
df_SAD_e_paisagem <- left_join(x=df_SAD_e_paisagem,
                               y=select(df_resultados,SiteCode,k,MN,n_nRef,modulo_diffS),
                               by=c("SiteCode","k","MN"))
# auditoria valores de congruência
registerDoMC(3)
df_auditoria <- df_SAD_e_paisagem %>%  
  mutate(diffS0 = (S_SAD.predita-S_SAD.obs)/S_SAD.obs,
         mod_diffS.aud = abs(diffS0)) %>% 
  inner_join(x=ddply(.,c("SiteCode","k","MN"),
                     summarise, 
                     KS.D_mean = mean(KS.D), KS.D_sd = sd(KS.D),KS.p_mean = mean(KS.p), KS.p_sd = sd(KS.p),
                     S_MNmean = mean(S_SAD.predita),S_MNsd = sd(S_SAD.predita),S_obs=head(S_SAD.obs,1),
                      mod_diffSmean=mean(mod_diffS.aud),mod_diffSsd=sd(mod_diffS.aud), diffS0mean=mean(diffS0),diffS0sd=sd(diffS0),
                     .parallel = TRUE),
             y=ddply(.,c("SiteCode","k","MN"),
                     function(x) nrow(x[x$KS.p >= 0.05,]),
                     .parallel = TRUE),
             by=c("SiteCode","k","MN")) %>% 
  rename(nRef = V1)
df_auditoria <- left_join(x=df_SAD_e_paisagem,
                          y=df_auditoria,
                          by=c("SiteCode","k","MN")) %>% 
  left_join(x=.,
            y=distinct(select(df_resultados,SiteCode,p,k,d)),
            by=c("SiteCode","k")) %>% 
  mutate(string_main=paste0("k=",k," d=",round(d,3),"\n nRef=",n_nRef,"; |diffS|=",round(mod_diffSmean,3),"; rankMax=",max_rank),
         string_mtext=paste0(SiteCode," MN==",MN," p=",round(p,3)) )
# 
levels_k <- df_auditoria$k %>% unique %>% as.numeric %>% sort() %>% as.character()
df_auditoria$k <- factor(df_auditoria$k,levels=levels_k[20:1])
```


```{r teste KS bootstrap,eval=FALSE}
# Dados
df_testeKS <- df_auditoria %>% 
  select(SAD_obs.name,SAD_MN.name,MN,k,rep,ordem,refID,SiteCode,txt.name,S_obs,p,d) %>%
  group_by(SAD_obs.name) %>% nest
df_testeKS$resultados <- vector("list",length = nrow(df_testeKS))
# rotina para a função
registerDoMC(3)
for(row_label in 1:nrow(df_testeKS)){
  # i <- 1
  df_ <- df_testeKS[row_label,]
  v_SAD.obs <- read.csv(df_$SAD_obs.name,header = TRUE,as.is = TRUE) %>% 
    filter(species.correct != "Mortas") %>% 
    .$N %>% sort()
  df_predicao <- as.data.frame(df_$data[[1]])
  f_KSeS <- function(v_obs = v_SAD.obs,path_MN){
    v_SAD.MN <- read.csv(file=path_MN,header = TRUE,as.is = TRUE)$SAD_predita
    teste <- ks_test(a=v_SAD.obs,b = v_SAD.MN,nboots = 3000)  
    a <- data.frame(D_KSboot=teste[1],p.valor_KSboot=teste[2])
    a$S_SAD.predita <- length(v_SAD.predita)
    a$S_SAD.obs <- length(v_SAD.obs) 
    return(a)
   }
  df_testeKS$resultados[[row_label]] <- adply(df_predicao,1,
                                              function(X) f_testeParallel(path_MN = X$SAD_MN.name),
                                              .parallel = TRUE)
}

df_replicas <- df_testeKS %>% select(-data) %>% unnest(cols = c(resultados)) %>% as.data.frame()
write.csv(df_replicas,file = "~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/resultados/df_replicas__2samples.csv",row.names = FALSE)
```
  
  
  
__Figura 3.4__ Comparação testes KS: pressupondo distribuição contínua (stats::ks.test) e por bootstrap (twosamples::ks_test)  
    
```{r figura 34 nRef KSboot, cache=TRUE}
df_replicasBoot <- read.csv("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/resultados/df_replicas__2samples.csv",
                        header = TRUE,as.is = TRUE)
registerDoMC(3)
df_nRef.KSboot <- df_replicasBoot %>% ddply(c("SiteCode","k","MN"),summarise,
                                           D.boot_mean = mean(D_KSboot),D.boot_sd = sd(D_KSboot),
                                           p.valor.boot_mean = mean(p.valor_KSboot),p.valor.boot_sd = sd(p.valor_KSboot),
                                           n_nRef_boot=sum(p.valor_KSboot>=0.05),
                                           .parallel = TRUE)
# comparação
level_k <- unique(as.character(df_nRef.KSboot$k))
df_nRef.KSboot$k <- factor(as.character(df_nRef.KSboot$k),levels = level_k[20:1])
# levels(df_nRef.KSboot$k)[19] <- "0.1"
df_ad <- inner_join(x=df_resultados,
                    y=df_nRef.KSboot,
                    by=c("SiteCode","k","MN"))
# graficos diagnostico
l_p <- list()
l_p[[1]] <- df_ad %>% ggplot(aes(x=D_mean,y=D.boot_mean)) + 
  geom_point() + 
  labs(x="dist. cont.",y="bootstrap", title="Média Estatística D")
l_p[[2]] <- df_ad %>% ggplot(aes(x=p.value_mean,y=p.valor.boot_mean)) + 
  geom_point() + 
  labs(x="dist. cont.",y="bootstrap", title="Média p-valor")
l_p[[3]] <- df_ad %>% ggplot(aes(x=sqrt(D_var),y=D.boot_sd)) + 
  geom_point() + 
  labs(x="dist. cont.",y="bootstrap", title="sd Estatística D")
l_p[[4]] <- df_ad %>% ggplot(aes(x=sqrt(p.value_var),y=p.valor.boot_sd)) + 
  geom_point() + 
  labs(x="dist. cont.",y="bootstrap", title="sd p-valor")
do.call("grid.arrange",c(l_p,ncol=2))
```
  
  
__figura 3.5__ número de SADs não refutadas: ks.test X ks_test  
  
```{r figura 35 nRef ks.test e ks_test}
df_ad %>% ggplot(aes(x=n_nRef,y=n_nRef_boot,col=MN)) + 
  geom_abline(slope = 1,intercept = 0,col="blue") +
  geom_point(alpha=0.3) + 
  scale_color_manual(values=c("#FF0000", "#000000")) +
  facet_wrap(~k,ncol=4)
```
  

## Visualização das SADs preditas e observadas

```{r painel de SADs, eval=FALSE}
### dados
# dados brutos
df_auditoria <- read.csv("~/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/df_raster_e_SAD_atualizados.csv",
                         header = TRUE,as.is = TRUE)
df_SAD.replicas <- read.csv("/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/resultados/df_replicas.csv",
                            header = TRUE,as.is = TRUE)
df_SAD_e_paisagem <- left_join(x=df_SAD.replicas,y=select(df_auditoria,-c(SAD_obs.name,SiteCode)),by=c("ordem","refID"))
# rank máximo
registerDoMC(3)
df_SAD_e_paisagem <- left_join(x=df_SAD_e_paisagem,
                               y=ddply(df_SAD_e_paisagem,c("SiteCode","k","MN"),function(X) max(c(X$S_SAD.predita,X$S_SAD.obs)),.parallel = TRUE),
                               by=c("SiteCode","k","MN"))
df_SAD_e_paisagem %<>% rename(max_rank=V1)
df_SAD_e_paisagem$SAD_MN.name <- gsub("./SADs_preditas/","/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/SADs_preditas/",df_SAD_e_paisagem$SAD_MN.name)
## 
df_SAD_e_paisagem$SiteCode <- factor(df_SAD_e_paisagem$SiteCode) 
df_SAD_e_paisagem$MN <- factor(df_SAD_e_paisagem$MN)
levels_k <- unique(df_SAD_e_paisagem$k) %>% sort %>% as.character()
df_SAD_e_paisagem$k <- factor(df_SAD_e_paisagem$k,levels = levels_k[20:1])
levels(df_SAD_e_paisagem$k)[19] <- "0.1"
#
df_ad$SiteCode <- factor(df_ad$SiteCode)
df_ad$MN <- factor(df_ad$MN)
df_auditoria <- left_join(x=df_SAD_e_paisagem,
                          y=select(df_ad,SiteCode,MN,k,d,p,n_nRef,n_nRef_boot),
                          by=c("SiteCode","MN","k"))
df_auditoria %<>%
  mutate(string_main=paste0("k=",k," d=",round(d,3),"\n ks.test::nRef=",n_nRef," ks_test::nRef=",n_nRef_boot),
         string_mtext=paste0(SiteCode," MN==",MN," p=",round(p,3)) )
### graficos
for(s in 1:length(levels(df_auditoria$SiteCode))){
  X <- df_auditoria %>% filter(SiteCode == levels(df_auditoria$SiteCode)[s])
  v_SADobs <- read.csv(X[1,"SAD_obs.name"],header = TRUE)[,"N"]
  # MNEE
  df_ <- X %>% filter(MN=="EE")
  png(paste0("/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/figuras/",
             levels(df_auditoria$SiteCode)[s],"_EE_SADs.png"),
      width = 980, height = 600)
  par(mfrow=c(4,5))
  for(K in 1:length(levels(df_$k))){
    df_k <- filter(df_,k==levels(df_$k)[K])
    plot(rad(v_SADobs),main=head(df_k$string_main,1),cex=0.5,
         xlim=c(1,head(df_$max_rank,1)))
    for(p in 1:nrow(df_k)){
      v_SAD_MN <- read.table(df_k[p,"SAD_MN.name"],header = TRUE,as.is = TRUE)$SAD_predita
      lines(rad(v_SAD_MN),type="l",col=rgb(0.25, 0.25, 0.25, 0.25))
    }
    lines(rad(v_SADobs),pch = 19, col="red",cex=0.5,bg="black",type="b",
           main=head(df_k$string_main,1))
  }
  dev.off()
  # MNEI
  df_ <- X %>% filter(MN=="EI")
  png(paste0("/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/simulacao/figuras/",
             levels(df_auditoria$SiteCode)[s],"_EI_SADs.png"),
      width = 980, height = 600)
  par(mfrow=c(4,5))
  for(K in 1:length(levels(df_$k))){
    df_k <- filter(df_,k==levels(df_$k)[K])
    plot(rad(v_SADobs),main=head(df_k$string_main,1),cex=0.5,
         xlim=c(1,head(df_$max_rank,1)))
    for(p in 1:nrow(df_k)){
      v_SAD_MN <- read.table(df_k[p,"SAD_MN.name"],header = TRUE,as.is = TRUE)$SAD_predita
      lines(rad(v_SAD_MN),type="l",col=rgb(0.25, 0.25, 0.25, 0.25))
    }
    lines(rad(v_SADobs),pch = 19, col="red",cex=0.5,type="b",
           main=head(df_k$string_main,1))
  }
  dev.off()
}
```




Inspeção individual das SADs



  
__Estratégia__  
  
i) estrutura do tipo:  
  
cbind(n_nRef,100-n_nRef) ~ log(modulo_diffS) * d + ( log(modulo_diffS) * d | SiteCode)  
  
ii) expectativa:  
  
a) esperavamos que se o teste é adequado então deve existir um erro de estimativa da riqueza máximo no qual a probabilidade de não se refutar uma SAD se torna muito diminuta.  
b) e uma vez que não é suficiente apresentar boa estimativa da riqueza para apresentar boa congruência, então esperava que a nuvem de pontos pudesse ser aproximada por um triangulo retangulo com angulo reto na origem. 
  
```{r nRef por modulo_diffS md cheio,cache=TRUE}
# para usar a escala log:
l_md <- vector("list",5)
names(l_md) <- c("log(modulo_diffS) * d.z | SiteCode",
                 "log(modulo_diffS) + d.z | SiteCode",
                 "log(modulo_diffS) | SiteCode",
                 "d.z | SiteCode",
                 "1 | SiteCode")
l_md[[1]] <- glmer(cbind(n_nRef,100-n_nRef) ~ log_modulo_diffS.z * (d.z + I(d.z^2)) + ( log_modulo_diffS.z * (d.z + I(d.z^2)) | SiteCode),
                   family = "binomial", data=df_resultados.EI,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[2]] <- glmer(cbind(n_nRef,100-n_nRef) ~ log_modulo_diffS.z * (d.z + I(d.z^2)) + ( log_modulo_diffS.z + (d.z + I(d.z^2)) | SiteCode),
                   family = "binomial", data=df_resultados.EI,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[3]] <- glmer(cbind(n_nRef,100-n_nRef) ~ log_modulo_diffS.z * (d.z + I(d.z^2)) + ( log_modulo_diffS.z| SiteCode),
                   family = "binomial", data=df_resultados.EI,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[4]] <- glmer(cbind(n_nRef,100-n_nRef) ~ log_modulo_diffS.z * (d.z + I(d.z^2)) + ( (d.z + I(d.z^2)) | SiteCode),
                   family = "binomial", data=df_resultados.EI,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
l_md[[5]] <- glmer(cbind(n_nRef,100-n_nRef) ~ log_modulo_diffS.z * (d.z + I(d.z^2)) + ( 1 | SiteCode),
                   family = "binomial", data=df_resultados.EI,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)))
AICctab(l_md,weights=TRUE)
```

```{r figura 34 nRef por modulo_diffS diag,fig.height=25,fig.width=8}
p_plot <- simulateResiduals(l_md[["log(modulo_diffS) * d.z | SiteCode"]],n = 1000)
# plot(p_plot)
df_plot <- df_resultados.EI %>% 
  select(SiteCode,n_nRef,log_modulo_diffS.z,d.z) %>% 
  mutate(quantile_res = p_plot$scaledResiduals,
         pearson_res = resid(l_md[["log(modulo_diffS) * d.z | SiteCode"]],type="pearson"),
         predict_ = predict(l_md[["log(modulo_diffS) * d.z | SiteCode"]]))
df_plot %>% 
  ggplot(aes(x=predict_,y = pearson_res)) +
    geom_abline(intercept = 0,slope = 0,color="red") +
    geom_smooth(method = "auto",color="blue",se=FALSE) +
    geom_point(alpha=0.4) +
    facet_wrap(~SiteCode,ncol=4,scales="free")
# df_resultados %>% filter(SiteCode == "MGlavr3") %>% summary
```

```{r}
# lme4::(l_md[["log(modulo_diffS) * d.z | SiteCode"]])
```

# 5 Determinação da escala espacial da paisagem local

__Figura 5.1_ log(S_obs) ~ p + offset(Ntotal)  
  
```{r df_se figura 51}
# dados
df_se <- read.csv("/home/danilo/Documentos/Doutorado/artigo_mestrado/1A.P_MOVER/df_ScaleEffect.csv",header = TRUE,as.is = TRUE)
df_se$raio_km <- factor(df_se$raio_km,levels = unique(df_se$raio_km))
# graficos exploratórios
# l_p <- list()
l_p[[1]] <- df_se %>% ggplot(aes(x=p,y=S_obs)) +
  geom_point(alpha=0.3,aes(size=Ntotal)) +
  facet_wrap(~raio_km,ncol=3) + theme(legend.position = "bottom")
l_p[[1]]
# l_p[[2]] <- df_se %>% select(Ntotal) %>% distinct %>% ggplot(aes(x="",y=Ntotal)) + 
#   geom_boxplot() + 
#   geom_jitter() + 
#   labs(x="")
# l_p[[3]] <- df_se %>% select(S_obs) %>% distinct %>% ggplot(aes(x="",y=S_obs)) + 
#   geom_boxplot() + 
#   geom_jitter() + 
#   labs(x="")
```

A média e variância de S_obs não apresenta valores próximos `r mean(df_se$S_obs)/var(df_se$S_obs)`, mostrando que os dados apresentam over-dispersion. Assim irei utilizar a distribuição binomial negativa com Ntotal como offset.

```{r ajuste de modelos aos dados}
library(MASS)
# data_ <- df_se %>% filter(raio_km == levels(df_se$raio_km)[1])
f_glm.nb <- function(data_){
  md_ <- glm.nb(S_obs ~ p + I(p^2) + offset(log(Ntotal)), data = data_)
}
registerDoMC(2)
l_md <- dlply(df_se,"raio_km",f_glm.nb,.parallel = TRUE)
names(l_md) <- paste0("raio = ",levels(df_se$raio_km),"km")
AICctab(l_md,weights=TRUE)
par(mfrow=c(2,2))
p_plot <- simulateResiduals(l_md[["raio = 2.3km"]],n = 1000)
plot(p_plot)
plot(l_md[["raio = 2.3km"]])

```

Não há um único modelo mais plausível, então vou aumentar a resolução 


