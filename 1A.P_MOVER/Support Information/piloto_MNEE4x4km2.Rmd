---
title: "Piloto de MNEE em paisagens de 4x4km2"
author: ""
date: '2022-03-19'
output: 
  html_document:
    toc: true
    toc_depth: 5
editor_options: 
  chunk_output_type: inline
---

<style>
body {
text-align: justify}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, tidy = FALSE, include = TRUE, warning = FALSE,cache = TRUE,message=FALSE,eval=TRUE)
knitr::opts_knit$set(root.dir = "/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/")
setwd("/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/")
```

```{r pacotes,warning=F}
library(sads)
library(ggpubr)
library(imager)
library(OpenImageR)
library(cowplot)
library(twosamples)
library(doMC)
library(raster)
library(GUILDS)
library(bbmle)
library(magrittr)
library(gridExtra)
library(ggplot2)
library(readr)
library(purrr)
library(stringr)
library(tidyr)
library(plyr)
library(dplyr)
select <- dplyr::select
```


## Plano do Piloto

- amostrar 30 sítios ao longo do gradiente de cobertura vegetal. - FEITO  

- trabalhar no raster dos sítios amostrados. - PRÓXIMO  

- organizar as pastas e revisar a funcionalidade do programa coalescente (simulação coalescente).  

- 1o sub-piloto: estimar a taxa U  

- 2o sub-piloto: predizer as SADs  

- calcular a diferença entre as respostas atuais e anteriores  

- descrever a diferença por um modelo gaussiano misto  

- Estudo das equações de conversão de parâmetros: validar com uma simulação espacialmente explícita:  

1) fazer a estimativa de m para os sítios amostrados a partir de uma simulação espacialmente explícita que desconsidera a perda de habitat (referência).  

2) calcular a taxa m’ usando a proposta do Coutinho e minha (olhar e-mail do encaminhamento 1) e usando a que eu fiz (pretendo implementar usando integração de Monte Carlo).  

- Simular as SADs preditas por MNEI (eu fiz uma primeira pesquisa, e a fórmula de amostragem de Etienne 2005 está mais atualizado no pacote GUILDS ao invés do pacote untb).   

### Sortear sítios ao longo do gradiente de cobertura vegetal 

```{r dados,message=FALSE}
### dados ###
# leitura
df_resultados <- read.csv(file="/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/simulacao_codigos_e_resultados/resultados/df_resultados.csv",
                            header = TRUE,as.is=FALSE)[,1:13]
# padronização
level_k <- as.character(unique(sort(as.numeric(df_resultados$k),decreasing = TRUE)))
df_resultados$k <- factor(df_resultados$k,levels = level_k)
levels(df_resultados$k)[19] <- "0.1"
# z score
f_z <- function(x){
  m <- base::mean(x,na.rm=FALSE)
  sd <- sd(x,na.rm=FALSE)
  output <- (x-m)/sd
  return(output)
} 
# names(df_resultados)
# str(df_resultados)
df_resultados %<>% mutate(diffS_gamma = diffS_mean + min(diffS_mean)*(-1) + 0.01,
                          modulo_diffS = abs(diffS_mean),
                          log_Sobs=log(S_obs))

df_resultados.z <- as.data.frame(apply(df_resultados[,c("p","Ntotal","log_Sobs","k_1","d_Lplot","d","modulo_diffS")],2,f_z))
names(df_resultados.z) <- sapply(names(df_resultados.z), function(x) paste0(x,".z"))
df_resultados %<>% cbind(.,df_resultados.z) %>% 
  select(-k_1,-k_1.z)
```

# Ap Final BIE 5770

```{r gráficos}
#
df_SADs.disponiveis <- read.csv(
  "/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/dados_para_iniciar_artigo/df_SADs_disponiveis.csv",
  header =T)
df_SADs.disponiveis %<>% 
  filter(method=="parcelas" &
           grepl("*contiguous*",arrangement) & 
           effort_ha>=1 &
           grepl("*yes*",status) & 
           grepl("ok*",status_diagnostico) &
           grepl("Atlantic_Forest*",domain) &
           dbh_cutoff %in% c("PBH>=15.0cm","PBH>=15.7cm",
                             "DBH>=5.0cm","DGH>=5.0cm","DBH>5.0cm",
                             "DBH>=4.8cm",
                             "DBH>=5.0cm&H>300cm","DBH>=5.0cm&H>500cm", 
                             "DGH30>=5.0cm")
         )
# df_SADs.disponiveis %>%
#   select(status_diagnostico:effort_ha) %>% 
#   select(-c(state,samples))


## dados disponíveis: usando landsat8 (ano referência 2000)
df_S1 <- read.csv("/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/resultados_e_SI/tabelaSI1.csv",
                  header = TRUE) %>% 
  mutate(year_plot = ifelse(is.na(year_data),year,year_data))
df_S1$year_plot[df_S1$year_plot=="2012_2013"] <- "2012.5"
df_S1$year_plot <- as.numeric(df_S1$year_plot)
### Filtros usados
### filtro universidades e campi
# df_filtro.UC <- df_1ofiltro %>% 
#   filter(UC_area_ha >= 1000 | 
#          Unidade_de_conservacao %in% c("UC Protecao Integral","universities and research centers"))
# ### filtro estados
# df_filtro.estate <- filter(df_1ofiltro,state %in% c("RJ","RS") & year >= 1990)
# df_filtro.estate %<>% rbind(.,filter(df_1ofiltro,state %in% c("BA","GO","MS") & year >= 2000))
# df_filtro.estate %<>% rbind(.,filter(df_1ofiltro,!(state %in% c("BA","GO","MS","RJ","RS")) & year >= 1995))
df_S1$site_category <- NA
df_S1$site_category[df_S1$UC_area_ha>=1000 | 
                      df_S1$Unidade_de_conservacao %in% 
                      c("UC Protecao Integral","universities and research centers")] <- 1
df_S1$site_category[df_S1$state %in% c("RJ","RS") & 
                      df_S1$year >= 1990] <- 2
df_S1$site_category[df_S1$state %in% c("BA","GO","MS") & 
                      df_S1$year >= 2000] <- 3
df_S1$site_category[!(df_S1$state %in% c("BA","GO","MS","RJ","RS")) & 
                      df_S1$year >= 1995] <- 4
df_S1 %>%
  mutate(site_category = factor(site_category)) %>% 
  ggplot(aes(x=year_plot,y=site_category,shape=site_category)) +
  # geom_vline(xintercept = 2000,color="red") + # versão 1
  geom_vline(aes(xintercept = year_plot),color="red",alpha=0.3) + # versão 2
  # geom_boxplot() +
  geom_jitter() +
  labs(shape="Categorias:",
       y="categoria inventário florestal",
       x="ano inventário florestal",
       title= "104 inventários dentro dos critérios (de 109 confiáveis)") +
  scale_shape_discrete(breaks=c("1","2","3","4"),
                       labels=c("todas as idades: \nUC Prot. Int. | Univ. | UC>=1000 ha",
                                "RJ e RS >= 1990",
                                "BA, GO e MS >= 2000",
                                "outros estados Brasil >= 1995")) +
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
# df_S1 %>% arrange(year_plot) %>% select(year_plot,UC_area_ha,state)
```
```{r}
df_S2 <- read.csv("/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/resultados_e_SI/tabelaSI2.csv",
                  header = TRUE) %>% 
  mutate(year_plot = ifelse(is.na(year_data),year,year_data))
df_S2$year_plot[df_S2$year_plot=="2012_2013"] <- "2012.5"
df_S2$year_plot <- as.numeric(df_S2$year_plot)
df_S2$site_category <- "1"
df_S2 %>%
  mutate(site_category = factor(site_category)) %>% 
  ggplot(aes(x=year_plot,y=site_category,shape=site_category)) +
  geom_vline(aes(xintercept = year_plot),color="red",alpha=0.6) + # versão 2
  # geom_boxplot() +
  geom_jitter() +
  labs(shape="",
       y="",
       x="ano inventário florestal",
       title= "109 inventários com SAD e coordenada confiáveis") +
  scale_shape_discrete(breaks="") +
                       # labels="- Atlantic Forest \n- DBH >= 5.0cm \n- plot >= 1ha") +
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
```

# Ap Final BIE 5770

# Piloto

Plano:  
  
1) amostrar 30 pontos de uma uniforme de 0 a 1  

2) subtrair, para cada ponto sorteado em 1, a proporção de cobertura vegetal observada (coluna 'p')  

3) selecionar, para cada ponto sorteado em 1, aquele que obteve menor diferença em 2  


```{r df_piloto}
f_random_byVar <- function(x = df_resultados,
                           column_name = "p", 
                           n_sample = 30, 
                           i_seed = 260320223){
  # amostragem de uma uniforme
  set.seed(i_seed)
  sample_points <- sort(runif(n = n_sample, min = 0, max = 1))
  # encontrar os valores mais próoximos
  df_x <- filter(x,k==levels(x$k)[1],MN=="EE")
  f_index <- function(X=df_x,
                      name=column_name,
                      v_ref){
    which.min(abs(X[[column_name]] - v_ref))
  }
  # remover os sítios repetidos
  v_sites <- df_x[sapply(sample_points,function(y) f_index(v_ref=y)),"SiteCode"] %>% unique
  df_return <- filter(x,SiteCode %in% v_sites,MN=="EE")
  df_return$SiteCode <- factor(df_return$SiteCode)
  return(df_return)
}
df_piloto <- f_random_byVar(x=df_resultados)
write.csv(df_piloto,file = "df_piloto.csv",row.names = FALSE)
```


```{r graficos df_piloto,echo=FALSE}
df_piloto <- read.csv(file="df_piloto.csv", header = TRUE)
# gráficos exploratóritos
df_piloto %>% 
  filter(k==unique(df_piloto$k)[1]) %>% 
  ggplot(aes(x=p,y=S_obs)) + 
  geom_point() +
  ggtitle(label="Sítios Sorteados") +
  labs(x="% Tree cover (p)",y="Species Richness")
```

NOTA :: Mapas de cobertura vegetal para os trabalhos pilotos

É suficiente recortar os atuais mapas de 10x10km2 para mapas de 4x4km2,
pois sempre é aplicado uma função que impõe que a densidade de pixels é igual à densidade de indivíduos na área amostral. 
Portanto, posso pular o trabalho com os mapas de cobertura vegetal e apenas fazer o recorte. Porém, como se estima
o recorte certo? Todos tem as mesmas dimensões, mas mudam na resolução. Podemos usar uma regra de três simples
aplicada ao número de colunas e linhas: se x colunas correspondem à 10km quanto corresponde à 4? 

#### Análise de Escala de Efeito:


a) calculo de p para cada valor de raio;  
b) ajuste de glm.nb para cada conjunto de dados;  
c) média ponderada pelo peso de evidência da comparação de todos os glm.nb ajustados.  

  
```{r janela de codigo 2 _ scale of effect, echo=TRUE,results="hide",eval=FALSE,cache=TRUE}
# dados brutos
df_dados <- read.csv("/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/resultados_e_SI/tabelaSI1.csv",header = TRUE)
#
df_se <- left_join(y=df_dados,
                   x=expand.grid(SiteCode = df_dados$SiteCode,
                                 raio_km = c(seq(sqrt(max(df_dados$effort_ha)*0.01)+0.1,
                                               12,by = 0.1),12) ),
                   by="SiteCode") %>% 
  group_by(tif.name) %>% nest()
df_se$resultado <- vector("list",length = nrow(df_se))
# rotina
registerDoMC(2)
for(i in 1:nrow(df_se)){
  # raster de paisagem (landsat8 Hansen et al. 2013)
  raster_ <- raster(df_se$tif.name[i])
  mat_raster <- matrix(data = getValues(raster_)/100)
  dim(mat_raster) <- dim(raster_)[1:2]
  # função para o calculo da cobertura da paisagem local
  f_p <- function(raio_KM){
    # 1 pixel = 30x30m
    # raio = metade do lado da paisagem local
    raio_pixels <- round(raio_KM * 1000 / 30)
    raio_max <- nrow(mat_raster)/2
    local_land <- mat_raster[(raio_max+1-raio_pixels):(raio_max+raio_pixels),
                             (raio_max+1-raio_pixels):(raio_max+raio_pixels)]
    # proporção de cobertura vegetal
    v_p <- sum(local_land,na.rm = NULL)/length(local_land)
    # para cada raio há a proporção de cobertura calculada e o raio efetivo que depende do tamanho do pixel
    df_ <- data.frame(p=v_p,raio_efetivo.KM=raio_pixels*30/1000)
    return(df_)
  }
  # dados para a f_p
  df_se$resultado[i][[1]] <- adply(df_se$data[i][[1]]$raio_km,1,f_p,.id = NULL,.parallel = TRUE)
}
# dados por raio
df_se %<>% unnest(cols = c(data,resultado)) %>% as.data.frame()
write.csv(df_se,file="/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/resultados_e_SI/df_escalaEfeito.csv",row.names = FALSE)
```


```{r estatisticas descritivas da variacao em p entre escalas,echo=FALSE}
df_se <- read.csv(file="/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/resultados_e_SI/df_escalaEfeito.csv",header = T)
df_se %>% ddply(.,"SiteCode",summarise,
                p_mean = mean(p), 
                p_var = var(p)) %>% 
  mutate(p_coef = sqrt(p_var)/p_mean) %>% 
  # arrange(p_coef) %>% tail
  ggplot(aes(x=p_coef,y=)) + geom_density() + #bins=60 
  ggtitle(label="coeficiente de variação da variavel p entre as extensões espaciais")
```


```{r selecao da escala espacial, echo=TRUE}
df_se <- read.csv(file="/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/resultados_e_SI/df_escalaEfeito.csv",header = T)
# ajuste de modelos aos dados
library(MASS)
f_glm.nb <- function(data_){
  md_ <- glm.nb(S_obs ~ p + I(p^2) + offset(log(Ntotal)), data = data_)
}
registerDoMC(3)
l_md <- dlply(df_se,"raio_km",f_glm.nb,.parallel = TRUE)
# média ponderada dos raios pelo peso de evidência
df_averageSE <- print(AICctab(l_md,weights=TRUE)) %>% 
  as.data.frame()
df_averageSE$raio_paisagem <- row.names(df_averageSE) %>% as.numeric()
df_averageSE$weight <- as.numeric(as.character(df_averageSE$weight))
df_averageSE$dAICc <- as.numeric(as.character(df_averageSE$dAICc))
# (raio_medio <- round(weighted.mean(x = df_averageSE$raio_paisagem,w = df_averageSE$weight),1))  
raio_medio <- mean(df_averageSE %>% filter(dAICc==0) %>% .$raio_paisagem)
df_averageSE %>% 
  # mutate(diff_moda = max(df_averageSE$weight) - weight) %>% 
  # filter(diff_moda < 0.0005) %>% dim
  ggplot(aes(x=raio_paisagem,y=weight)) +
  geom_line() + 
  geom_vline(xintercept = raio_medio,color="red",alpha=0.5) + 
  annotate(geom="text",x=raio_medio+1.3,y=0.002,label=paste0("raio médio = ",raio_medio," km"),size=3) +
  theme_classic()
```

O raio médio = `r raio_medio` (2.07) e portanto o lado da paisagem é de `r 2*raio_medio`km e área total de 1713.96 hectares  
  
O lado anterior é de 10.2x10.2, o lado atual é 4.14x4.14.

```{r recorte das paisagens para piloto,echo=FALSE}
df_piloto <- read.csv(file="df_piloto.csv", header = TRUE)
df_sims <- read.csv("/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/simulacao_codigos_e_resultados/df_simulacao.csv",
                    header = TRUE) %>% 
  filter(SiteCode %in% unique(df_piloto$SiteCode)) %>% 
  select(!(J_M:theta))

f_tree.cover <- function(file_path){
  mat_paisagem <- read.table(file=file_path,sep=" ",header=TRUE)
  tree.cover <- as.vector(mat_paisagem)
  tree.cover <- tree.cover[!is.na(tree.cover)]
  p <- 1 - length(tree.cover[tree.cover==0])/length(tree.cover)
  return(p)
}
# estudo funcao
file_path <- df_sims$txt.name[1]
mat_paisagem <- read.table(file=file_path,sep=" ",header=TRUE) %>% 
  as.matrix
# image(mat_paisagem)
dim(mat_paisagem)[1]


```
  

