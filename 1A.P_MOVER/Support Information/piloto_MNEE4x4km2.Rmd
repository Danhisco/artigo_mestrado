---
title: "Piloto de MNEE em paisagens de 4x4km2"
author: ""
date: '2022-03-19'
output: 
  html_document:
    toc: true
    toc_depth: 5
editor_options: 
  chunk_output_type: console
---

<style>
body {
text-align: justify}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, tidy = FALSE, include = TRUE, warning = FALSE,cache = TRUE,message=FALSE,eval=TRUE)
knitr::opts_knit$set(root.dir = "/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/")
setwd("/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/piloto_MNEE_4x4km/")
```

```{r pacotes,warning=F}
library(sads)
library(ggpubr)
library(imager)
library(OpenImageR)
library(cowplot)
library(twosamples)
library(doMC)
library(raster)
library(GUILDS)
library(bbmle)
library(magrittr)
library(gridExtra)
library(ggplot2)
library(readr)
library(purrr)
library(stringr)
library(tidyr)
library(plyr)
library(dplyr)
select <- dplyr::select
```


## Plano do Piloto

- amostrar 30 sítios ao longo do gradiente de cobertura vegetal. - FEITO  

- trabalhar no raster dos sítios amostrados. - PRÓXIMO  

- organizar as pastas e revisar a funcionalidade do programa coalescente (simulação coalescente).  

- 1o sub-piloto: estimar a taxa U  

- 2o sub-piloto: predizer as SADs  

- calcular a diferença entre as respostas atuais e anteriores  

- descrever a diferença por um modelo gaussiano misto  

- Estudo das equações de conversão de parâmetros: validar com uma simulação espacialmente explícita:  

1) fazer a estimativa de m para os sítios amostrados a partir de uma simulação espacialmente explícita que desconsidera a perda de habitat (referência).  

2) calcular a taxa m’ usando a proposta do Coutinho e minha (olhar e-mail do encaminhamento 1) e usando a que eu fiz (pretendo implementar usando integração de Monte Carlo).  

- Simular as SADs preditas por MNEI (eu fiz uma primeira pesquisa, e a fórmula de amostragem de Etienne 2005 está mais atualizado no pacote GUILDS ao invés do pacote untb).   

### Sortear sítios ao longo do gradiente de cobertura vegetal 

```{r dados,message=FALSE}
### dados ###
# leitura
df_resultados <- read.csv(file="/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/simulacao_codigos_e_resultados/resultados/df_resultados.csv",
                            header = TRUE,as.is=FALSE)[,1:13]
# padronização
level_k <- as.character(unique(sort(as.numeric(df_resultados$k),decreasing = TRUE)))
df_resultados$k <- factor(df_resultados$k,levels = level_k)
levels(df_resultados$k)[19] <- "0.1"
# z score
f_z <- function(x){
  m <- base::mean(x,na.rm=FALSE)
  sd <- sd(x,na.rm=FALSE)
  output <- (x-m)/sd
  return(output)
} 
# names(df_resultados)
# str(df_resultados)
df_resultados %<>% mutate(diffS_gamma = diffS_mean + min(diffS_mean)*(-1) + 0.01,
                          modulo_diffS = abs(diffS_mean),
                          log_Sobs=log(S_obs))

df_resultados.z <- as.data.frame(apply(df_resultados[,c("p","Ntotal","log_Sobs","k_1","d_Lplot","d","modulo_diffS")],2,f_z))
names(df_resultados.z) <- sapply(names(df_resultados.z), function(x) paste0(x,".z"))
df_resultados %<>% cbind(.,df_resultados.z) %>% 
  select(-k_1,-k_1.z)
```

# Ap Final BIE 5770

```{r gráficos}
#
df_SADs.disponiveis <- read.csv(
  "/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/dados_para_iniciar_artigo/df_SADs_disponiveis.csv",
  header =T)
df_SADs.disponiveis %<>% 
  filter(method=="parcelas" &
           grepl("*contiguous*",arrangement) & 
           effort_ha>=1 &
           grepl("*yes*",status) & 
           grepl("ok*",status_diagnostico) &
           grepl("Atlantic_Forest*",domain) &
           dbh_cutoff %in% c("PBH>=15.0cm","PBH>=15.7cm",
                             "DBH>=5.0cm","DGH>=5.0cm","DBH>5.0cm",
                             "DBH>=4.8cm",
                             "DBH>=5.0cm&H>300cm","DBH>=5.0cm&H>500cm", 
                             "DGH30>=5.0cm")
         )
# df_SADs.disponiveis %>%
#   select(status_diagnostico:effort_ha) %>% 
#   select(-c(state,samples))


## dados disponíveis: usando landsat8 (ano referência 2000)
df_S1 <- read.csv("/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/resultados_e_SI/tabelaSI1.csv",
                  header = TRUE) %>% 
  mutate(year_plot = ifelse(is.na(year_data),year,year_data))
df_S1$year_plot[df_S1$year_plot=="2012_2013"] <- "2012.5"
df_S1$year_plot <- as.numeric(df_S1$year_plot)
### Filtros usados
### filtro universidades e campi
# df_filtro.UC <- df_1ofiltro %>% 
#   filter(UC_area_ha >= 1000 | 
#          Unidade_de_conservacao %in% c("UC Protecao Integral","universities and research centers"))
# ### filtro estados
# df_filtro.estate <- filter(df_1ofiltro,state %in% c("RJ","RS") & year >= 1990)
# df_filtro.estate %<>% rbind(.,filter(df_1ofiltro,state %in% c("BA","GO","MS") & year >= 2000))
# df_filtro.estate %<>% rbind(.,filter(df_1ofiltro,!(state %in% c("BA","GO","MS","RJ","RS")) & year >= 1995))
df_S1$site_category <- NA
df_S1$site_category[df_S1$UC_area_ha>=1000 | 
                      df_S1$Unidade_de_conservacao %in% 
                      c("UC Protecao Integral","universities and research centers")] <- 1
df_S1$site_category[df_S1$state %in% c("RJ","RS") & 
                      df_S1$year >= 1990] <- 2
df_S1$site_category[df_S1$state %in% c("BA","GO","MS") & 
                      df_S1$year >= 2000] <- 3
df_S1$site_category[!(df_S1$state %in% c("BA","GO","MS","RJ","RS")) & 
                      df_S1$year >= 1995] <- 4
df_S1 %>%
  mutate(site_category = factor(site_category)) %>% 
  ggplot(aes(x=year_plot,y=site_category,shape=site_category)) +
  # geom_vline(xintercept = 2000,color="red") + # versão 1
  geom_vline(aes(xintercept = year_plot),color="red",alpha=0.3) + # versão 2
  # geom_boxplot() +
  geom_jitter() +
  labs(shape="Categorias:",
       y="categoria inventário florestal",
       x="ano inventário florestal",
       title= "104 inventários dentro dos critérios (de 109 confiáveis)") +
  scale_shape_discrete(breaks=c("1","2","3","4"),
                       labels=c("todas as idades: \nUC Prot. Int. | Univ. | UC>=1000 ha",
                                "RJ e RS >= 1990",
                                "BA, GO e MS >= 2000",
                                "outros estados Brasil >= 1995")) +
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
# df_S1 %>% arrange(year_plot) %>% select(year_plot,UC_area_ha,state)
```
```{r}
df_S2 <- read.csv("/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/resultados_e_SI/tabelaSI2.csv",
                  header = TRUE) %>% 
  mutate(year_plot = ifelse(is.na(year_data),year,year_data))
df_S2$year_plot[df_S2$year_plot=="2012_2013"] <- "2012.5"
df_S2$year_plot <- as.numeric(df_S2$year_plot)
df_S2$site_category <- "1"
df_S2 %>%
  mutate(site_category = factor(site_category)) %>% 
  ggplot(aes(x=year_plot,y=site_category,shape=site_category)) +
  geom_vline(aes(xintercept = year_plot),color="red",alpha=0.6) + # versão 2
  # geom_boxplot() +
  geom_jitter() +
  labs(shape="",
       y="",
       x="ano inventário florestal",
       title= "109 inventários com SAD e coordenada confiáveis") +
  scale_shape_discrete(breaks="") +
                       # labels="- Atlantic Forest \n- DBH >= 5.0cm \n- plot >= 1ha") +
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
```

# Ap Final BIE 5770

# Piloto

Plano:  
  
1) amostrar 30 pontos de uma uniforme de 0 a 1  

2) subtrair, para cada ponto sorteado em 1, a proporção de cobertura vegetal observada (coluna 'p')  

3) selecionar, para cada ponto sorteado em 1, aquele que obteve menor diferença em 2  


```{r df_piloto}
f_random_byVar <- function(x = df_resultados,
                           column_name = "p", 
                           n_sample = 30, 
                           i_seed = 260320223){
  # amostragem de uma uniforme
  set.seed(i_seed)
  sample_points <- sort(runif(n = n_sample, min = 0, max = 1))
  # encontrar os valores mais próoximos
  df_x <- filter(x,k==levels(x$k)[1],MN=="EE")
  f_index <- function(X=df_x,
                      name=column_name,
                      v_ref){
    which.min(abs(X[[column_name]] - v_ref))
  }
  # remover os sítios repetidos
  v_sites <- df_x[sapply(sample_points,function(y) f_index(v_ref=y)),"SiteCode"] %>% unique
  df_return <- filter(x,SiteCode %in% v_sites,MN=="EE")
  df_return$SiteCode <- factor(df_return$SiteCode)
  return(df_return)
}
df_piloto <- f_random_byVar(x=df_resultados)
write.csv(df_piloto,file = "df_piloto.csv",row.names = FALSE)
```


```{r graficos df_piloto,echo=FALSE}
df_piloto <- read.csv(file="df_piloto.csv", header = TRUE)
# gráficos exploratóritos
df_piloto %>% 
  filter(k==unique(df_piloto$k)[1]) %>% 
  ggplot(aes(x=p,y=S_obs)) + 
  geom_point() +
  ggtitle(label="Sítios Sorteados") +
  labs(x="% Tree cover (p)",y="Species Richness")
```

NOTA :: Mapas de cobertura vegetal para os trabalhos pilotos

É suficiente recortar os atuais mapas de 10x10km2 para mapas de 4x4km2,
pois sempre é aplicado uma função que impõe que a densidade de pixels é igual à densidade de indivíduos na área amostral. 
Portanto, posso pular o trabalho com os mapas de cobertura vegetal e apenas fazer o recorte. Porém, como se estima
o recorte certo? Todos tem as mesmas dimensões, mas mudam na resolução. Podemos usar uma regra de três simples
aplicada ao número de colunas e linhas: se x colunas correspondem à 10km quanto corresponde à 4? 

#### Análise de Escala de Efeito:


a) calculo de p para cada valor de raio;  
b) ajuste de glm.nb para cada conjunto de dados;  
c) média ponderada pelo peso de evidência da comparação de todos os glm.nb ajustados.  

  
```{r janela de codigo 2 _ scale of effect, echo=TRUE,results="hide",eval=FALSE,cache=TRUE}
# dados brutos
df_dados <- read.csv("/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/resultados_e_SI/tabelaSI1.csv",header = TRUE)
#
df_se <- left_join(y=df_dados,
                   x=expand.grid(SiteCode = df_dados$SiteCode,
                                 raio_km = c(seq(sqrt(max(df_dados$effort_ha)*0.01)+0.1,
                                               12,by = 0.1),12) ),
                   by="SiteCode") %>% 
  group_by(tif.name) %>% nest()
df_se$resultado <- vector("list",length = nrow(df_se))
# rotina
registerDoMC(2)
for(i in 1:nrow(df_se)){
  # raster de paisagem (landsat8 Hansen et al. 2013)
  raster_ <- raster(df_se$tif.name[i])
  mat_raster <- matrix(data = getValues(raster_)/100)
  dim(mat_raster) <- dim(raster_)[1:2]
  # função para o calculo da cobertura da paisagem local
  f_p <- function(raio_KM){
    # 1 pixel = 30x30m
    # raio = metade do lado da paisagem local
    raio_pixels <- round(raio_KM * 1000 / 30)
    raio_max <- nrow(mat_raster)/2
    local_land <- mat_raster[(raio_max+1-raio_pixels):(raio_max+raio_pixels),
                             (raio_max+1-raio_pixels):(raio_max+raio_pixels)]
    # proporção de cobertura vegetal
    v_p <- sum(local_land,na.rm = NULL)/length(local_land)
    # para cada raio há a proporção de cobertura calculada e o raio efetivo que depende do tamanho do pixel
    df_ <- data.frame(p=v_p,raio_efetivo.KM=raio_pixels*30/1000)
    return(df_)
  }
  # dados para a f_p
  df_se$resultado[i][[1]] <- adply(df_se$data[i][[1]]$raio_km,1,f_p,.id = NULL,.parallel = TRUE)
}
# dados por raio
df_se %<>% unnest(cols = c(data,resultado)) %>% as.data.frame()
write.csv(df_se,file="/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/resultados_e_SI/df_escalaEfeito.csv",row.names = FALSE)
```


```{r estatisticas descritivas da variacao em p entre escalas,echo=FALSE}
df_se <- read.csv(file="/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/resultados_e_SI/df_escalaEfeito.csv",header = T)
df_se %>% ddply(.,"SiteCode",summarise,
                p_mean = mean(p), 
                p_var = var(p)) %>% 
  mutate(p_coef = sqrt(p_var)/p_mean) %>% 
  # arrange(p_coef) %>% tail
  ggplot(aes(x=p_coef,y=)) + geom_density() + #bins=60 
  ggtitle(label="coeficiente de variação da variavel p entre as extensões espaciais")
```


```{r selecao da escala espacial, echo=TRUE}
df_se <- read.csv(file="/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/resultados_e_SI/df_escalaEfeito.csv",header = T)
# ajuste de modelos aos dados
library(MASS)
f_glm.nb <- function(data_){
  md_ <- glm.nb(S_obs ~ p + I(p^2) + offset(log(Ntotal)), data = data_)
}
registerDoMC(3)
l_md <- dlply(df_se,"raio_km",f_glm.nb,.parallel = TRUE)
# média ponderada dos raios pelo peso de evidência
df_averageSE <- print(AICctab(l_md,weights=TRUE)) %>% 
  as.data.frame()
df_averageSE$raio_paisagem <- row.names(df_averageSE) %>% as.numeric()
df_averageSE$weight <- as.numeric(as.character(df_averageSE$weight))
df_averageSE$dAICc <- as.numeric(as.character(df_averageSE$dAICc))
# (raio_medio <- round(weighted.mean(x = df_averageSE$raio_paisagem,w = df_averageSE$weight),1))  
raio_medio <- mean(df_averageSE %>% filter(dAICc==0) %>% .$raio_paisagem)
df_averageSE %>% 
  # mutate(diff_moda = max(df_averageSE$weight) - weight) %>% 
  # filter(diff_moda < 0.0005) %>% dim
  ggplot(aes(x=raio_paisagem,y=weight)) +
  geom_line() + 
  geom_vline(xintercept = raio_medio,color="red",alpha=0.5) + 
  annotate(geom="text",x=raio_medio+1.3,y=0.002,label=paste0("raio médio = ",raio_medio," km"),size=3) +
  theme_classic()
```

O raio médio = `r raio_medio` (2.07) e portanto o lado da paisagem é de `r 2*raio_medio`km e área total de 1713.96 hectares  
  
O lado anterior é de 10.2x10.2, o lado atual é 4.14x4.14.

```{r recorte das paisagens para piloto,echo=FALSE}
df_piloto <- read.csv(file="/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/df_piloto.csv", header = TRUE)
df_sims <- read.csv("/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/simulacao_codigos_e_resultados/df_simulacao.csv",
                    header = TRUE) %>% 
  filter(SiteCode %in% unique(df_piloto$SiteCode)) %>% 
  select(!(U_med:theta))
# estudo funcao
# file_path <- df_sims$txt.name[3]
f_recorte <- function(file_path){
  mat_paisagem <- read.table(file=file_path,sep=" ",header=TRUE) %>% 
    as.matrix
  v_dim_novo <- dim(mat_paisagem) - round(dim(mat_paisagem) * (4.14/10.2),0)
  v_dim <- dim(mat_paisagem)
  mat_paisagem_output <- mat_paisagem[floor(v_dim_novo[1]/2):(v_dim[1]-1-ceiling(v_dim_novo[1]/2)),
                                      floor(v_dim_novo[2]/2):(v_dim[2]-1-ceiling(v_dim_novo[2]/2))]
  write.table(mat_paisagem_output,
              file=gsub("dados_para_iniciar_artigo",
                        "piloto_MNEE_4x4km",
                        file_path),
              sep=" ", 
              row.names = FALSE,col.names = FALSE)
  tree.cover <- as.vector(mat_paisagem_output)
  p <- 1 - length(tree.cover[tree.cover==0])/length(tree.cover)
  return(p)
}
# image(mat_paisagem)
df_ <- df_sims %>% filter(k==0.05)
df_$p2 <- aaply(df_$txt.name,1,f_recorte)
# 
# 
# # mat_paisagem_output %>% dim
# # c(floor(v_dim_novo[1]/2):(v_dim[1]-ceiling(v_dim_novo[1]/2))) %>% length()
# image(mat_paisagem,main="10.2x10.2km2")
# image(mat_paisagem_output,main="4.14x4.14km2")
df_ %>% 
  ggplot(aes(x=p,y=p2)) +
  geom_abline(slope = 1,intercept = 0,color="red",alpha=0.6) +
  geom_point()
###
df_sims <- left_join(x=df_sims,
                     y=select(df_,SiteCode,p2),
                     by="SiteCode") %>% 
  mutate(txt.name_antigo = txt.name,
         txt.name = gsub("dados_para_iniciar_artigo",
                        "piloto_MNEE_4x4km",
                        txt.name_antigo))

```
  
```{r janela de codigo 7,echo=TRUE,eval=TRUE}
dinamica_coalescente <- function(U, S=0, N_simul, seed, disp_range, disp_kernel, landscape){
  # Runs coalescent simulations for a given heterogeneous landscape
  #
  # Parameters:
  # U: speciation rate
  # S: observed richness (integer) - used to fit the value of U, or set to
  #       0 (default) if that is not desired
  # N_simul: number of simulations
  # seed: seed of the RNG (an integer)
  # disp_range: width of the dispersal kernel
  # disp_kernel: an integer corresponding to the type of dispersal kernel. One of
  #               0: uniform
  #               1: normal
  #               2: Laplacian
  # landscape: either a filename containing the landscape data, or a
  #   bidimensional R array or matrix.
  #   TODO: describe the format of the input - trinary matrix)
  #
  # Returns:
  # r: an array of dimension N_simul x landscape dimensions, that is, each
  #   r[i.,] is a bidimensional array of the same shape as the landscape.
  #   Each site is labeled according to the identity of the species occupying
  #   that site.
  # U_est: estimated speciation rate. This is returned only if input parameter S > 0
  if (is.character(landscape)){
    l <- as.matrix(read.table(landscape))
    infile <- landscape
    land_dims <- dim(l)
  } else {
    land_dims <- dim(landscape)
    infile <- tempfile()
    # input file *must* be clean: no comments, headers or anything
    write.table(landscape, infile, col.names=F, row.names=F)
  }
  outfile <- tempfile()
  repeat {
    system(paste('./dinamica_coalescente', land_dims[1], land_dims[2], U, S, N_simul,
                 seed, disp_range, disp_kernel, infile, outfile))
    if (file.exists(outfile) || S == 0)
      break
    U <- U/10.
    print(paste("Decreasing value of U to", U))
    # set some lowest boundary here so simulations don't take forever
    if (U < 1e-20){
      print("Richness value too low, giving up...")
      return(NULL)
    }
  }
  r <- as.matrix(read.table(outfile))
  # transpose each grid, as output is written along lines but R reads it along columns
  # TODO: I thought I got it right, but it was wrong... please DO re-check
  #r <- aperm(r, c(1,3,2))

  # recover estimated speciation rate
  if (S > 0){
    out_con <- file(outfile)
    U_line <- strsplit(readLines(out_con, 2)[2], ' ')[[1]]
    close(out_con)
    U_est <- as.double(U_line[length(U_line)])
    return(list(r = r, U_est = U_est))
  }
  return(r)
}
```


#### Janela de Código 8:
Estimativa de U



```{r janela de codigo 8}
# replicas
n_rep.U <- 10
func1 <- function(x,replicas=n_rep.U) {
  x$U <- NA
  x <- x[rep(1:dim(x)[1],each=replicas),]
}
# nomes
df_simulacao.U <- df_sims %>% func1()
####################
# simulacao
## objetos necessarios
# system(paste0("mkdir ",getwd(),"/U")) # pasta para armazenar os data.frames, só faz uma vez
k_factor <- unique(df_simulacao.U$k) # dividi as simulações por blocos de cenário de limitação
registerDoMC(3)
for(a in 1:length(k_factor)){
  df_simU <- df_simulacao.U %>% dplyr::filter(k == k_factor[a])
  op <- options(digits.secs=6)
  funcao_imigracao <- function(i,df_temp=df_simU){
    aviao <- list()
    aviao <- dinamica_coalescente(U = 1.25e-06,
                                  S = df_temp[i,"S_obs"],
                                  N_simul = 1,
                                  seed = as.numeric(Sys.time()),
                                  disp_range = df_temp[i,"d"],
                                  disp_kernel = df_temp[i,"kernel_code"],
                                  landscape = df_temp[i,"txt.name"])
    return(aviao$U_est)
  }
  replica.sim <- as.list(1:dim(df_simU)[1])
  sim.coal_U <- llply(.data = replica.sim, .fun = funcao_imigracao, .parallel = TRUE)
  df_simU[,"U"] <- unlist(sim.coal_U)
  write.csv(df_simU,
            file=paste0("./U/","df_simU__k",k_factor[a],".csv"),row.names = FALSE)
}
```

A simulação ocorreu entre 19h58 e 21h11, totalizando 1h13. Se considerarmos 103 sítios, serão 5h45. Pras SADS eu estimo que seja fique 54h49, 2.27 dias.  