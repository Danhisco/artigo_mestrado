---
title: "Figuras Finais"
author: "Mori, Danilo"
date: "25/05/2020"
output: 
  html_document:
    toc: true
    toc_depth: 5
editor_options: 
  chunk_output_type: inline
---
<style>
body {
text-align: justify}
</style>

```{r setup, include=TRUE,echo=FALSE}
knitr::opts_chunk$set(echo = FALSE, tidy = FALSE, include = TRUE, warning = FALSE,cache = TRUE,message=FALSE,eval=TRUE)
setwd("/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/simulacao_codigos_e_resultados")
knitr::opts_knit$set(root.dir = "/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/simulacao_codigos_e_resultados")
```

```{r pacotes,eval=TRUE,echo=TRUE,warning=FALSE,message=FALSE}
library(scales)
library(parallel)
library(doMC)
library(DHARMa)
library(broom.mixed)
library(gratia)
library(mgcv)
library(bbmle)
library(lme4)
library(merTools)
library(magrittr)
library(ggplotify)
library(gridExtra)
library(scatterplot3d)
library(plotly)
library(RColorBrewer)
library(cowplot)
library(ggplot2); theme_set(theme_classic())
library(metR)
library(tidyr)
library(purrr)
library(plyr)
library(dplyr)
```

```{r dados,message=FALSE}
### dados ###
# leitura
df_resultados <- read.csv(file="/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/simulacao_codigos_e_resultados/resultados/df_resultados.csv",
                            header = TRUE,as.is=FALSE)[,1:13]
# padronização
level_k <- as.character(unique(sort(as.numeric(df_resultados$k),decreasing = TRUE)))
df_resultados$k <- factor(df_resultados$k,levels = level_k)
levels(df_resultados$k)[19] <- "0.1"
# z score
f_z <- function(x){
  m <- base::mean(x,na.rm=FALSE)
  sd <- sd(x,na.rm=FALSE)
  output <- (x-m)/sd
  return(output)
} 
# names(df_resultados)
# str(df_resultados)
df_resultados %<>% mutate(diffS_gamma = diffS_mean + min(diffS_mean)*(-1) + 0.01,
                          modulo_diffS = abs(diffS_mean),
                          log_Sobs=log(S_obs))

df_resultados.z <- as.data.frame(apply(df_resultados[,c("p","Ntotal","log_Sobs","k_1","d_Lplot","d","modulo_diffS")],2,f_z))
names(df_resultados.z) <- sapply(names(df_resultados.z), function(x) paste0(x,".z"))
df_resultados %<>% cbind(.,df_resultados.z) %>% 
  select(-k_1,-k_1.z)
```


```{r}
df_resultados$U_med %>% range
```


# Figura 1 - Sessão Material e Métodos

# Figura 2 - Sessão de Resultados

descrição: logOR por d e p, com curva de nível para logOR == 0 (linha contínua e preta, alpha>=0.6); curvas de níveis para sinalizar diffS (linha pontilhadas e preta, alpha<=0.4), linha pontilhada vermelha e área rachurada em preto são média e intervalo de confiança de diffS(MN==EE). 

```{r figura 2 logOR diffS,echo=FALSE,include=TRUE,fig.height=5,fig.width=12,message=FALSE,warning=FALSE}
################### diffS ##############################
# EE
df_md <- df_resultados %>% filter(MN=="EE") %>% distinct
md_diffS.EE <- lmer(diffS_mean ~ 1 + (1|SiteCode),data=df_md,na.action = "na.fail")
df_predEE_diffS <- predictInterval(md_diffS.EE,level = 0.95) %>% 
  apply(., 2, mean) %>% t %>% as.data.frame()
# EI
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_diffS_EI__AICcmodavg.Rdata")
df_plot_diffS <- mdAvg_diffS_EI__AICcmodavg
df_plot_diffS %<>% 
  mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
         d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
################### Pr(nRef) ###################
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_mdPredict__nRef.Rdata")
df_EE <- l_mdPredict[["EE"]]
df_EI <- l_mdPredict[["EI"]]
df_EI %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
                  d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
df_ <- apply(df_EI[,c(2,5:6)],2,arm::invlogit) %>% as.data.frame
names(df_) <- sapply(names(df_), function(x) paste0(x,"_response"))
df_nRef <- cbind(df_EI,df_,
                 logOR_EE.EI = df_EE$mod.avg.pred - df_EI$mod.avg.pred,
                 lower.logOR_EE.EI = df_EE$lower.CL - df_EI$lower.CL,
                 upper.logOR_EE.EI = df_EE$upper.CL - df_EI$upper.CL)
################# df_plot1 ###################
df_plot1 <- inner_join(x=select(df_plot_diffS,
                                mod.avg.pred,lower.CL,upper.CL,
                                p,d),
                       y=select(df_nRef,
                                mod.avg.pred_response,lower.CL_response,upper.CL_response,
                                logOR_EE.EI,lower.logOR_EE.EI,upper.logOR_EE.EI,
                                p,d),
                       by=c("p","d"))
df_plot <- do.call("rbind.fill",
                   list(
                     mutate(rename(df_plot1[,c("lower.CL",
                                               "lower.logOR_EE.EI",
                                               "p","d")],
                                   logOR=lower.logOR_EE.EI,diffS=lower.CL),
                            IC_class = "5%"),
                     mutate(rename(df_plot1[,c("mod.avg.pred",
                                               "logOR_EE.EI",
                                               "p","d")],
                                   logOR=logOR_EE.EI,diffS=mod.avg.pred),
                            IC_class = "median"),
                     mutate(rename(df_plot1[,c("upper.CL",
                                               "upper.logOR_EE.EI",
                                               "p","d")],
                                   logOR=upper.logOR_EE.EI,diffS=upper.CL),
                           IC_class = "95%")
                     )
                   )
df_plot$IC_class <- factor(df_plot$IC_class,levels = unique(df_plot$IC_class))
# objetos para os gráficos
# para área rachurada
v_range <- df_predEE_diffS[,3:2] %>% as.numeric() %>% unname()
v_limits <- df_plot1 %>% 
  select(logOR_EE.EI:upper.logOR_EE.EI) %>% as.matrix %>% as.vector %>% range
v_limits <- c(v_limits,mean(df_plot1$logOR_EE.EI))
############# gráficos #############
df_plot %>% 
  ggplot(aes(x=p,y=d,fill=logOR)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() + theme_classic() +
  scale_fill_distiller(limits = c(v_limits[1],v_limits[2]),
                       palette = "Spectral",
                       breaks = c(-30, 0, 30, 70)) +
  theme(legend.position="bottom") +
  # labs(title ="Goodness-of-fit") +
  # curva de nível de logOR
  geom_contour(aes(z=logOR),alpha=0.7, col="black",
               breaks = 0) +
  geom_text_contour(aes(z=logOR),stroke=0.2,
                    breaks = 0,
                    rotate = FALSE,
                    size=2.7) +
  # diffS
  ## área rachurada ##
  stat_subset(aes(z=diffS,
                  subset = diffS >= v_range[1] & diffS <= v_range[2]),
              alpha=0.3,color="black",size=0.1,shape=3) +
  ## curvas de nível de diffS 
  geom_contour(aes(z=diffS),
               breaks=c(-0.6,-0.25,-0.01,0.25,0.75,1.5,2.5),color="black",alpha=0.3,linetype="dotdash") +
  ## média de diffS MN==EE
  geom_contour(aes(z=diffS),
               breaks=df_predEE_diffS$fit,color="red",alpha=0.3,linetype="dotdash") +
  ## texto do contorno
  geom_text_contour(aes(z=diffS),stroke=0.2,
                    breaks = c(-0.6,-0.25,-0.01,0.25,0.75,1.5,2.5),
                    rotate = FALSE,
                    size=2.7) +
  facet_wrap(~IC_class,ncol=3)
```




# Figura 3 - Sessão Discussão 



# 3.1 - Número de SADs não refutadas (nRef)

## Sessão Resultados


```{r figura final nRef,echo=FALSE,eval=TRUE,fig.width=8,fig.height=8,message=FALSE,warning=FALSE}
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_mdPredict__nRef.Rdata")
# dados
df_plot <- bind_rows(l_mdPredict,.id = "MN")
df_plot %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
                    d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
df_ <- apply(df_plot[,c(3:4,6:7)],2,arm::invlogit) %>% as.data.frame
names(df_) <- sapply(names(df_), function(x) paste0(x,"_response"))
df_plot <- cbind(df_plot,df_)
# plots Probabilidad de não refutar
l_p <- list()
labels_IC <- c(lower.CL_response="IC 5%", upper.CL_response="IC 95%")
## predição média para ambos modelos
l_p[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred_response)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() +
  scale_fill_distiller(limits = c(0,1),palette = "Spectral") +
  theme_classic() + 
  facet_wrap(~MN,ncol=2) + 
  theme(legend.position="top",legend.title = element_blank()) +
  geom_contour(aes(z=mod.avg.pred_response),alpha=0.4, col="black",
               breaks = c(0.10,0.25,0.5,0.75,0.90)) +
  geom_text_contour(aes(z=mod.avg.pred_response),stroke=0.2,
                    breaks = c(0.10,0.25,0.5,0.75,0.90),
                    rotate = FALSE,
                    size=3)
## IC para MNEE
df_plotEE <- df_plot %>% filter(MN=="EE") %>%
  gather(key = IC_class ,value = IC_pred,lower.CL_response:upper.CL_response)
l_p[[2]] <- ggplot(df_plotEE,aes(x=p,y=d,fill=IC_pred)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() +
  scale_fill_distiller(limits = c(0,1),palette = "Spectral") +
  theme_classic() + 
  facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) +
  theme(legend.position='none') +
  geom_contour(aes(z=IC_pred),alpha=0.4, col="black",
               breaks = c(0.10,0.25,0.5,0.75,0.90)) +
  geom_text_contour(aes(z=IC_pred),stroke=0.2,
                    breaks = c(0.10,0.25,0.5,0.75,0.90),
                    rotate = FALSE,
                    size=2.7)
## IC para MNEI
df_plotEI <- df_plot %>% filter(MN=="EI") %>%
  gather(key = IC_class ,value = IC_pred,lower.CL_response:upper.CL_response)
l_p[[3]] <- ggplot(df_plotEI,aes(x=p,y=d,fill=IC_pred)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() +
  scale_fill_distiller(limits = c(0,1),palette = "Spectral") +
  theme_classic() + 
  facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) +
  theme(legend.position='none') +
  geom_contour(aes(z=IC_pred),alpha=0.4, col="black",
               breaks = c(0.10,0.50,0.90)) +
  geom_text_contour(aes(z=IC_pred),stroke=0.2,
                    breaks = c(0.10,0.50,0.90),
                    rotate = FALSE,
                    size=2.7)
## Arranjo dos gráficos
# l_p[[1]],l_p[[2]],l_p[[3]],l_p[[4]],l_p[[5]],
lay_mat <- rbind(rep(1,2),
                 rep(1,2),
                 c(2,3))
grid.arrange(grobs = l_p, layout_matrix = lay_mat,top="Probabilidade de Não Refutar")
```


### Figura 3.1 - legenda:


Predito para a probabilidade de não refutar uma SAD por modelo neutro (EE=modelo neutro de espaço explícito, EI=modelo neutro de espaço implícito) em função da  proporção de cobertura vegetal (p), distância média de dispersão (d). Nos painéis superiores há a média, nos painéis inferiores os respectivos intervalo de confiança de 5% e 95%. Utilizamos um GLMM binomial (Bolker et al. 2009) para estimar a probabilidade de não refutar uma SAD neutra,  como variável resposta o número de SADs neutras não refutadas segundo o teste KS bootstrap. O modelo cheio contou com um termo linear e quadrático para p e d na estrutura fixa, e um termo linear e quadrático para d por sítio de amostragem (estrutura aleatória). A predição do modelo médio foi calculado baseado em AICc (Burnham & Andersen 2002).



## Sessão Support Information

```{r FF nRef: graficos diagnosticos,eval=TRUE,echo=FALSE,fig.show='hide'}
#
df_md <- df_resultados %>% filter(MN=="EE") %>% distinct()
md_nRefEE <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                     (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                     (d.z + I(d.z^2)|SiteCode),
                   family = "binomial",data=df_md,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)),
                   na.action = "na.fail")
df_md <- df_resultados %>% filter(MN=="EI") %>% distinct()
md_nRefEI <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                      (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                      (d.z + I(d.z^2)|SiteCode),
                 family = "binomial",data=df_md,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)),
                 na.action = "na.fail")
#
l_p <- list()
##############################
########### MNEE #############
##############################
# modelo médio
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__MuMIn.Rdata")
## Predição
df_md <- df_resultados %>% filter(MN=="EE")
df_md$Pr_nRef <- predict(mdAvg_nRefEE__MuMIn,type="response")*100
l_p[[1]] <- ggplot(df_md,aes(x=n_nRef,y=Pr_nRef)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  geom_smooth(method = "gam",aes(group=SiteCode),se = FALSE) +
  geom_abline(intercept = 0,slope=1,color="red") +
  geom_point(alpha=0.3) +
  labs(x="observado",y="predito") +
  facet_wrap(~MN,ncol=1)
## qqnorm ranef
df_ranef <- ranef(md_nRefEE)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
l_p[[2]] <- df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  ggplot(aes(sample=parameter_value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") +
  facet_wrap(~parameter_class,scales="free",ncol=1)
## diagnostico DHARMa
p_plot <- DHARMa::simulateResiduals(md_nRefEE,n=1000)
p1 <-  as.ggplot(~plotQQunif(p_plot))
p2 <-  as.ggplot(~plotResiduals(p_plot))
l_p[[3]] <- as.ggplot(grid.arrange(p1,p2,ncol=2))
##############################
########### MNEI #############
##############################
# modelo médio
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__MuMIn.Rdata")
## Predição
df_md <- df_resultados %>% filter(MN=="EI")
df_md$Pr_nRef <- predict(mdAvg_nRefEI__MuMIn,type="response")*100
l_p[[4]] <- ggplot(df_md,aes(x=n_nRef,y=Pr_nRef)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  geom_smooth(method = "gam",aes(group=SiteCode),se = FALSE) +
  geom_abline(intercept = 0,slope=1,color="red") +
  geom_point(alpha=0.3) +
  labs(x="observado",y="predito") +
  facet_wrap(~MN,ncol=1)
## qqnorm ranef
df_ranef <- ranef(md_nRefEI)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
l_p[[5]] <- df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  ggplot(aes(sample=parameter_value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") +
  facet_wrap(~parameter_class,scales="free",ncol=1)
## diagnostico DHARMa
p_plot <- DHARMa::simulateResiduals(md_nRefEI,n=1000)
p1 <-  as.ggplot(~plotQQunif(p_plot))
p2 <-  as.ggplot(~plotResiduals(p_plot))
l_p[[6]] <- as.ggplot(grid.arrange(p1,p2,ncol=2))
```

```{r diag nRef, fig.width=9,fig.height=7.5}
grid.arrange(grobs=l_p,
             layout_matrix=rbind(c(1,1,2,4,4,5),
                                 c(1,1,2,4,4,5),
                                 c(1,1,2,4,4,5),
                                 rep(c(3,6),each=3),
                                 rep(c(3,6),each=3)),
             top="Diagnóstico número de SADs não refutadas"
             )
```
  
### Figura S.1 - legenda:  
  
Gráficos diagnóstico dos modelos estatísticos ajustados para os dados separados por modelo neutro, primeira coluna modelo neutro de espaço explícito (EE), na segunda coluna o modelo neutro de espaço implícito (EI). Na primeira linha há o predito e observado para o modelo médio, em azul é o estimado pela função geom_smooth do pacote ‘ggplot2’ pelo método ‘gam’ para cada sítio de amostragem. Na segunda linha há o gráfico quantil observado e quantil esperado segundo uma distribuição normal dos coeficientes estimados na estrutura aleatória do modelo cheio. Na terceira linha há os resíduos quantílicos do modelo cheio calculados pela função 'simulateResiduals' do pacote ‘DHARMa’ (REF), primeira coluna há o gráfico quantil-quantil pressuposto distribuição uniforme, na segunda coluna regressão quantílica. Retas vermelhas correspondem à 1=1; exceto nos gráficos de regressão quantílica onde representa a reta da mediana esperada, neste gráfico a linha tracejada vermelha é a mediana estimada. No gráfico quantil-quantil pressuposto uniforme dos resíduos quantílicos há 3 testes: primeiro o de aderência dos resíduos à distribuição uniforme segundo o teste Kolmogorov-Smirnov padrão; o segundo um teste de dispersão dos dados; terceiro um teste de presença de outliers.




# 3.2 - Viés na Riqueza Estimada (diffS)

## Sessão Resultados

```{r 32 vies da riqueza estimada, fig.height=6,fig.width=4}
# EE
df_md <- df_resultados %>% filter(MN=="EE") %>% distinct
md_diffS.EE <- lmer(diffS_mean ~ 1 + (1|SiteCode),data=df_md,na.action = "na.fail")
df_predEE <- predictInterval(md_diffS.EE,level = 0.95) %>% 
  apply(., 2, mean) %>% t %>% as.data.frame()
# EI
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_diffS_EI__AICcmodavg.Rdata")
df_plot <- mdAvg_diffS_EI__AICcmodavg
df_plot %<>% 
  mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
         d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
# graficos
v_range <- df_predEE[,3:2] %>% as.numeric() %>% unname()
v_limits <- df_plot %>% select(mod.avg.pred,upper.CL,lower.CL) %>% as.matrix %>% as.vector %>% range
l_p <- list()
df_plot$MN <- "EI"
l_p[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred,z=mod.avg.pred)) +
  geom_tile() +
  coord_cartesian(expand = FALSE) +
  scale_fill_gradient2(midpoint=0, low="blue", high="red",mid="green",limits=v_limits) +
  stat_subset(aes(subset = mod.avg.pred >= v_range[1] & mod.avg.pred <= v_range[2]),
              alpha=0.5,color="black",size=0.1) +
  geom_contour(breaks=c(-0.6,-0.25,0.25,0.75,1.5,2.5),color="black",alpha=0.5) +
  geom_contour(breaks=df_predEE$fit,color="red",alpha=0.5) +
  geom_text_contour(aes(z=mod.avg.pred),stroke=0.2,
                    breaks = c(-0.6,-0.25,0.25,0.75,1.5,2.5),
                    rotate = FALSE,
                    size=2.7) +
  theme_classic() + 
  theme(legend.position="top") + labs(fill="") +
  facet_wrap(~MN,ncol=1)
labels_IC <- c(lower.CL="IC 5%", upper.CL="IC 95%")
l_p[[2]] <- df_plot %>% 
  gather(key="IC_class",value="IC_pred",lower.CL:upper.CL) %>% 
  ggplot(aes(x=p,y=d,fill=IC_pred,z=IC_pred)) +
  geom_tile() +
  coord_cartesian(expand = FALSE) +
  scale_fill_gradient2(midpoint=0, low="blue", high="red",mid="green",limits=v_limits) +
  stat_subset(aes(subset = IC_pred >= v_range[1] & IC_pred <= v_range[2]),
              alpha=0.5,color="black",size=0.1) +
  geom_contour(breaks=c(-0.6,-0.25,0.25,0.75,1.5,2.5),color="black",alpha=0.5) +
  geom_contour(breaks=df_predEE$fit,color="red",alpha=0.5) +
  # geom_text_contour(aes(z=IC_pred),stroke=0.2,
  #                   breaks = c(-0.6,-0.25,0.25,0.75,1.5,2.5),
  #                   rotate = FALSE,
  #                   size=2.7) +
  theme_classic() + 
  theme(legend.position='none') +
  facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC))
grid.arrange(grobs=l_p,
             layout_matrix=rbind(1,1,2),
             top="Viés na Riqueza Estimada")
# apply(df_predEE,2,function(X) formatC(X,format = "e",digits=3))
```

### Figura 3.2.1 - legenda:  

Predito para o viés na riqueza estimada (diffS) do modelo neutro de espaço implícito (EI) e em detalhe o predito para o modelo neutro de espaço explícito (EE, área racharuda e contorno em vermelho). No painel superior o predito pelo modelo médio, nos painéis inferiores o intervalo de confiança de 5% e 95%. Foi utilizado um LMM (Bolker et al. 2009) para descrever diffS = (S - Sobs)/Sobs, S = riqueza de espécies predita e Sobs = riqueza observada. Para EE um LMM com intercepto global (estrutura fixa) e um intercepto por sítio de amostragem (estrutura aleatória) foi suficiente para descrever o observado. Em vermelho há o contorno do valor de diffS igual à média estimada para EE (-7.14e-3) e a área racharuda corresponde aos valores de diffS dentro do intervalo de confiança de 5% e 95%, -3.410e-2 e 1.971e-02 respectivamente. Para EI um LMM com termo linear e quadrático para p e d na estrutura fixa e um termo linear para d por sítio de amostragem (estrutura aleatporia) foi usado como modelo cheio; o predito para o modelo médio foi calculado segundo AICc (Burnham & Andersen 2002). 


## Sessão Support Information

```{r fig.show='hide'}
# modelos cheios
df_md <- df_resultados %>% filter(MN=="EE") %>% distinct
md_diffS.EE <- lmer(diffS_mean ~ 1 + (1|SiteCode),data=df_md,na.action = "na.fail")
df_predEE <- predictInterval(md_diffS.EE,level = 0.95) %>% 
  apply(., 2, mean) %>% t %>% as.data.frame() %>% 
  mutate(rep=1)
df_md <- df_resultados %>% filter(MN=="EI") %>% distinct
md_diffS.EI <- lmer(diffS_mean ~ 
                      (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                      (d.z|SiteCode),
                    data=df_md, na.action = "na.fail")
# graficos
l_p <- list()
##############################
########### MNEE #############
##############################
df_md <- filter(df_resultados,MN=="EE") %>% distinct()
l_p[[1]] <- ggplot(df_md,aes(x="",y=diffS_mean)) +
  geom_jitter(alpha=0.3) +
  geom_hline(yintercept = c(df_predEE$upr,df_predEE$lwr),color="blue",size=1) +
  geom_hline(yintercept=df_predEE$fit,color="red",size=1) +
  theme(axis.ticks.x = element_blank()) +
  labs(x="",y="observado") + coord_cartesian(expand = FALSE) + facet_wrap(~MN,ncol=1)
df_ranef <- ranef(md_diffS.EE)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
l_p[[2]] <- df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  ggplot(aes(sample=parameter_value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") +
  facet_wrap(~parameter_class,scales="free",ncol=1)  
p_plot <- DHARMa::simulateResiduals(md_diffS.EE,n=1000)
p1 <-  as.ggplot(~plotQQunif(p_plot))
p2 <-  as.ggplot(~plotResiduals(p_plot,main="Residual vs. predicted"))
l_p[[3]] <- as.ggplot(grid.arrange(p1,p2,ncol=2))
##############################
########### MNEI #############
##############################
# modelo médio
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_diffS_EI__MuMIn.Rdata")
## Predição
df_md <- df_resultados %>% filter(MN=="EI")
df_md$fit <- predict(mdAvg_diffS_EI__MuMIn,type="response")
l_p[[4]] <- ggplot(df_md,aes(x=diffS_mean,y=fit)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  geom_smooth(method = "gam",aes(group=SiteCode),se = FALSE) +
  geom_abline(intercept = 0,slope=1,color="red") +
  geom_point(alpha=0.3) +
  labs(x="observado",y="predito") +
  facet_wrap(~MN,ncol=1)
## qqnorm ranef
df_ranef <- ranef(md_diffS.EI)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
l_p[[5]] <- df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  ggplot(aes(sample=parameter_value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") +
  facet_wrap(~parameter_class,scales="free",ncol=3)
## diagnostico DHARMa
p_plot <- DHARMa::simulateResiduals(md_diffS.EI,n=1000)
p1 <-  as.ggplot(~plotQQunif(p_plot))
p2 <-  as.ggplot(~plotResiduals(p_plot))
l_p[[6]] <- as.ggplot(grid.arrange(p1,p2,ncol=2))
##############################
########### arrange ##########
##############################
```

```{r fig.height=8,fig.width=6}
title <- ggdraw() + draw_label("Diagnostic for diffS models", fontface='bold')
plot_grid(title,
          plot_grid(l_p[[1]],l_p[[4]]),
          plot_grid(l_p[[2]],NULL,l_p[[5]],ncol=3,rel_widths = c(0.75,0.5,1.5)),
          plot_grid(l_p[[3]],l_p[[6]]),
          ncol=1,rel_heights = c(0.1,1,0.5,0.65))
```

### Figura S.2 - legenda:  

Gráficos diagnóstico dos modelos estatísticos ajustados para os dados separados por modelo neutro: primeira coluna - modelo neutro de espaço explícito (EE); segunda coluna - modelo neutro de espaço implícito (EI). Na primeira linha há o observado contra o predito; para EE a média em vermelho e o intervalo de 95% em azul; para EI  em azul há o estimado pela função geom_smooth do pacote ‘ggplot2’ (REF). Na segunda linha há o gráfico quantil observado e quantil esperado segundo uma distribuição normal dos coeficientes estimados na estrutura aleatória do modelo cheio. Na terceira linha há os resíduos quantílicos do pacote ‘DHARMa’, primeira coluna há o gráfico quantil-quantil pressuposto distribuição uniforme, na segunda coluna regressão quantílica. Retas vermelhas correspondem à 1=1; exceto nos gráficos de regressão quantílica onde representa a reta da mediana esperada, linha tracejada vermelha é a mediana estimada. No gráfico quantil-quantil pressuposto uniforme dos resíduos quantílicos há 3 testes: primeiro o de aderência dos resíduos à distribuição uniforme segundo o teste Kolmogorov-Smirnov padrão; o segundo um teste de dispersão dos dados; terceiro um teste de presença de outliers.

# 3.2.2. - Congruência entre nRef e diffS

## Sessão Resultados

```{r fig.height=4,fig.width=8}
ggplot(df_resultados,aes(x=diffS_mean,y=n_nRef)) +
  # coord_cartesian(expand = TRUE) +
  # scale_y_continuous(c(0,0))+
  geom_bin2d(bins=60) +
  scale_fill_continuous(type = "viridis") +
  geom_vline(xintercept = c(-0.25,0.25),color="red",alpha=0.7) +
  labs(x="diffS",y="nRef") +
  theme(legend.position = "top") +
  theme_classic() +
  facet_wrap(~MN,ncol=2,scales="free")
```

### Figura 3.2.2 - legenda:

Histograma 2D do número de ocorrência por viés na riqueza estimada (diffS) e número de SADs não refutadas (nRef) por modelo neutro (EE = modelo neutro de espaço explícito; EI = modelo neutro de espaço implícito). O plano diffS e nRef é subdivido em 30 quadrados de igual área, a cor do quadrado representa o número de ocorrências. As linhas verticais vermelhas marcam diffS = -0.25 e 0.25.


# 3.3 - Log da razão da chance MNEE/MNEI (logOR)

## Sessão Resultados

```{r log OR fig 33 log OR atualizado,fig.height=5,fig.width=12,warning=FALSE,message=FALSE}
################### Pr(nRef) ###################
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_mdPredict__nRef.Rdata")
df_EE <- l_mdPredict[["EE"]]
df_EI <- l_mdPredict[["EI"]]
df_EI %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
                  d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
df_ <- apply(df_EI[,c(2,5:6)],2,arm::invlogit) %>% as.data.frame
names(df_) <- sapply(names(df_), function(x) paste0(x,"_response"))
df_nRef <- cbind(df_EI,df_,
                 logOR_EE.EI = df_EE$mod.avg.pred - df_EI$mod.avg.pred,
                 lower.logOR_EE.EI = df_EE$lower.CL - df_EI$lower.CL,
                 upper.logOR_EE.EI = df_EE$upper.CL - df_EI$upper.CL)
################### diffS EI ###################
# EE
df_md <- df_resultados %>% filter(MN=="EE") %>% distinct
md_diffS.EE <- lmer(diffS_mean ~ 1 + (1|SiteCode),data=df_md,na.action = "na.fail")
df_predEE <- predictInterval(md_diffS.EE,level = 0.95) %>% 
  apply(., 2, mean) %>% t %>% as.data.frame()
# EI
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_diffS_EI__AICcmodavg.Rdata")
df_plot <- mdAvg_diffS_EI__AICcmodavg
df_plot %<>% 
  mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
         d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
################# df_plot1 ###################
df_plot1 <- inner_join(x=select(df_plot,
                                mod.avg.pred,lower.CL,upper.CL,
                                p,d),
                       y=select(df_nRef,
                                # mod.avg.pred_response,lower.CL_response,upper.CL_response,
                                logOR_EE.EI,lower.logOR_EE.EI,upper.logOR_EE.EI,
                                p,d),
                       by=c("p","d"))
v_limits <- df_plot1 %>% 
  select(logOR_EE.EI:upper.logOR_EE.EI) %>% as.matrix %>% as.vector %>% range
v_limits <- c(v_limits,mean(df_plot1$logOR_EE.EI))
v_range <- df_predEE[,3:2] %>% as.numeric() %>% unname()
# df_plot1 %<>% mutate(KS_f_logOR = NA, KS_f_lower.logOR = NA, KS_f_upper.logOR = NA)
# for(i in 12:14){
#   df_plot1[,i] <- ifelse(abs(df_plot1[,i-11]) > 0.25 & 
#                            df_plot1[,i-6] >0.5, 
#                          NA,"yes") %>% as.factor()
# }
############# gráficos #############
l_p <- list()
br <- c(0,1)
#### sem rachurado
df_plot1$legend1 <- "5%"
l_p[[1]] <- ggplot(df_plot1,aes(x=p,y=d,fill=lower.logOR_EE.EI)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() + theme_classic() +
  scale_fill_distiller(limits = c(v_limits[1],v_limits[2]),
                       palette = "Spectral") +
  theme(legend.position="top",
        legend.title = element_blank()) +
  # stat_subset(aes(subset=is.na(KS_f_logOR)),shape=3,alpha=0.5) +
  geom_contour(aes(z=lower.logOR_EE.EI),alpha=0.5, col="black",
               breaks = br) +
  geom_text_contour(aes(z=lower.logOR_EE.EI),stroke=0.2,
                    breaks = br,
                    rotate = FALSE,
                    size=3) +
  # diffS
  geom_contour(aes(z=lower.CL),breaks=c(-0.6,-0.25,0.25,1.5,2.5),color="black",alpha=0.5,linetype = "dotdash") +
  geom_contour(aes(z=lower.CL),breaks=df_predEE$fit,color="red",alpha=0.5) +
  geom_text_contour(aes(z=lower.CL),stroke=0.2,
                    breaks = c(-0.6,-0.25,0.25,1.5,2.5),
                    rotate = FALSE,
                    size=2.7) +
  stat_subset(aes(subset = lower.CL >= v_range[1] & lower.CL <= v_range[2]),
              alpha=0.5,color="black",size=0.3,shape=3) +
  facet_wrap(~legend1,ncol=1)
df_plot1$legend1 <- "median"
l_p[[2]] <- ggplot(df_plot1,aes(x=p,y=d,fill=logOR_EE.EI)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() + theme_classic() +
  scale_fill_distiller(limits = c(v_limits[1],v_limits[2]),
                       palette = "Spectral") +
  theme(legend.position="top",
        legend.title = element_blank()) +
  # stat_subset(aes(subset=is.na(KS_f_logOR)),shape=3,alpha=0.5) +
  geom_contour(aes(z=logOR_EE.EI),alpha=0.5, col="black",
               breaks = br) +
  geom_text_contour(aes(z=logOR_EE.EI),stroke=0.2,
                    breaks = br,
                    rotate = FALSE,
                    size=3) +
  # diffS
  geom_contour(aes(z=mod.avg.pred),breaks=c(-0.6,-0.25,0.25,1.5,2.5),color="black",alpha=0.5,linetype = "dotdash") +
  geom_contour(aes(z=mod.avg.pred),breaks=df_predEE$fit,color="red",alpha=0.5) +
  geom_text_contour(aes(z=mod.avg.pred),stroke=0.2,
                    breaks = c(-0.6,-0.25,0.25,1.5,2.5),
                    rotate = FALSE,
                    size=2.7) +
  stat_subset(aes(subset = mod.avg.pred >= v_range[1] & mod.avg.pred <= v_range[2]),
              alpha=0.5,color="black",size=0.3,shape=3) +
  facet_wrap(~legend1,ncol=1)
df_plot1$legend1 <- "95%"
l_p[[3]] <- ggplot(df_plot1,aes(x=p,y=d,fill=upper.logOR_EE.EI)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() + theme_classic() +
  scale_fill_distiller(limits = c(v_limits[1],v_limits[2]),
                       palette = "Spectral") +
  theme(legend.position="top",
        legend.title = element_blank()) +
  # stat_subset(aes(subset=is.na(KS_f_logOR)),shape=3,alpha=0.5) +
  geom_contour(aes(z=upper.logOR_EE.EI),alpha=0.5, col="black",
               breaks = br) +
  geom_text_contour(aes(z=upper.logOR_EE.EI),stroke=0.2,
                    breaks = br,
                    rotate = FALSE,
                    size=3) +
  # diffS
  geom_contour(aes(z=upper.CL),breaks=c(-0.6,-0.25,0.25,1.5,2.5),color="black",alpha=0.5,linetype = "dotdash") +
  geom_contour(aes(z=upper.CL),breaks=df_predEE$fit,color="red",alpha=0.5) +
  geom_text_contour(aes(z=upper.CL),stroke=0.2,
                    breaks = c(-0.6,-0.25,0.25,1.5,2.5),
                    rotate = FALSE,
                    size=2.7) +
  stat_subset(aes(subset = upper.CL >= v_range[1] & upper.CL <= v_range[2]),
              alpha=0.5,color="black",size=0.3,shape=3) +
  facet_wrap(~legend1,ncol=1)
grid.arrange(grobs=l_p,ncol=3)
```

### Figura 3.3 - legenda:

Log da chance da razão (log OR) de não refutar uma SAD neutra do modelo neutro de espaço explícito (EE) em relação ao modelo neutro de espaço implícito, EE,
 pelo modelo neutro de espaço implícito, EI, (log OR): direita - estimado; esquerda - rachurado se o módulo do viés da riqueza estimada for maior do que 0.25 (figura 3.2) e a probabilidade de não refutar uma SAD neutra for maior do que 0.5 (figura 3.1). O teste KS bootstrap calcula o p-valor da hipótese nula de que a SAD observada e predita são amostradas de uma mesma distribuição teórica baseado na estatística D, a maior distância entre a distribuição empirica acumulada da SAD observada e predita. O viés na riqueza estimada mede a magnitude do desvio na riqueza estimada em termos de proporção de riqueza observada. Podemos pressumir que não é razoável que a probabilidade de não refutar uma SAD neutra seja maior do que 0.5 se o módulo do viés da riqueza estimada for maior do que 0.25. Portanto, a área rachurada mostra onde o teste KS bootstrap deve estar sendo mais rigoroso para EE, que apresenta viés da riqueza estimada próxima de zero, do que para EI que apresenta grande variação no viés da riqueza estimada e pode apresentar alto número de SADs não refutadas (figura 3.3). Subtraimos o log chance estimada para EE pelo estimado para EI para calcular o log OR. 
 
 
 
# 3.4.1 - ln(U) ~ ln(Sobs)
 
## Sessão Resultados

```{r cache=TRUE}
# modelo
df_md <- df_resultados %>% filter(MN=="EE") %>% distinct()
glmer_U <- glmer(U_med ~ log_Sobs + (1|SiteCode),data=df_md,family = Gamma(link="log"))
#new data
df_newdat <- expand.grid(SiteCode=df_resultados$SiteCode[1], 
                         log_Sobs = seq(min(df_resultados$log_Sobs),max(df_resultados$log_Sobs), length=150))
## Passo 2: crie as função que devem ser calculadas dos modelos a cada simulação
## Previstos por efeitos fixos e aleatórios
f1 <- function(.) predict(., newdata=df_newdat)
## Previstos por efeitos fixos (argumento re.form=~0)
f2 <- function(.) predict(., newdata=df_newdat, re.form=~0)
## Os dois bootstraps. Ajuste o argumento ncpus para o numero de cores de seu computador
b3 <- bootMer(glmer_U, FUN = f1, nsim=1000, parallel="multicore", ncpus=2)
b4 <- bootMer(glmer_U, FUN = f2, nsim=1000, parallel="multicore", ncpus=2)
## calcula as médias e intervalos de confiança quantílicos para cada combinação de preditoras
## no novo conjunto de dados
df_newdat$mean <- apply(b3$t,2,mean)
df_newdat$IC.low <- apply(b3$t,2,quantile, 0.025)
df_newdat$IC.upp <- apply(b3$t,2,quantile, 0.975)
df_newdat$mean.fixed <- apply(b4$t,2,mean)
df_newdat$IC.low.fixed <- apply(b4$t,2,quantile, 0.025)
df_newdat$IC.upp.fixed <- apply(b4$t,2,quantile, 0.975)
df_newdat %<>% mutate(std_mean = exp(mean),
                      std_IC.low = exp(IC.low),
                      std_IC.upp = exp(IC.upp),
                      std_mean.fixed = exp(mean.fixed),
                      std_IC.low.fixed = exp(IC.low),
                      std_IC.upp.fixed = exp(IC.upp.fixed))

## graficos
df_resultados %>% 
  mutate(log_U = log(U_med)) %>% 
  ggplot(aes(x=log_Sobs,y=log_U)) + 
  # geom_ribbon(aes(y = std_mean, ymin=std_IC.low, ymax=std_IC.upp), data=df_newdat, fill="grey15", alpha=0.5) +
  # geom_ribbon(aes(y=std_mean, ymin=std_IC.low.fixed, ymax=std_IC.upp.fixed), data=df_newdat, fill="white", alpha=0.5) +
  # geom_line(aes(x=log_Sobs, y=std_mean.fixed), data=df_newdat,color="red") +
  geom_ribbon(aes(y = mean, ymin=IC.low, ymax=IC.upp), data=df_newdat, fill="grey15", alpha=0.5) +
  geom_ribbon(aes(y=mean, ymin=IC.low.fixed, ymax=IC.upp.fixed), data=df_newdat, fill="white", alpha=0.5) +
  geom_line(aes(x=log_Sobs, y=mean.fixed), data=df_newdat,color="red") +
  geom_point(alpha=0.3) +labs(x="ln(Sobs)",y="ln(U)",title="U - Estimated Especiation Rate")
```

### Legenda Figura 3.4.1:

Log da taxa de especiação estimada ( ln(U) ) pelo log da riqueza observada ( ln(Sobs) ). O modelo utilizado foi um GLMM Gamma com log da riqueza observada como preditora e um intercepto por sítio de amostragem. O modelo ajustado não apresenta boa concordância com os pressupostos do modelo estatístico. O coeficiente de determinação marginal e condicional são aproximadamente 0.48 e 0.65 respectivamente [???]. Os parâmetros do modelo ajustado são -9.479 para o intercepto e 0.9593 para a inclinação em log da riqueza observada. O valor médio estimado é a reta em vermelho; a área em cinza mais claro é o intervalo de confiança de 95% bootstrap quando consideramos apenas a estrutura fixa do modelo; a área em cinza escuro é o intervalo de confiança de 95% quando incluimos a estrutura aleatória.
 
 
## Support Information

```{r FF nRef: graficos diagnosticos 1,eval=TRUE,echo=FALSE,fig.show='hide',fig.height=6}
#
l_p <- list()
##############################
########### MNEE #############
##############################
## Predição
df_md <- augment(glmer_U) %>% 
  mutate(fit_response = exp(.fitted))
l_p[[1]] <- ggplot(df_md,aes(x=U_med,y=fit_response)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  geom_abline(intercept = 0,slope = 1,color="red") +
  geom_smooth(method = "loess",se = FALSE,color="black",aes(group=SiteCode),alpha=0.3,size=0.2) +
  geom_smooth(method = "lm",se=TRUE,color="blue",formula = y~0+x) +
  coord_cartesian(expand = TRUE) + labs(x="observado",y="predito") +
  geom_point(alpha=0.3) +
  labs(x="observado",y="predito")
## qqnorm ranef
df_ranef <- ranef(glmer_U)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
l_p[[2]] <- df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  ggplot(aes(sample=parameter_value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") +
  facet_wrap(~parameter_class,scales="free",ncol=1)
## diagnostico DHARMa
p_plot <- DHARMa::simulateResiduals(glmer_U,n=1000)
l_p[[3]] <- as.ggplot(~plot(p_plot))
## arrange
grid.arrange(grobs = l_p,layout_matrix = rbind(c(1,2),3))
```

### Legenda Figura S.XXXX:

Graficos diagnostico do GLMM para descrever o efeito de log da riqueza observada em U. No primeiro painel há o predito e observado, em vermelho a reta y=x, em azul a regressão linear sem intercepto. No segundo painel o gráfico quantil-quantil do esperado segundo uma distribuiçao normal e o observado. Na segunda linha há os gráficos do pacote DHARMa para os resíduos quantílicos. 


# 3.4.2 - U ~ f(d,p)


## Sessão Resultados

```{r include=FALSE,eval=FALSE}
# df_plot %>% summary
df_plot %>% select(lower,fit,upper) %>% apply(.,2,range) %>% formatC(.,digits=2,format="e")
```



```{r U predito, fig.height=5,fig.width=12}
# dados
df_plot <- read.csv("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/df_plotPredU.csv",
                    header = TRUE,as.is = TRUE)
## graficos
l_p <- list()
# 
df_plot$IC_pred <- "5% quantile"
l_p[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=lower)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() +
  scale_fill_distiller(palette = "Spectral") +
  theme_classic() + 
  facet_wrap(~IC_pred,ncol=1) +
  theme(legend.position="bottom",legend.title = element_blank()) +
  geom_contour(aes(z=lower),alpha=0.4, col="black",
               breaks = round(quantile(df_plot$lower,probs = c(0.1,0.25,0.5,0.75,0.9)),5)) +
  geom_text_contour(aes(z=lower),stroke=0.2,
                    breaks = round(quantile(df_plot$lower,probs = c(0.1,0.25,0.5,0.75,0.9)),5),
                    rotate = FALSE,
                    size=2.7)
#
df_plot$variable <- "median"
l_p[[2]] <- ggplot(df_plot,aes(x=p,y=d,fill=fit)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() +
  scale_fill_distiller(palette = "Spectral") +
  theme_classic() + 
  facet_wrap(~variable,ncol=1) +
  theme(legend.position="bottom",legend.title = element_blank()) +
  geom_contour(aes(z=fit),alpha=0.4, col="black",
               breaks = round(quantile(df_plot$fit,probs = c(0.1,0.25,0.5,0.75,0.9)),5) ) +
  geom_text_contour(aes(z=fit),stroke=0.2,
                    breaks = formatC(quantile(df_plot$fit,probs = c(0.1,0.25,0.5,0.75,0.9)),format = "e", digits = 3),
                    rotate = FALSE,
                    size=3)
#
df_plot$IC_pred <- "95% quantile"
l_p[[3]] <- ggplot(df_plot,aes(x=p,y=d,fill=upper)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() +
  scale_fill_distiller(palette = "Spectral") +
  theme_classic() + 
  facet_wrap(~IC_pred,ncol=1) +
  theme(legend.position="bottom",legend.title = element_blank()) +
  geom_contour(aes(z=upper),alpha=0.4, col="black",
               breaks = round(quantile(df_plot$upper,probs = c(0.1,0.25,0.5,0.75,0.9)),5)) +
  geom_text_contour(aes(z=upper),stroke=0.2,
                    breaks = round(quantile(df_plot$upper,probs = c(0.1,0.25,0.5,0.75,0.9)),5),
                    rotate = FALSE,
                    size=2.7)
grid.arrange(grobs=l_p,ncol=3,top="Speciation Rate")
```

### Figura 3.4.2 - legenda:

Predito para a taxa de especiação necessária para obter a riqueza observada no equilíbrio (U), segundo o modelo neutro de espaço explícito, em função da distância média de dispersão (d) e a proporção de cobertura vegetal na paisagem (p). Ajustamos um modelo generalizado aditivo (Wood 2017) com um smoother isotropico para cada preditora, um tensor para a interação entre as duas preditoras, e um smoother para d por sítio de amostragem com parâmetro de penalização por sítio de amostragem (Pedersen et al. 2019). Presumimos que a distribuição dos coeficiente pode ser aproximada por uma distribuição normal multivariada com média e variância igual aos coeficientes e matriz de covariância estimados pelo modelo. Então fizemos 10000 amostras dos coeficientes e calculamos os quantils de 0.05, 0.50 e 0.95 dos valores preditos para novo conjunto de dados. Notem que há grande variação no range de valores preditos para cada quantil (guia na parte inferior de cada gráfico).



## Sessão Support Information

```{r}
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/md_U.tp.Rdata")
appraise(md_U.tp)
```


### Figura S.3 - legenda:

Gráficos diagnósticos padrão do pacote "gratia" (REF). Na primeira linha e coluna há os quantils observados e esperados dos resíduos do tipo "deviance"; na segunda coluna e primeira linha há o gráfico de dispersão dos resíduos pelo preditor linear; na segunda linha e primeira coluna o histograma dos resíduos; e por último o observado contra o predito.



## Para Discussão


### Parâmetros de MNEI

```{r parametros MNEI discusssao, message=FALSE,warning=FALSE,fig.width=12,fig.height=4}
#########
# Dados #
#########
df_U <- map_df(Sys.glob("/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/simulacao_codigos_e_resultados/U/*.csv"), readr::read_csv)
df_simulacao <-  inner_join(x=distinct(dplyr::select(df_U, SiteCode, k, Ntotal, S_obs, kernel_code, DA, d, p, txt.name)),
                            y=ddply(df_U,c("SiteCode","k"),summarise,U_med = mean(U), U_var = var(U)),
                            by=c("SiteCode","k"))
# conversão de parâmetros
df_simulacao %<>% 
  mutate(J_M = 10404 * DA * p,
         L_plot = sqrt( 10000 * (Ntotal/DA) ),
         m = d * (1 - exp( -sqrt(2) * (L_plot/d) ) ) / ( sqrt(2) * L_plot ), #eq 4
         m_ = m * p / ( 1 - (1-p)*m ),#eq 5
         I =  m_ * (Ntotal-1)/(1-m_), #Etienne 2005
         theta = U_med * ( J_M - 1 ) / (1-U_med) ) #Vallade & Houshmandzadeh (2003)

############
# Graficos #
############
l_p <- list()
l_p[[1]] <- df_simulacao %>% mutate(legend = "m'") %>%
  ggplot(aes(x=p,y=m_)) + #,color=d
  geom_smooth(method="loess",se=FALSE,alpha=0.3,color="red") +
  geom_point(alpha=0.3) +
  scale_y_continuous(trans='log10') +
  annotation_logticks(sides = "l") +
  labs(y="") +
  facet_wrap(~legend)
l_p[[2]] <- df_simulacao %>% mutate(legend = "theta") %>%
  ggplot(aes(x=p,y=theta)) + #,color=d
  geom_smooth(method="loess",se=FALSE,alpha=0.3,color="red") +
  geom_point(alpha=0.3) +
  scale_y_continuous(trans='log10') +
  annotation_logticks(sides = "l") +
  labs(y="") +
  facet_wrap(~legend)
l_p[[3]] <- df_resultados %>% mutate(ratio_J = Ntotal /(10404*DA*p),legend = "N_sample / N_landscape") %>% select(p,ratio_J,SiteCode,legend) %>% unique %>% 
  ggplot(aes(x=p,y=ratio_J)) +
  geom_point(alpha = 0.8) +
  labs(x = "p",y="N_sample / N_landscape") +
  # scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
  #             labels = trans_format("log10", math_format(10^.x))) +
  scale_y_continuous(trans='log10') +
  annotation_logticks(sides = "l") +
  labs(y="") +
  facet_wrap(~legend)
l_p[[4]] <- df_resultados %>% select(p,DA,SiteCode) %>% unique %>% mutate(legend="DA(individuals / sample area)") %>% 
  ggplot(aes(x=p,y=DA)) +
  geom_point(alpha = 0.8) +
  geom_smooth(method = "loess",se=F,color="red",alpha=0.7) +
  # labs(x = "p",y="N_sample / N_landscape") +
  # scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                # labels = trans_format("log10", math_format(10^.x))) +
  scale_y_continuous(trans='log10') +
  annotation_logticks(sides = "l") +
  # labs(y="") +
  facet_wrap(~legend)
grid.arrange(grobs=l_p,ncol=3)
```

### MN==EE: nRef ~ U_med * p


```{r}
# 
# ###
# # 1)
# library(lattice)
# cloud(U_med ~ p * d, df_resultados)
# # 2)
# l_p <- df_resultados %>% 
#   # filter(p<0.35 & d>5 & MN=="EE") %>%
#   ggplot(aes(x=p,y=d)) +
#   # geom_tile(aes(fill=n_nRef))
#   geom_point(aes(color=U_med),alpha=0.8)
#   # geom_smooth(method = "loess",color="red",alpha=0.7)
# ggMarginal(l_p, type = "boxplot", fill="transparent",margins = "x")
# # 3)
plotclr <- brewer.pal(9,"PuBu") # get the colors
colornum <- cut(rank(df_resultados$U_med[df_resultados$MN=="EI"]), 9, labels=FALSE)
colcode <- plotclr[colornum]
l_p <- list()
# par(mfrow=c(1,3))
l_p[[1]] <- with(filter(df_resultados,MN=="EI"),scatterplot3d(x=U_med,y=d,z=n_nRef,
                                             angle=50,color=alpha(colcode,0.4),
                                             # main = "nRef ~ U médio * p",
                                             pch=16,type="p",zlab = "nRef",xlab = "U médio"))
```

```{r fig.width=9,fig.height=3}
# par(mfrow=c(1,3))
# plot(p ~ U_med, df_resultados,pch=16,col = alpha("black", 0.4),main="p ~ U_med")
# plot(n_nRef ~ p, df_resultados,pch=16,col = alpha("black", 0.4),ylab="nRef",main="nRef ~ p")
# plot(n_nRef ~ U_med, df_resultados,pch=16,col = alpha("black", 0.4),ylab="nRef",main="nRef ~ U_med")
l_p <- list()
l_p[[1]] <- ggplot(filter(df_resultados,MN=="EE"),aes(y=p,x=U_med)) +
  geom_point(alpha=0.3) +
  geom_density_2d(color="red") +
  labs(x="U médio")
  # stat_density_2d(aes(fill = ..level..), geom="polygon",alpha=0.5) +
  # scale_fill_gradient(low="green", high="red")
l_p[[2]] <- ggplot(filter(df_resultados,MN=="EE"),aes(y=n_nRef,x=p)) +
  geom_point(alpha=0.3) +
  geom_density_2d(color="red") +
  labs(y="nRef")
  # stat_density_2d(aes(fill = ..level..), geom="polygon",alpha=0.5) +
  # scale_fill_gradient(low="green", high="red")
l_p[[3]] <- ggplot(filter(df_resultados,MN=="EE"),aes(y=n_nRef,x=U_med)) +
  geom_point(alpha=0.3) +
  geom_density_2d(color="red") +
  labs(y="nRef",x="U médio")
  # stat_density_2d(aes(fill = ..level..), geom="polygon",alpha=0.5) +
  # scale_fill_gradient(low="green", high="red")
grid.arrange(grobs=l_p,ncol=3)
```


#### LEGENDA:
##### a) Gráfico de dispersão 3D:   
Pontos apresentam certo grau de transparência, são coloridos pelo valor de U_med que foi dividido em 9 classes (quanto mais escuro maior U_med).    
##### b) Gráfico de dispersão 2D:    
Gráficos das relações parciais entre as 3 variáveis 2 a 2. Os contornos são estimados por kernel em 2 dimensões segundo a densidade de pontos na área: quanto mais contornos maior a ocorrência de valores.   


### Scatterplot3D de MNEE: nRef ~ p  * d 

```{r}
plotclr <- brewer.pal(9,"PuBu") # get the colors
# colornum <- cut(rank(df_resultados$p[df_resultados$MN=="EE"]), 9, labels=FALSE)
# colcode <- plotclr[colornum]
l_p <- list()
# par(mfrow=c(1,3))
l_p[[1]] <- with(filter(df_resultados,MN=="EE"),
                 scatterplot3d(x=p,y=d,z=n_nRef,
                               angle=-60,color=alpha("black",0.4),
                               # main = "nRef ~ U médio * p",
                               pch=16,type="p",zlab = "nRef",
                               zlim=c(0,100),xlim=c(0,1)))
```

```{r}
l_p <- list()
l_p[[1]] <- ggplot(filter(df_resultados,MN=="EE"),aes(y=p,x=d)) +
  geom_point(alpha=0.3) +
  geom_density_2d(color="red") 
  # stat_density_2d(aes(fill = ..level..), geom="polygon",alpha=0.5) +
  # scale_fill_gradient(low="green", high="red")
l_p[[2]] <- ggplot(filter(df_resultados,MN=="EE"),aes(y=n_nRef,x=p)) +
  geom_point(alpha=0.3) +
  geom_density_2d(color="red") +
  labs(y="nRef")
  # stat_density_2d(aes(fill = ..level..), geom="polygon",alpha=0.5) +
  # scale_fill_gradient(low="green", high="red")
l_p[[3]] <- ggplot(filter(df_resultados,MN=="EE"),aes(y=n_nRef,x=d)) +
  geom_point(alpha=0.3) +
  geom_density_2d(color="red") +
  labs(y="nRef")
  # stat_density_2d(aes(fill = ..level..), geom="polygon",alpha=0.5) +
  # scale_fill_gradient(low="green", high="red")
grid.arrange(grobs=l_p,ncol=3)
```

### Scatterplot3D de MNEI: nRef ~ p  * d 

```{r}
plotclr <- brewer.pal(9,"PuBu") # get the colors
# colornum <- cut(rank(df_resultados$p[df_resultados$MN=="EE"]), 9, labels=FALSE)
# colcode <- plotclr[colornum]
l_p <- list()
# par(mfrow=c(1,3))
l_p[[1]] <- with(filter(df_resultados,MN=="EI"),
                 scatterplot3d(y=p,x=d,z=n_nRef,
                               angle=-60,color=alpha("black",0.4),
                               # main = "nRef ~ U médio * p",
                               pch=16,type="p",zlab = "nRef",
                               zlim=c(0,100),ylim=c(0,1)))
```

```{r}
l_p <- list()
l_p[[1]] <- ggplot(filter(df_resultados,MN=="EI"),aes(y=p,x=d)) +
  geom_point(alpha=0.3) +
  geom_density_2d(color="red") 
  # stat_density_2d(aes(fill = ..level..), geom="polygon",alpha=0.5) +
  # scale_fill_gradient(low="green", high="red")
l_p[[2]] <- ggplot(filter(df_resultados,MN=="EI"),aes(y=n_nRef,x=p)) +
  geom_point(alpha=0.3) +
  geom_density_2d(color="red") +
  labs(y="nRef")
  # stat_density_2d(aes(fill = ..level..), geom="polygon",alpha=0.5) +
  # scale_fill_gradient(low="green", high="red")
l_p[[3]] <- ggplot(filter(df_resultados,MN=="EI"),aes(y=n_nRef,x=d)) +
  geom_point(alpha=0.3) +
  geom_density_2d(color="red") +
  labs(y="nRef")
  # stat_density_2d(aes(fill = ..level..), geom="polygon",alpha=0.5) +
  # scale_fill_gradient(low="green", high="red")
grid.arrange(grobs=l_p,ncol=3)
```


```{r, warning=F,message=F}
df_resultados$factor_cong <- NA
df_resultados[which(df_resultados$n_nRef>50 & abs(df_resultados$diffS_mean)<0.25),"factor_cong"] <- "nRef>50 & |diffS|>0.25"
df_resultados[-which(df_resultados$n_nRef>50 & abs(df_resultados$diffS_mean)<0.25),"factor_cong"] <- "otherwise"
df_resultados$factor_cong <- factor(df_resultados$factor_cong)
df_plot <- df_resultados %>% 
  mutate(J_M = 10404 * DA * p,
         L_plot = sqrt( 10000 * (Ntotal/DA) ),
         m = d * (1 - exp( -sqrt(2) * (L_plot/d) ) ) / ( sqrt(2) * L_plot ), #eq 4
         m_ = m * p / ( 1 - (1-p)*m ),#eq 5
         I =  m_ * (Ntotal-1)/(1-m_), #Etienne 2005
         theta = U_med * ( J_M - 1 ) / (1-U_med) ) %>% 
  filter(MN=="EI")
df_plot$factor_p <- NA
df_plot[df_plot$p>0.35,"factor_p"] <- "p > 0.35"
df_plot[df_plot$p<0.35,"factor_p"] <- "p < 0.35"
df_plot$factor_cong <- factor(df_plot$factor_cong)
l_p <- list()
l_p[[1]] <- plot_ly(df_plot,
                    x = ~p, y = ~d, z = ~U_med,
                    color= ~factor_cong, colors = c('#BF382A', '#0C4B8E'),
                    ylim=range(df_resultados$diffS_mean)) %>% 
  add_markers() %>% 
  layout(scene=list(xaxis = list(title="p"),
                    yaxis = list(title="d"),
                    zaxis = list(title="U")))
# l_p[[1]]
l_p[[2]] <- plot_ly(df_plot,
                    x = ~p, y = ~theta, z = ~m_,
                    color= ~factor_cong, colors = c('#BF382A', '#0C4B8E')) %>% 
  add_markers() %>% 
  layout(scene=list(xaxis = list(title="p"),
                    yaxis = list(title="theta",type="log"),
                    zaxis = list(title="m_",type="log")))
l_p[[2]]
df_plot %>% 
  select(p,factor_cong,theta,m_) %>% 
  gather(par_class,par_value,theta:m_) %>% 
  ggplot(aes(x=p,y=par_value,color=factor_cong)) +
  geom_point(alpha=0.8) +
  # scale_x_continuous(trans = "log10") +
  scale_y_continuous(trans = "log10") +
  scale_color_manual(values=c('#BF382A', '#0C4B8E')) +
  theme(legend.position="bottom") +
  facet_wrap(~par_class,ncol=2,scales="free")
```

```{r}
l_p[[2]] <- ggplot(df_plot,aes(y=m_,x=theta,color=factor_cong)) +
  theme_bw() +
  scale_x_continuous(trans = "log10") +
  scale_y_continuous(trans = "log10") +
  geom_point(alpha=0.4) +
  aes(color=factor_cong)  +
  geom_density_2d(color="black",alpha=0.4) +
  scale_color_manual(values=c('#BF382A', '#0C4B8E')) +
  theme(legend.position = "bottom") +
  facet_grid(~factor_p)
l_p[[2]]
# ggplotly(l_p[[2]], dynamicTicks = TRUE)
# 
# 
# l_p[[3]] <- plot_ly(df_plot,
#                     x = ~U_med, y = ~d, z = ~p) %>%
#   add_markers() %>%
#   layout(scene=list(xaxis = list(title="U_med"),
#                     yaxis = list(title="d"),
#                     zaxis = list(title="p")))
# l_p[[3]]
# 
# plot(density(df_plot$p),xlim=c(0,1))
```
Para p > 0.35: onde a boa congruência de MNEI ocorre em distâncias intermediárias e quando os valores de theta são máximos para 

```{r}
l_p[[3]] <- ggplot(df_plot,aes(y=n_nRef,x=U_med,color=factor_cong)) +
  theme_bw() +
  # scale_x_continuous(trans = "log10") +
  # scale_y_continuous(trans = "log10") +
  geom_point(alpha=0.3) + #,aes(color=factor_cong) 
  # geom_density_2d(color="red") +
  scale_color_manual(values=c('#BF382A', '#0C4B8E'))
  # facet_grid(factor_cong~factor_p)
l_p[[3]]
```





```{r}
l_p[[3]] <- plot_ly(filter(df_resultados,MN=="EI"),
                    x = ~p, y = ~d, z = ~n_nRef,
                    color= ~factor_cong, colors = c('#BF382A', '#0C4B8E')) %>% 
                    # ylim=range(df_resultados$diffS_mean)) %>% 
  add_markers(opacity = 0.5) %>% 
  layout(scene=list(xaxis = list(title="p"),
                    yaxis = list(title="d"),
                    zaxis = list(title="nRef")))
l_p[[3]]

l_p[[4]] <- plot_ly(filter(df_resultados,MN=="EE"),
                    x = ~p, y = ~d, z = ~n_nRef,
                    color= ~factor_cong, colors = c('#BF382A', '#0C4B8E')) %>% 
                    # ylim=range(df_resultados$diffS_mean)) %>% 
  add_markers(opacity = 0.5) %>% 
  layout(scene=list(xaxis = list(title="p"),
                    yaxis = list(title="d"),
                    zaxis = list(title="nRef")))
l_p[[4]]
```

### Figuras Para Texto

Quando nRef < 50 onde o ponto está no espaço (U,p,d)?

```{r}
df_plot <- df_resultados %>% filter(MN=="EI") %>% distinct()
df_plot$factor_nRef <- "boa_cong"
df_plot$factor_nRef[df_plot$n_nRef < 50] <- "nRef<50"

plot_ly(df_plot,
        x=~p,y=~d,z=~U_med,
        color= ~factor_nRef, colors = c('#BF382A', '#0C4B8E')) %>% 
  add_markers(opacity = 0.5)
```

