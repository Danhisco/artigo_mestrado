---
title: "Figuras Finais"
author: "Mori, Danilo"
date: "25/05/2020"
output: 
  html_document:
    toc: true
    toc_depth: 5
editor_options: 
  chunk_output_type: inline
---
<style>
body {
text-align: justify}
</style>

```{r setup, include=TRUE,echo=FALSE}
knitr::opts_chunk$set(echo = FALSE, tidy = FALSE, include = TRUE, warning = FALSE,cache = TRUE,message=FALSE,eval=TRUE)
# setwd("~/Documentos/artigo_mestrado/1A.P_MOVER/simulacao/")
knitr::opts_knit$set(root.dir = "~/Documentos/artigo_mestrado/1A.P_MOVER/simulacao/")
```

```{r pacotes,eval=TRUE,echo=TRUE,warning=FALSE,message=FALSE}
library(parallel)
library(doMC)
library(DHARMa)
library(broom.mixed)
library(gratia)
library(mgcv)
library(bbmle)
library(lme4)
library(merTools)
library(magrittr)
library(ggplotify)
library(gridExtra)
library(cowplot)
library(ggplot2); theme_set(theme_classic())
library(metR)
library(tidyr)
library(purrr)
library(plyr)
library(dplyr)
```

```{r dados,message=FALSE}
### dados ###
# leitura
df_resultados <- read.csv(file="/home/danilo/Documentos/artigo_mestrado/1A.P_MOVER/simulacao/resultados/df_resultados.csv",
                            header = TRUE,as.is=FALSE)[,1:13]
# padronização
level_k <- as.character(unique(sort(as.numeric(df_resultados$k),decreasing = TRUE)))
df_resultados$k <- factor(df_resultados$k,levels = level_k)
levels(df_resultados$k)[19] <- "0.1"
# z score
f_z <- function(x){
  m <- base::mean(x,na.rm=FALSE)
  sd <- sd(x,na.rm=FALSE)
  output <- (x-m)/sd
  return(output)
} 
# names(df_resultados)
# str(df_resultados)
df_resultados %<>% mutate(diffS_gamma = diffS_mean + min(diffS_mean)*(-1) + 0.01,
                          modulo_diffS = abs(diffS_mean),
                          log_Sobs=log(S_obs))

df_resultados.z <- as.data.frame(apply(df_resultados[,c("p","Ntotal","log_Sobs","k_1","d_Lplot","d","modulo_diffS")],2,f_z))
names(df_resultados.z) <- sapply(names(df_resultados.z), function(x) paste0(x,".z"))
df_resultados %<>% cbind(.,df_resultados.z) %>% 
  select(-k_1,-k_1.z)
```


# 3.1 - Número de SADs não refutadas (nRef)

## Sessão Resultados


```{r figura final nRef,echo=FALSE,eval=TRUE,fig.width=8,fig.height=8,message=FALSE,warning=FALSE}
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_mdPredict__nRef.Rdata")
# dados
df_plot <- bind_rows(l_mdPredict,.id = "MN")
df_plot %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
                    d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
df_ <- apply(df_plot[,c(3:4,6:7)],2,arm::invlogit) %>% as.data.frame
names(df_) <- sapply(names(df_), function(x) paste0(x,"_response"))
df_plot <- cbind(df_plot,df_)
# plots Probabilidad de não refutar
l_p <- list()
labels_IC <- c(lower.CL_response="IC 5%", upper.CL_response="IC 95%")
## predição média para ambos modelos
l_p[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred_response)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() +
  scale_fill_distiller(limits = c(0,1),palette = "Spectral") +
  theme_classic() + 
  facet_wrap(~MN,ncol=2) + 
  theme(legend.position="top",legend.title = element_blank()) +
  geom_contour(aes(z=mod.avg.pred_response),alpha=0.4, col="black",
               breaks = c(0.10,0.25,0.5,0.75,0.90)) +
  geom_text_contour(aes(z=mod.avg.pred_response),stroke=0.2,
                    breaks = c(0.10,0.25,0.5,0.75,0.90),
                    rotate = FALSE,
                    size=3)
## IC para MNEE
df_plotEE <- df_plot %>% filter(MN=="EE") %>%
  gather(key = IC_class ,value = IC_pred,lower.CL_response:upper.CL_response)
l_p[[2]] <- ggplot(df_plotEE,aes(x=p,y=d,fill=IC_pred)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() +
  scale_fill_distiller(limits = c(0,1),palette = "Spectral") +
  theme_classic() + 
  facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) +
  theme(legend.position='none') +
  geom_contour(aes(z=IC_pred),alpha=0.4, col="black",
               breaks = c(0.10,0.25,0.5,0.75,0.90)) +
  geom_text_contour(aes(z=IC_pred),stroke=0.2,
                    breaks = c(0.10,0.25,0.5,0.75,0.90),
                    rotate = FALSE,
                    size=2.7)
## IC para MNEI
df_plotEI <- df_plot %>% filter(MN=="EI") %>%
  gather(key = IC_class ,value = IC_pred,lower.CL_response:upper.CL_response)
l_p[[3]] <- ggplot(df_plotEI,aes(x=p,y=d,fill=IC_pred)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() +
  scale_fill_distiller(limits = c(0,1),palette = "Spectral") +
  theme_classic() + 
  facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC)) +
  theme(legend.position='none') +
  geom_contour(aes(z=IC_pred),alpha=0.4, col="black",
               breaks = c(0.10,0.50,0.90)) +
  geom_text_contour(aes(z=IC_pred),stroke=0.2,
                    breaks = c(0.10,0.50,0.90),
                    rotate = FALSE,
                    size=2.7)
## Arranjo dos gráficos
# l_p[[1]],l_p[[2]],l_p[[3]],l_p[[4]],l_p[[5]],
lay_mat <- rbind(rep(1,2),
                 rep(1,2),
                 c(2,3))
grid.arrange(grobs = l_p, layout_matrix = lay_mat,top="Probabilidade de Não Refutar")
```


### Figura 3.1 - legenda:


Predito para a probabilidade de não refutar uma SAD por modelo neutro (EE=modelo neutro de espaço explícito, EI=modelo neutro de espaço implícito) em função da  proporção de cobertura vegetal (p), distância média de dispersão (d). Nos painéis superiores há a média, nos painéis inferiores os respectivos intervalo de confiança de 5% e 95%. Utilizamos um GLMM binomial (Bolker et al. 2009) para estimar a probabilidade de não refutar uma SAD neutra,  como variável resposta o número de SADs neutras não refutadas segundo o teste KS bootstrap. O modelo cheio contou com um termo linear e quadrático para p e d na estrutura fixa, e um termo linear e quadrático para d por sítio de amostragem (estrutura aleatória). A predição do modelo médio foi calculado baseado em AICc (Burnham & Andersen 2002).



## Sessão Support Information

```{r FF nRef: graficos diagnosticos,eval=TRUE,echo=FALSE,fig.show='hide'}
#
df_md <- df_resultados %>% filter(MN=="EE") %>% distinct()
md_nRefEE <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                     (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                     (d.z + I(d.z^2)|SiteCode),
                   family = "binomial",data=df_md,
                   control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)),
                   na.action = "na.fail")
df_md <- df_resultados %>% filter(MN=="EI") %>% distinct()
md_nRefEI <- glmer(cbind(n_nRef,100-n_nRef) ~ 
                      (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                      (d.z + I(d.z^2)|SiteCode),
                 family = "binomial",data=df_md,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)),
                 na.action = "na.fail")
#
l_p <- list()
##############################
########### MNEE #############
##############################
# modelo médio
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEE__MuMIn.Rdata")
## Predição
df_md <- df_resultados %>% filter(MN=="EE")
df_md$Pr_nRef <- predict(mdAvg_nRefEE__MuMIn,type="response")*100
l_p[[1]] <- ggplot(df_md,aes(x=n_nRef,y=Pr_nRef)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  geom_smooth(method = "gam",aes(group=SiteCode),se = FALSE) +
  geom_abline(intercept = 0,slope=1,color="red") +
  geom_point(alpha=0.3) +
  labs(x="observado",y="predito") +
  facet_wrap(~MN,ncol=1)
## qqnorm ranef
df_ranef <- ranef(md_nRefEE)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
l_p[[2]] <- df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  ggplot(aes(sample=parameter_value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") +
  facet_wrap(~parameter_class,scales="free",ncol=1)
## diagnostico DHARMa
p_plot <- DHARMa::simulateResiduals(md_nRefEE,n=1000)
p1 <-  as.ggplot(~plotQQunif(p_plot))
p2 <-  as.ggplot(~plotResiduals(p_plot))
l_p[[3]] <- as.ggplot(grid.arrange(p1,p2,ncol=2))
##############################
########### MNEI #############
##############################
# modelo médio
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_nRefEI__MuMIn.Rdata")
## Predição
df_md <- df_resultados %>% filter(MN=="EI")
df_md$Pr_nRef <- predict(mdAvg_nRefEI__MuMIn,type="response")*100
l_p[[4]] <- ggplot(df_md,aes(x=n_nRef,y=Pr_nRef)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  geom_smooth(method = "gam",aes(group=SiteCode),se = FALSE) +
  geom_abline(intercept = 0,slope=1,color="red") +
  geom_point(alpha=0.3) +
  labs(x="observado",y="predito") +
  facet_wrap(~MN,ncol=1)
## qqnorm ranef
df_ranef <- ranef(md_nRefEI)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
l_p[[5]] <- df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  ggplot(aes(sample=parameter_value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") +
  facet_wrap(~parameter_class,scales="free",ncol=1)
## diagnostico DHARMa
p_plot <- DHARMa::simulateResiduals(md_nRefEI,n=1000)
p1 <-  as.ggplot(~plotQQunif(p_plot))
p2 <-  as.ggplot(~plotResiduals(p_plot))
l_p[[6]] <- as.ggplot(grid.arrange(p1,p2,ncol=2))
```

```{r diag nRef, fig.width=9,fig.height=7.5}
grid.arrange(grobs=l_p,
             layout_matrix=rbind(c(1,1,2,4,4,5),
                                 c(1,1,2,4,4,5),
                                 c(1,1,2,4,4,5),
                                 rep(c(3,6),each=3),
                                 rep(c(3,6),each=3)),
             top="Diagnóstico número de SADs não refutadas"
             )
```
  
### Figura S.1 - legenda:  
  
Gráficos diagnóstico dos modelos estatísticos ajustados para os dados separados por modelo neutro, primeira coluna modelo neutro de espaço explícito (EE), na segunda coluna o modelo neutro de espaço implícito (EI). Na primeira linha há o predito e observado para o modelo médio, em azul é o estimado pela função geom_smooth do pacote ‘ggplot2’ pelo método ‘gam’ para cada sítio de amostragem. Na segunda linha há o gráfico quantil observado e quantil esperado segundo uma distribuição normal dos coeficientes estimados na estrutura aleatória do modelo cheio. Na terceira linha há os resíduos quantílicos do modelo cheio calculados pela função 'simulateResiduals' do pacote ‘DHARMa’ (REF), primeira coluna há o gráfico quantil-quantil pressuposto distribuição uniforme, na segunda coluna regressão quantílica. Retas vermelhas correspondem à 1=1; exceto nos gráficos de regressão quantílica onde representa a reta da mediana esperada, neste gráfico a linha tracejada vermelha é a mediana estimada. No gráfico quantil-quantil pressuposto uniforme dos resíduos quantílicos há 3 testes: primeiro o de aderência dos resíduos à distribuição uniforme segundo o teste Kolmogorov-Smirnov padrão; o segundo um teste de dispersão dos dados; terceiro um teste de presença de outliers.




# 3.2 - Viés na Riqueza Estimada (diffS)

## Sessão Resultados

```{r 32 vies da riqueza estimada, fig.height=6,fig.width=4}
# EE
df_md <- df_resultados %>% filter(MN=="EE") %>% distinct
md_diffS.EE <- lmer(diffS_mean ~ 1 + (1|SiteCode),data=df_md,na.action = "na.fail")
df_predEE <- predictInterval(md_diffS.EE,level = 0.95) %>% 
  apply(., 2, mean) %>% t %>% as.data.frame()
# EI
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_diffS_EI__AICcmodavg.Rdata")
df_plot <- mdAvg_diffS_EI__AICcmodavg
df_plot %<>% 
  mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
         d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
# graficos
v_range <- df_predEE[,3:2] %>% as.numeric() %>% unname()
v_limits <- df_plot %>% select(mod.avg.pred,upper.CL,lower.CL) %>% as.matrix %>% as.vector %>% range
l_p <- list()
df_plot$MN <- "EI"
l_p[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=mod.avg.pred,z=mod.avg.pred)) +
  geom_tile() +
  coord_cartesian(expand = FALSE) +
  scale_fill_gradient2(midpoint=0, low="blue", high="red",mid="green",limits=v_limits) +
  stat_subset(aes(subset = mod.avg.pred >= v_range[1] & mod.avg.pred <= v_range[2]),
              alpha=0.5,color="black",size=0.1) +
  geom_contour(breaks=c(-0.6,-0.25,0.25,0.75,1.5,2.5),color="black",alpha=0.5) +
  geom_contour(breaks=df_predEE$fit,color="red",alpha=0.5) +
  geom_text_contour(aes(z=mod.avg.pred),stroke=0.2,
                    breaks = c(-0.6,-0.25,0.25,0.75,1.5,2.5),
                    rotate = FALSE,
                    size=2.7) +
  theme_classic() + 
  theme(legend.position="top") + labs(fill="") +
  facet_wrap(~MN,ncol=1)
labels_IC <- c(lower.CL="IC 5%", upper.CL="IC 95%")
l_p[[2]] <- df_plot %>% 
  gather(key="IC_class",value="IC_pred",lower.CL:upper.CL) %>% 
  ggplot(aes(x=p,y=d,fill=IC_pred,z=IC_pred)) +
  geom_tile() +
  coord_cartesian(expand = FALSE) +
  scale_fill_gradient2(midpoint=0, low="blue", high="red",mid="green",limits=v_limits) +
  stat_subset(aes(subset = IC_pred >= v_range[1] & IC_pred <= v_range[2]),
              alpha=0.5,color="black",size=0.1) +
  geom_contour(breaks=c(-0.6,-0.25,0.25,0.75,1.5,2.5),color="black",alpha=0.5) +
  geom_contour(breaks=df_predEE$fit,color="red",alpha=0.5) +
  # geom_text_contour(aes(z=IC_pred),stroke=0.2,
  #                   breaks = c(-0.6,-0.25,0.25,0.75,1.5,2.5),
  #                   rotate = FALSE,
  #                   size=2.7) +
  theme_classic() + 
  theme(legend.position='none') +
  facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC))
grid.arrange(grobs=l_p,
             layout_matrix=rbind(1,1,2),
             top="Viés na Riqueza Estimada")
# apply(df_predEE,2,function(X) formatC(X,format = "e",digits=3))
```

### Figura 3.2 - legenda:  

Predito para o viés na riqueza estimada (diffS) do modelo neutro de espaço implícito (EI) e em detalhe o predito para o modelo neutro de espaço explícito (EE, área racharuda e contorno em vermelho). No painel superior o predito pelo modelo médio, nos painéis inferiores o intervalo de confiança de 5% e 95%. Foi utilizado um LMM (Bolker et al. 2009) para descrever diffS = (S - Sobs)/Sobs, S = riqueza de espécies predita e Sobs = riqueza observada. Para EE um LMM com intercepto global (estrutura fixa) e um intercepto por sítio de amostragem (estrutura aleatória) foi suficiente para descrever o observado. Em vermelho há o contorno do valor de diffS igual à média estimada para EE (-7.14e-3) e a área racharuda corresponde aos valores de diffS dentro do intervalo de confiança de 5% e 95%, -3.410e-2 e 1.971e-02 respectivamente. Para EI um LMM com termo linear e quadrático para p e d na estrutura fixa e um termo linear para d por sítio de amostragem (estrutura aleatporia) foi usado como modelo cheio; o predito para o modelo médio foi calculado segundo AICc (Burnham & Andersen 2002). 


## Sessão Support Information

```{r fig.show='hide'}
# modelos cheios
df_md <- df_resultados %>% filter(MN=="EE") %>% distinct
md_diffS.EE <- lmer(diffS_mean ~ 1 + (1|SiteCode),data=df_md,na.action = "na.fail")
df_predEE <- predictInterval(md_diffS.EE,level = 0.95) %>% 
  apply(., 2, mean) %>% t %>% as.data.frame() %>% 
  mutate(rep=1)
df_md <- df_resultados %>% filter(MN=="EI") %>% distinct
md_diffS.EI <- lmer(diffS_mean ~ 
                      (p.z + I(p.z^2)) * (d.z + I(d.z^2)) + 
                      (d.z|SiteCode),
                    data=df_md, na.action = "na.fail")
# graficos
l_p <- list()
##############################
########### MNEE #############
##############################
df_md <- filter(df_resultados,MN=="EE") %>% distinct()
l_p[[1]] <- ggplot(df_md,aes(x="",y=diffS_mean)) +
  geom_jitter(alpha=0.3) +
  geom_hline(yintercept = c(df_predEE$upr,df_predEE$lwr),color="blue",size=1) +
  geom_hline(yintercept=df_predEE$fit,color="red",size=1) +
  theme(axis.ticks.x = element_blank()) +
  labs(x="",y="observado") + coord_cartesian(expand = FALSE) + facet_wrap(~MN,ncol=1)
df_ranef <- ranef(md_diffS.EE)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
l_p[[2]] <- df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  ggplot(aes(sample=parameter_value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") +
  facet_wrap(~parameter_class,scales="free",ncol=1)  
p_plot <- DHARMa::simulateResiduals(md_diffS.EE,n=1000)
p1 <-  as.ggplot(~plotQQunif(p_plot))
p2 <-  as.ggplot(~plotResiduals(p_plot,main="Residual vs. predicted"))
l_p[[3]] <- as.ggplot(grid.arrange(p1,p2,ncol=2))
##############################
########### MNEI #############
##############################
# modelo médio
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_diffS_EI__MuMIn.Rdata")
## Predição
df_md <- df_resultados %>% filter(MN=="EI")
df_md$fit <- predict(mdAvg_diffS_EI__MuMIn,type="response")
l_p[[4]] <- ggplot(df_md,aes(x=diffS_mean,y=fit)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  geom_smooth(method = "gam",aes(group=SiteCode),se = FALSE) +
  geom_abline(intercept = 0,slope=1,color="red") +
  geom_point(alpha=0.3) +
  labs(x="observado",y="predito") +
  facet_wrap(~MN,ncol=1)
## qqnorm ranef
df_ranef <- ranef(md_diffS.EI)$SiteCode 
df_ranef$SiteCode <- row.names(df_ranef)
row.names(df_ranef) <- NULL
l_p[[5]] <- df_ranef %>% 
  gather(key = parameter_class,value = parameter_value, -SiteCode) %>% 
  ggplot(aes(sample=parameter_value)) + 
  stat_qq(alpha=0.3) + stat_qq_line(alpha=0.3,col="red") +
  facet_wrap(~parameter_class,scales="free",ncol=3)
## diagnostico DHARMa
p_plot <- DHARMa::simulateResiduals(md_diffS.EI,n=1000)
p1 <-  as.ggplot(~plotQQunif(p_plot))
p2 <-  as.ggplot(~plotResiduals(p_plot))
l_p[[6]] <- as.ggplot(grid.arrange(p1,p2,ncol=2))
##############################
########### arrange ##########
##############################
```

```{r fig.height=8,fig.width=6}
title <- ggdraw() + draw_label("Diagnostic for diffS models", fontface='bold')
plot_grid(title,
          plot_grid(l_p[[1]],l_p[[4]]),
          plot_grid(l_p[[2]],NULL,l_p[[5]],ncol=3,rel_widths = c(0.75,0.5,1.5)),
          plot_grid(l_p[[3]],l_p[[6]]),
          ncol=1,rel_heights = c(0.1,1,0.5,0.65))
```

### Figura S.2 - legenda:  

Gráficos diagnóstico dos modelos estatísticos ajustados para os dados separados por modelo neutro: primeira coluna - modelo neutro de espaço explícito (EE); segunda coluna - modelo neutro de espaço implícito (EI). Na primeira linha há o observado contra o predito; para EE a média em vermelho e o intervalo de 95% em azul; para EI  em azul há o estimado pela função geom_smooth do pacote ‘ggplot2’ (REF). Na segunda linha há o gráfico quantil observado e quantil esperado segundo uma distribuição normal dos coeficientes estimados na estrutura aleatória do modelo cheio. Na terceira linha há os resíduos quantílicos do pacote ‘DHARMa’, primeira coluna há o gráfico quantil-quantil pressuposto distribuição uniforme, na segunda coluna regressão quantílica. Retas vermelhas correspondem à 1=1; exceto nos gráficos de regressão quantílica onde representa a reta da mediana esperada, linha tracejada vermelha é a mediana estimada. No gráfico quantil-quantil pressuposto uniforme dos resíduos quantílicos há 3 testes: primeiro o de aderência dos resíduos à distribuição uniforme segundo o teste Kolmogorov-Smirnov padrão; o segundo um teste de dispersão dos dados; terceiro um teste de presença de outliers.

# 3.3 - Congruência entre nRef e diffS

## Sessão Resultados

```{r fig.height=4,fig.width=8}
ggplot(df_resultados,aes(x=diffS_mean,y=n_nRef)) +
  # coord_cartesian(expand = TRUE) +
  # scale_y_continuous(c(0,0))+
  geom_bin2d(bins=60) +
  scale_fill_continuous(type = "viridis") +
  geom_vline(xintercept = c(-0.25,0.25),color="red",alpha=0.7) +
  labs(x="diffS",y="nRef") +
  theme(legend.position = "top") +
  theme_classic() +
  facet_wrap(~MN,ncol=2,scales="free")
```

### Figura 3.3 - legenda:

Histograma 2D do número de ocorrência por viés na riqueza estimada (diffS) e número de SADs não refutadas (nRef) por modelo neutro (EE = modelo neutro de espaço explícito; EI = modelo neutro de espaço implícito). O plano diffS e nRef é subdivido em 30 quadrados de igual área, a cor do quadrado representa o número de ocorrências. As linhas verticais vermelhas marcam diffS = -0.25 e 0.25.


## Sessão Support Information

# 3.4 - Log da razão da chance MNEE/MNEI (logOR)

## Sessão Resultados

```{r log OR fig 34,fig.width=8,fig.height=8}
################### Pr(nRef) ###################
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/l_mdPredict__nRef.Rdata")
df_EE <- l_mdPredict[["EE"]]
df_EI <- l_mdPredict[["EI"]]
df_EI %<>% mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
                  d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
df_ <- apply(df_EI[,c(2,5:6)],2,arm::invlogit) %>% as.data.frame
names(df_) <- sapply(names(df_), function(x) paste0(x,"_response"))
df_nRef <- cbind(df_EI,df_,
                 logOR_EE.EI = df_EE$mod.avg.pred - df_EI$mod.avg.pred,
                 lower.logOR_EE.EI = df_EE$lower.CL - df_EI$lower.CL,
                 upper.logOR_EE.EI = df_EE$upper.CL - df_EI$upper.CL)
################### diffS EI ###################
load(file="~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/mdAvg_diffS_EI__AICcmodavg.Rdata")
df_plot <- mdAvg_diffS_EI__AICcmodavg
df_plot %<>% 
  mutate(p = p.z * sd(df_resultados$p) + mean(df_resultados$p),
         d = d.z*sd(df_resultados$d) + mean(df_resultados$d))
################# df_plot1 ###################
df_plot1 <- inner_join(x=select(df_plot,
                                mod.avg.pred,lower.CL,upper.CL,
                                p,d),
                       y=select(df_nRef,
                                mod.avg.pred_response,lower.CL_response,upper.CL_response,
                                logOR_EE.EI,lower.logOR_EE.EI,upper.logOR_EE.EI,
                                p,d),
                       by=c("p","d"))
v_limits <- df_plot1 %>% 
  select(logOR_EE.EI:upper.logOR_EE.EI) %>% as.matrix %>% as.vector %>% range
v_limits <- c(v_limits,mean(df_plot1$logOR_EE.EI))
df_plot1 %<>% mutate(KS_f_logOR = NA, KS_f_lower.logOR = NA, KS_f_upper.logOR = NA)
for(i in 12:14){
  df_plot1[,i] <- ifelse(abs(df_plot1[,i-11]) > 0.25 & 
                           df_plot1[,i-6] >0.5, 
                         NA,"yes") %>% as.factor()
}
############# gráficos #############
l_p <- list()
br <- c(-5,-1,0,1,5,30)
#### sem rachurado
l_p[[1]] <- ggplot(df_plot1,aes(x=p,y=d,fill=logOR_EE.EI)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() + theme_classic() +
  scale_fill_distiller(limits = c(v_limits[1],v_limits[2]),
                       palette = "Spectral") +
  theme(legend.position="top",
        legend.title = element_blank()) +
  # stat_subset(aes(subset=is.na(KS_f_logOR)),shape=3,alpha=0.5) +
  geom_contour(aes(z=logOR_EE.EI),alpha=0.3, col="black",
               breaks = br) +
  geom_text_contour(aes(z=logOR_EE.EI),stroke=0.2,
                    breaks = br,
                    rotate = FALSE,
                    size=2.7)
labels_IC2 <- c(lower.logOR_EE.EI="IC 5%", upper.logOR_EE.EI="IC 95%")
df_ <- bind_rows(mutate(rename(df_plot1[,c("lower.logOR_EE.EI","KS_f_lower.logOR","p","d")],
                               logOR=lower.logOR_EE.EI,KS_f=KS_f_lower.logOR),
                        IC_class = "lower.logOR_EE.EI"),
                 mutate(rename(df_plot1[,c("upper.logOR_EE.EI","KS_f_upper.logOR","p","d")],
                               logOR=upper.logOR_EE.EI,KS_f=KS_f_upper.logOR),
                        IC_class = "upper.logOR_EE.EI"))
l_p[[2]] <- df_ %>%
  ggplot(aes(x=p,y=d,fill=logOR,z=logOR)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() + 
  theme_classic() +
  scale_fill_distiller(limits = c(v_limits[1],v_limits[2]),
                       palette = "Spectral") +
  theme(legend.position='none')  +
  facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC2)) +
  # stat_subset(aes(subset=is.na(KS_f)),shape=3,alpha=0.07) +
  geom_contour(aes(z=logOR),alpha=0.4, col="black",
               breaks = br) +
  geom_text_contour(aes(z=logOR),stroke=0.2,
                    breaks = br,
                    rotate = FALSE,
                    size=2.7)

#### com rachurado
l_p[[3]] <- ggplot(df_plot1,aes(x=p,y=d,fill=logOR_EE.EI)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() + theme_classic() +
  scale_fill_distiller(limits = c(v_limits[1],v_limits[2]),
                       palette = "Spectral") +
  theme(legend.position="top",
        legend.title = element_blank()) +
  stat_subset(aes(subset=is.na(KS_f_logOR)),shape=3,alpha=0.1) +
  geom_contour(aes(z=logOR_EE.EI),alpha=0.3, col="black",
               breaks = br) +
  geom_text_contour(aes(z=logOR_EE.EI),stroke=0.2,
                    breaks = br,
                    rotate = FALSE,
                    size=2.7)
labels_IC2 <- c(lower.logOR_EE.EI="IC 5%", upper.logOR_EE.EI="IC 95%")
df_ <- bind_rows(mutate(rename(df_plot1[,c("lower.logOR_EE.EI","KS_f_lower.logOR","p","d")],
                               logOR=lower.logOR_EE.EI,KS_f=KS_f_lower.logOR),
                        IC_class = "lower.logOR_EE.EI"),
                 mutate(rename(df_plot1[,c("upper.logOR_EE.EI","KS_f_upper.logOR","p","d")],
                               logOR=upper.logOR_EE.EI,KS_f=KS_f_upper.logOR),
                        IC_class = "upper.logOR_EE.EI"))
l_p[[4]] <- df_ %>%
  ggplot(aes(x=p,y=d,fill=logOR,z=logOR)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() + 
  theme_classic() +
  scale_fill_distiller(limits = c(v_limits[1],v_limits[2]),
                       palette = "Spectral") +
  theme(legend.position='none')  +
  facet_wrap(~IC_class,ncol=2,labeller = labeller(IC_class = labels_IC2)) +
  stat_subset(aes(subset=is.na(KS_f)),shape=3,alpha=0.03) +
  geom_contour(aes(z=logOR),alpha=0.4, col="black",
               breaks = br) +
  geom_text_contour(aes(z=logOR),stroke=0.2,
                    breaks = br,
                    rotate = FALSE,
                    size=2.7)
##### arrange
lay_mat <- rbind(c(1,3),
                 c(1,3),
                 c(2,4))
grid.arrange(grobs = l_p, layout_matrix = lay_mat,top="log Odds Ratio (EE/EI)")
```

### Figura 3.4 - legenda:

Log da chance da razão (log OR) de não refutar uma SAD neutra do modelo neutro de espaço explícito (EE) em relação ao modelo neutro de espaço implícito, EE,
 pelo modelo neutro de espaço implícito, EI, (log OR): direita - estimado; esquerda - rachurado se o módulo do viés da riqueza estimada for maior do que 0.25 (figura 3.2) e a probabilidade de não refutar uma SAD neutra for maior do que 0.5 (figura 3.1). O teste KS bootstrap calcula o p-valor da hipótese nula de que a SAD observada e predita são amostradas de uma mesma distribuição teórica baseado na estatística D, a maior distância entre a distribuição empirica acumulada da SAD observada e predita. O viés na riqueza estimada mede a magnitude do desvio na riqueza estimada em termos de proporção de riqueza observada. Podemos pressumir que não é razoável que a probabilidade de não refutar uma SAD neutra seja maior do que 0.5 se o módulo do viés da riqueza estimada for maior do que 0.25. Portanto, a área rachurada mostra onde o teste KS bootstrap deve estar sendo mais rigoroso para EE, que apresenta viés da riqueza estimada próxima de zero, do que para EI que apresenta grande variação no viés da riqueza estimada e pode apresentar alto número de SADs não refutadas (figura 3.3). Subtraimos o log chance estimada para EE pelo estimado para EI para calcular o log OR. 
 
 

# 3.5 - Taxa de especiação estimada para obter a riqueza observada no equilíbrio (U)

## Sessão Resultados

```{r U predito, fig.height=5,fig.width=12}
# dados
df_plot <- read.csv("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/df_plotPredU.csv",
                    header = TRUE,as.is = TRUE)
## graficos
l_p <- list()
# 
df_plot$IC_pred <- "5% quantile"
l_p[[1]] <- ggplot(df_plot,aes(x=p,y=d,fill=lower)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() +
  scale_fill_distiller(palette = "Spectral") +
  theme_classic() + 
  facet_wrap(~IC_pred,ncol=1) +
  theme(legend.position="bottom",legend.title = element_blank()) +
  geom_contour(aes(z=lower),alpha=0.4, col="black",
               breaks = round(quantile(df_plot$lower,probs = c(0.1,0.25,0.5,0.75,0.9)),5)) +
  geom_text_contour(aes(z=lower),stroke=0.2,
                    breaks = round(quantile(df_plot$lower,probs = c(0.1,0.25,0.5,0.75,0.9)),5),
                    rotate = FALSE,
                    size=2.7)
#
df_plot$variable <- "median"
l_p[[2]] <- ggplot(df_plot,aes(x=p,y=d,fill=fit)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() +
  scale_fill_distiller(palette = "Spectral") +
  theme_classic() + 
  facet_wrap(~variable,ncol=1) +
  theme(legend.position="bottom",legend.title = element_blank()) +
  geom_contour(aes(z=fit),alpha=0.4, col="black",
               breaks = round(quantile(df_plot$fit,probs = c(0.1,0.25,0.5,0.75,0.9)),5) ) +
  geom_text_contour(aes(z=fit),stroke=0.2,
                    breaks = formatC(quantile(df_plot$fit,probs = c(0.1,0.25,0.5,0.75,0.9)),format = "e", digits = 3),
                    rotate = FALSE,
                    size=3)
#
df_plot$IC_pred <- "95% quantile"
l_p[[3]] <- ggplot(df_plot,aes(x=p,y=d,fill=upper)) +
  coord_cartesian(expand = FALSE) + 
  geom_tile() +
  scale_fill_distiller(palette = "Spectral") +
  theme_classic() + 
  facet_wrap(~IC_pred,ncol=1) +
  theme(legend.position="bottom",legend.title = element_blank()) +
  geom_contour(aes(z=upper),alpha=0.4, col="black",
               breaks = round(quantile(df_plot$upper,probs = c(0.1,0.25,0.5,0.75,0.9)),5)) +
  geom_text_contour(aes(z=upper),stroke=0.2,
                    breaks = round(quantile(df_plot$upper,probs = c(0.1,0.25,0.5,0.75,0.9)),5),
                    rotate = FALSE,
                    size=2.7)
grid.arrange(grobs=l_p,ncol=3,top="Speciation Rate")
```

### Figura 3.5 - legenda:

Predito para a taxa de especiação necessária para obter a riqueza observada no equilíbrio (U), segundo o modelo neutro de espaço explícito, em função da distância média de dispersão (d) e a proporção de cobertura vegetal na paisagem (p). Ajustamos um modelo generalizado aditivo (Wood 2017) com um smoother isotropico para cada preditora, um tensor para a interação entre as duas preditoras, e um smoother para d por sítio de amostragem com parâmetro de penalização por sítio de amostragem (Pedersen et al. 2019). Presumimos que a distribuição dos coeficiente pode ser aproximada por uma distribuição normal multivariada com média e variância igual aos coeficientes e matriz de covariância estimados pelo modelo. Então fizemos 10000 amostras dos coeficientes e calculamos os quantils de 0.05, 0.50 e 0.95 dos valores preditos para novo conjunto de dados. Notem que há grande variação no range de valores preditos para cada quantil (guia na parte inferior de cada gráfico).



## Sessão Support Information

```{r}
load("~/Documentos/artigo_mestrado/1A.P_MOVER/Support Information/md_U.tp.Rdata")
appraise(md_U.tp)
```


### Figura S.3 - legenda:

Gráficos diagnósticos padrão do pacote "gratia" (REF). Na primeira linha e coluna há os quantils observados e esperados dos resíduos do tipo "deviance"; na segunda coluna e primeira linha há o gráfico de dispersão dos resíduos pelo preditor linear; na segunda linha e primeira coluna o histograma dos resíduos; e por último o observado contra o predito.
